// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: c_gs.60.warcup.proto

package msg

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type WarCupData struct {
	Stage      int32              `protobuf:"varint,1,opt,name=Stage,proto3" json:"Stage,omitempty"`
	Ts2        int64              `protobuf:"varint,2,opt,name=Ts2,proto3" json:"Ts2,omitempty"`
	Round      int32              `protobuf:"varint,3,opt,name=Round,proto3" json:"Round,omitempty"`
	RoundPiece int32              `protobuf:"varint,4,opt,name=RoundPiece,proto3" json:"RoundPiece,omitempty"`
	PieceEndTs int64              `protobuf:"varint,5,opt,name=PieceEndTs,proto3" json:"PieceEndTs,omitempty"`
	Attain     []*WarCupAttainObj `protobuf:"bytes,6,rep,name=Attain" json:"Attain,omitempty"`
	TaskTaken  []int32            `protobuf:"varint,7,rep,packed,name=TaskTaken" json:"TaskTaken,omitempty"`
	Chat       []*WarCupChatOne   `protobuf:"bytes,8,rep,name=Chat" json:"Chat,omitempty"`
}

func (m *WarCupData) Reset()                    { *m = WarCupData{} }
func (m *WarCupData) String() string            { return proto.CompactTextString(m) }
func (*WarCupData) ProtoMessage()               {}
func (*WarCupData) Descriptor() ([]byte, []int) { return fileDescriptorCGs_60Warcup, []int{0} }

// 竞猜对战数据
type WarCupGuessData struct {
	GuessScore     int32         `protobuf:"varint,1,opt,name=GuessScore,proto3" json:"GuessScore,omitempty"`
	GuessHas       bool          `protobuf:"varint,2,opt,name=GuessHas,proto3" json:"GuessHas,omitempty"`
	Replay         *BattleReplay `protobuf:"bytes,3,opt,name=Replay" json:"Replay,omitempty"`
	GuessWin       int32         `protobuf:"varint,4,opt,name=GuessWin,proto3" json:"GuessWin,omitempty"`
	GuessNum       int32         `protobuf:"varint,5,opt,name=GuessNum,proto3" json:"GuessNum,omitempty"`
	GuessRatio     float32       `protobuf:"fixed32,6,opt,name=GuessRatio,proto3" json:"GuessRatio,omitempty"`
	GuessWinRatio1 float32       `protobuf:"fixed32,7,opt,name=GuessWinRatio1,proto3" json:"GuessWinRatio1,omitempty"`
	GuessWinRatio2 float32       `protobuf:"fixed32,8,opt,name=GuessWinRatio2,proto3" json:"GuessWinRatio2,omitempty"`
}

func (m *WarCupGuessData) Reset()                    { *m = WarCupGuessData{} }
func (m *WarCupGuessData) String() string            { return proto.CompactTextString(m) }
func (*WarCupGuessData) ProtoMessage()               {}
func (*WarCupGuessData) Descriptor() ([]byte, []int) { return fileDescriptorCGs_60Warcup, []int{1} }

// 玩家身上竞猜记录
type WarCupPlrGuessOne struct {
	Stage int32  `protobuf:"varint,1,opt,name=Stage,proto3" json:"Stage,omitempty"`
	Round int32  `protobuf:"varint,2,opt,name=Round,proto3" json:"Round,omitempty"`
	Name  string `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name,omitempty"`
	Num   int32  `protobuf:"varint,4,opt,name=Num,proto3" json:"Num,omitempty"`
	Add   int32  `protobuf:"varint,5,opt,name=Add,proto3" json:"Add,omitempty"`
	IsFin bool   `protobuf:"varint,6,opt,name=IsFin,proto3" json:"IsFin,omitempty"`
}

func (m *WarCupPlrGuessOne) Reset()                    { *m = WarCupPlrGuessOne{} }
func (m *WarCupPlrGuessOne) String() string            { return proto.CompactTextString(m) }
func (*WarCupPlrGuessOne) ProtoMessage()               {}
func (*WarCupPlrGuessOne) Descriptor() ([]byte, []int) { return fileDescriptorCGs_60Warcup, []int{2} }

// 对战信息
type WarCupVsData struct {
	VsSeq    int32             `protobuf:"varint,1,opt,name=VsSeq,proto3" json:"VsSeq,omitempty"`
	Stage    int32             `protobuf:"varint,2,opt,name=Stage,proto3" json:"Stage,omitempty"`
	Round    int32             `protobuf:"varint,3,opt,name=Round,proto3" json:"Round,omitempty"`
	Plr1     *PlayerSimpleInfo `protobuf:"bytes,4,opt,name=Plr1" json:"Plr1,omitempty"`
	Plr2     *PlayerSimpleInfo `protobuf:"bytes,5,opt,name=Plr2" json:"Plr2,omitempty"`
	Winner   int32             `protobuf:"varint,6,opt,name=Winner,proto3" json:"Winner,omitempty"`
	AddScore int32             `protobuf:"varint,7,opt,name=AddScore,proto3" json:"AddScore,omitempty"`
}

func (m *WarCupVsData) Reset()                    { *m = WarCupVsData{} }
func (m *WarCupVsData) String() string            { return proto.CompactTextString(m) }
func (*WarCupVsData) ProtoMessage()               {}
func (*WarCupVsData) Descriptor() ([]byte, []int) { return fileDescriptorCGs_60Warcup, []int{3} }

// 统计值到达
type WarCupAttainObj struct {
	OId int32   `protobuf:"varint,1,opt,name=OId,proto3" json:"OId,omitempty"`
	Val float64 `protobuf:"fixed64,2,opt,name=Val,proto3" json:"Val,omitempty"`
}

func (m *WarCupAttainObj) Reset()                    { *m = WarCupAttainObj{} }
func (m *WarCupAttainObj) String() string            { return proto.CompactTextString(m) }
func (*WarCupAttainObj) ProtoMessage()               {}
func (*WarCupAttainObj) Descriptor() ([]byte, []int) { return fileDescriptorCGs_60Warcup, []int{4} }

// 聊天信息
type WarCupChatOne struct {
	Name    string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Content string `protobuf:"bytes,2,opt,name=Content,proto3" json:"Content,omitempty"`
}

func (m *WarCupChatOne) Reset()                    { *m = WarCupChatOne{} }
func (m *WarCupChatOne) String() string            { return proto.CompactTextString(m) }
func (*WarCupChatOne) ProtoMessage()               {}
func (*WarCupChatOne) Descriptor() ([]byte, []int) { return fileDescriptorCGs_60Warcup, []int{5} }

// 阶段更新
type GS_WarCupStageUpdate struct {
	Stage      int32 `protobuf:"varint,1,opt,name=Stage,proto3" json:"Stage,omitempty"`
	Ts2        int64 `protobuf:"varint,2,opt,name=Ts2,proto3" json:"Ts2,omitempty"`
	Round      int32 `protobuf:"varint,3,opt,name=Round,proto3" json:"Round,omitempty"`
	RoundPiece int32 `protobuf:"varint,4,opt,name=RoundPiece,proto3" json:"RoundPiece,omitempty"`
	PieceEndTs int64 `protobuf:"varint,5,opt,name=PieceEndTs,proto3" json:"PieceEndTs,omitempty"`
}

func (m *GS_WarCupStageUpdate) Reset()                    { *m = GS_WarCupStageUpdate{} }
func (m *GS_WarCupStageUpdate) String() string            { return proto.CompactTextString(m) }
func (*GS_WarCupStageUpdate) ProtoMessage()               {}
func (*GS_WarCupStageUpdate) Descriptor() ([]byte, []int) { return fileDescriptorCGs_60Warcup, []int{6} }

// 弹幕聊天推送
type GS_WarCupChat struct {
	Name    string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Content string `protobuf:"bytes,2,opt,name=Content,proto3" json:"Content,omitempty"`
}

func (m *GS_WarCupChat) Reset()                    { *m = GS_WarCupChat{} }
func (m *GS_WarCupChat) String() string            { return proto.CompactTextString(m) }
func (*GS_WarCupChat) ProtoMessage()               {}
func (*GS_WarCupChat) Descriptor() ([]byte, []int) { return fileDescriptorCGs_60Warcup, []int{7} }

// 押注信息更新
type GS_WarCupGuessRatio struct {
	GuessRatio     float32 `protobuf:"fixed32,1,opt,name=GuessRatio,proto3" json:"GuessRatio,omitempty"`
	GuessWinRatio1 float32 `protobuf:"fixed32,2,opt,name=GuessWinRatio1,proto3" json:"GuessWinRatio1,omitempty"`
	GuessWinRatio2 float32 `protobuf:"fixed32,3,opt,name=GuessWinRatio2,proto3" json:"GuessWinRatio2,omitempty"`
}

func (m *GS_WarCupGuessRatio) Reset()                    { *m = GS_WarCupGuessRatio{} }
func (m *GS_WarCupGuessRatio) String() string            { return proto.CompactTextString(m) }
func (*GS_WarCupGuessRatio) ProtoMessage()               {}
func (*GS_WarCupGuessRatio) Descriptor() ([]byte, []int) { return fileDescriptorCGs_60Warcup, []int{8} }

// 通知: 任务进度变化
type GS_WarCupAttainObjValueChanged struct {
	OId int32   `protobuf:"varint,1,opt,name=OId,proto3" json:"OId,omitempty"`
	Val float64 `protobuf:"fixed64,2,opt,name=Val,proto3" json:"Val,omitempty"`
}

func (m *GS_WarCupAttainObjValueChanged) Reset()         { *m = GS_WarCupAttainObjValueChanged{} }
func (m *GS_WarCupAttainObjValueChanged) String() string { return proto.CompactTextString(m) }
func (*GS_WarCupAttainObjValueChanged) ProtoMessage()    {}
func (*GS_WarCupAttainObjValueChanged) Descriptor() ([]byte, []int) {
	return fileDescriptorCGs_60Warcup, []int{9}
}

// 获取竞猜信息
type C_WarCupGuessInfo struct {
}

func (m *C_WarCupGuessInfo) Reset()                    { *m = C_WarCupGuessInfo{} }
func (m *C_WarCupGuessInfo) String() string            { return proto.CompactTextString(m) }
func (*C_WarCupGuessInfo) ProtoMessage()               {}
func (*C_WarCupGuessInfo) Descriptor() ([]byte, []int) { return fileDescriptorCGs_60Warcup, []int{10} }

type GS_WarCupGuessInfo_R struct {
	ErrorCode int32            `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Guess     *WarCupGuessData `protobuf:"bytes,2,opt,name=Guess" json:"Guess,omitempty"`
}

func (m *GS_WarCupGuessInfo_R) Reset()         { *m = GS_WarCupGuessInfo_R{} }
func (m *GS_WarCupGuessInfo_R) String() string { return proto.CompactTextString(m) }
func (*GS_WarCupGuessInfo_R) ProtoMessage()    {}
func (*GS_WarCupGuessInfo_R) Descriptor() ([]byte, []int) {
	return fileDescriptorCGs_60Warcup, []int{11}
}

// 获取自己比赛信息
type C_WarCupSelfInfo struct {
}

func (m *C_WarCupSelfInfo) Reset()                    { *m = C_WarCupSelfInfo{} }
func (m *C_WarCupSelfInfo) String() string            { return proto.CompactTextString(m) }
func (*C_WarCupSelfInfo) ProtoMessage()               {}
func (*C_WarCupSelfInfo) Descriptor() ([]byte, []int) { return fileDescriptorCGs_60Warcup, []int{12} }

type GS_WarCupSelfInfo_R struct {
	ErrorCode int32           `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	VsData    []*WarCupVsData `protobuf:"bytes,2,rep,name=VsData" json:"VsData,omitempty"`
	CurReplay *BattleReplay   `protobuf:"bytes,3,opt,name=CurReplay" json:"CurReplay,omitempty"`
}

func (m *GS_WarCupSelfInfo_R) Reset()                    { *m = GS_WarCupSelfInfo_R{} }
func (m *GS_WarCupSelfInfo_R) String() string            { return proto.CompactTextString(m) }
func (*GS_WarCupSelfInfo_R) ProtoMessage()               {}
func (*GS_WarCupSelfInfo_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_60Warcup, []int{13} }

// 获取64强淘汰赛信息
type C_WarCupTop64Info struct {
	Grp int32 `protobuf:"varint,1,opt,name=Grp,proto3" json:"Grp,omitempty"`
}

func (m *C_WarCupTop64Info) Reset()                    { *m = C_WarCupTop64Info{} }
func (m *C_WarCupTop64Info) String() string            { return proto.CompactTextString(m) }
func (*C_WarCupTop64Info) ProtoMessage()               {}
func (*C_WarCupTop64Info) Descriptor() ([]byte, []int) { return fileDescriptorCGs_60Warcup, []int{14} }

type GS_WarCupTop64Info_R struct {
	ErrorCode int32           `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	VsData    []*WarCupVsData `protobuf:"bytes,2,rep,name=VsData" json:"VsData,omitempty"`
}

func (m *GS_WarCupTop64Info_R) Reset()         { *m = GS_WarCupTop64Info_R{} }
func (m *GS_WarCupTop64Info_R) String() string { return proto.CompactTextString(m) }
func (*GS_WarCupTop64Info_R) ProtoMessage()    {}
func (*GS_WarCupTop64Info_R) Descriptor() ([]byte, []int) {
	return fileDescriptorCGs_60Warcup, []int{15}
}

// 获取8强冠军赛信息
type C_WarCupTop8Info struct {
}

func (m *C_WarCupTop8Info) Reset()                    { *m = C_WarCupTop8Info{} }
func (m *C_WarCupTop8Info) String() string            { return proto.CompactTextString(m) }
func (*C_WarCupTop8Info) ProtoMessage()               {}
func (*C_WarCupTop8Info) Descriptor() ([]byte, []int) { return fileDescriptorCGs_60Warcup, []int{16} }

type GS_WarCupTop8Info_R struct {
	ErrorCode int32           `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	VsData    []*WarCupVsData `protobuf:"bytes,2,rep,name=VsData" json:"VsData,omitempty"`
}

func (m *GS_WarCupTop8Info_R) Reset()                    { *m = GS_WarCupTop8Info_R{} }
func (m *GS_WarCupTop8Info_R) String() string            { return proto.CompactTextString(m) }
func (*GS_WarCupTop8Info_R) ProtoMessage()               {}
func (*GS_WarCupTop8Info_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_60Warcup, []int{17} }

// 竞猜
type C_WarCupGuess struct {
	GuessWin int32 `protobuf:"varint,1,opt,name=GuessWin,proto3" json:"GuessWin,omitempty"`
	GuessNum int32 `protobuf:"varint,2,opt,name=GuessNum,proto3" json:"GuessNum,omitempty"`
}

func (m *C_WarCupGuess) Reset()                    { *m = C_WarCupGuess{} }
func (m *C_WarCupGuess) String() string            { return proto.CompactTextString(m) }
func (*C_WarCupGuess) ProtoMessage()               {}
func (*C_WarCupGuess) Descriptor() ([]byte, []int) { return fileDescriptorCGs_60Warcup, []int{18} }

type GS_WarCupGuess_R struct {
	ErrorCode  int32 `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	GuessScore int32 `protobuf:"varint,2,opt,name=GuessScore,proto3" json:"GuessScore,omitempty"`
}

func (m *GS_WarCupGuess_R) Reset()                    { *m = GS_WarCupGuess_R{} }
func (m *GS_WarCupGuess_R) String() string            { return proto.CompactTextString(m) }
func (*GS_WarCupGuess_R) ProtoMessage()               {}
func (*GS_WarCupGuess_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_60Warcup, []int{19} }

// 海选排行榜
type C_WarCupAuditionRank struct {
	Top int32 `protobuf:"varint,1,opt,name=Top,proto3" json:"Top,omitempty"`
	N   int32 `protobuf:"varint,2,opt,name=N,proto3" json:"N,omitempty"`
}

func (m *C_WarCupAuditionRank) Reset()         { *m = C_WarCupAuditionRank{} }
func (m *C_WarCupAuditionRank) String() string { return proto.CompactTextString(m) }
func (*C_WarCupAuditionRank) ProtoMessage()    {}
func (*C_WarCupAuditionRank) Descriptor() ([]byte, []int) {
	return fileDescriptorCGs_60Warcup, []int{20}
}

type GS_WarCupAuditionRank_R struct {
	ErrorCode int32      `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Rows      []*RankRow `protobuf:"bytes,2,rep,name=Rows" json:"Rows,omitempty"`
}

func (m *GS_WarCupAuditionRank_R) Reset()         { *m = GS_WarCupAuditionRank_R{} }
func (m *GS_WarCupAuditionRank_R) String() string { return proto.CompactTextString(m) }
func (*GS_WarCupAuditionRank_R) ProtoMessage()    {}
func (*GS_WarCupAuditionRank_R) Descriptor() ([]byte, []int) {
	return fileDescriptorCGs_60Warcup, []int{21}
}

// 聊天
type C_WarCupChatSend struct {
	Content string `protobuf:"bytes,1,opt,name=Content,proto3" json:"Content,omitempty"`
}

func (m *C_WarCupChatSend) Reset()                    { *m = C_WarCupChatSend{} }
func (m *C_WarCupChatSend) String() string            { return proto.CompactTextString(m) }
func (*C_WarCupChatSend) ProtoMessage()               {}
func (*C_WarCupChatSend) Descriptor() ([]byte, []int) { return fileDescriptorCGs_60Warcup, []int{22} }

type GS_WarCupChatSend_R struct {
	ErrorCode int32 `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
}

func (m *GS_WarCupChatSend_R) Reset()                    { *m = GS_WarCupChatSend_R{} }
func (m *GS_WarCupChatSend_R) String() string            { return proto.CompactTextString(m) }
func (*GS_WarCupChatSend_R) ProtoMessage()               {}
func (*GS_WarCupChatSend_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_60Warcup, []int{23} }

// 拉战报
type C_WarCupGetReplay struct {
	VsSeq int32 `protobuf:"varint,1,opt,name=VsSeq,proto3" json:"VsSeq,omitempty"`
}

func (m *C_WarCupGetReplay) Reset()                    { *m = C_WarCupGetReplay{} }
func (m *C_WarCupGetReplay) String() string            { return proto.CompactTextString(m) }
func (*C_WarCupGetReplay) ProtoMessage()               {}
func (*C_WarCupGetReplay) Descriptor() ([]byte, []int) { return fileDescriptorCGs_60Warcup, []int{24} }

type GS_WarCupGetReplay_R struct {
	ErrorCode int32         `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Replay    *BattleReplay `protobuf:"bytes,2,opt,name=Replay" json:"Replay,omitempty"`
}

func (m *GS_WarCupGetReplay_R) Reset()         { *m = GS_WarCupGetReplay_R{} }
func (m *GS_WarCupGetReplay_R) String() string { return proto.CompactTextString(m) }
func (*GS_WarCupGetReplay_R) ProtoMessage()    {}
func (*GS_WarCupGetReplay_R) Descriptor() ([]byte, []int) {
	return fileDescriptorCGs_60Warcup, []int{25}
}

// 获取冠军信息
type C_WarCupTop1Info struct {
}

func (m *C_WarCupTop1Info) Reset()                    { *m = C_WarCupTop1Info{} }
func (m *C_WarCupTop1Info) String() string            { return proto.CompactTextString(m) }
func (*C_WarCupTop1Info) ProtoMessage()               {}
func (*C_WarCupTop1Info) Descriptor() ([]byte, []int) { return fileDescriptorCGs_60Warcup, []int{26} }

type GS_WarCupTop1Info_R struct {
	ErrorCode int32             `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Plr       *PlayerSimpleInfo `protobuf:"bytes,2,opt,name=Plr" json:"Plr,omitempty"`
	HeroId    int32             `protobuf:"varint,3,opt,name=HeroId,proto3" json:"HeroId,omitempty"`
	HeroStar  int32             `protobuf:"varint,4,opt,name=HeroStar,proto3" json:"HeroStar,omitempty"`
	HeroSkin  int32             `protobuf:"varint,5,opt,name=HeroSkin,proto3" json:"HeroSkin,omitempty"`
}

func (m *GS_WarCupTop1Info_R) Reset()                    { *m = GS_WarCupTop1Info_R{} }
func (m *GS_WarCupTop1Info_R) String() string            { return proto.CompactTextString(m) }
func (*GS_WarCupTop1Info_R) ProtoMessage()               {}
func (*GS_WarCupTop1Info_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_60Warcup, []int{27} }

// 任务领取
type C_WarCupTaskTake struct {
	Id int32 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
}

func (m *C_WarCupTaskTake) Reset()                    { *m = C_WarCupTaskTake{} }
func (m *C_WarCupTaskTake) String() string            { return proto.CompactTextString(m) }
func (*C_WarCupTaskTake) ProtoMessage()               {}
func (*C_WarCupTaskTake) Descriptor() ([]byte, []int) { return fileDescriptorCGs_60Warcup, []int{28} }

type GS_WarCupTaskTake_R struct {
	ErrorCode int32    `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Rewards   *Rewards `protobuf:"bytes,2,opt,name=Rewards" json:"Rewards,omitempty"`
}

func (m *GS_WarCupTaskTake_R) Reset()                    { *m = GS_WarCupTaskTake_R{} }
func (m *GS_WarCupTaskTake_R) String() string            { return proto.CompactTextString(m) }
func (*GS_WarCupTaskTake_R) ProtoMessage()               {}
func (*GS_WarCupTaskTake_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_60Warcup, []int{29} }

// 观看比赛
type C_WarCupWatch struct {
}

func (m *C_WarCupWatch) Reset()                    { *m = C_WarCupWatch{} }
func (m *C_WarCupWatch) String() string            { return proto.CompactTextString(m) }
func (*C_WarCupWatch) ProtoMessage()               {}
func (*C_WarCupWatch) Descriptor() ([]byte, []int) { return fileDescriptorCGs_60Warcup, []int{30} }

// 玩家竞猜记录
type C_WarCupGuessRecords struct {
}

func (m *C_WarCupGuessRecords) Reset()         { *m = C_WarCupGuessRecords{} }
func (m *C_WarCupGuessRecords) String() string { return proto.CompactTextString(m) }
func (*C_WarCupGuessRecords) ProtoMessage()    {}
func (*C_WarCupGuessRecords) Descriptor() ([]byte, []int) {
	return fileDescriptorCGs_60Warcup, []int{31}
}

type GS_WarCupGuessRecords_R struct {
	ErrorCode int32                `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Records   []*WarCupPlrGuessOne `protobuf:"bytes,2,rep,name=Records" json:"Records,omitempty"`
}

func (m *GS_WarCupGuessRecords_R) Reset()         { *m = GS_WarCupGuessRecords_R{} }
func (m *GS_WarCupGuessRecords_R) String() string { return proto.CompactTextString(m) }
func (*GS_WarCupGuessRecords_R) ProtoMessage()    {}
func (*GS_WarCupGuessRecords_R) Descriptor() ([]byte, []int) {
	return fileDescriptorCGs_60Warcup, []int{32}
}

func init() {
	proto.RegisterType((*WarCupData)(nil), "msg.WarCupData")
	proto.RegisterType((*WarCupGuessData)(nil), "msg.WarCupGuessData")
	proto.RegisterType((*WarCupPlrGuessOne)(nil), "msg.WarCupPlrGuessOne")
	proto.RegisterType((*WarCupVsData)(nil), "msg.WarCupVsData")
	proto.RegisterType((*WarCupAttainObj)(nil), "msg.WarCupAttainObj")
	proto.RegisterType((*WarCupChatOne)(nil), "msg.WarCupChatOne")
	proto.RegisterType((*GS_WarCupStageUpdate)(nil), "msg.GS_WarCupStageUpdate")
	proto.RegisterType((*GS_WarCupChat)(nil), "msg.GS_WarCupChat")
	proto.RegisterType((*GS_WarCupGuessRatio)(nil), "msg.GS_WarCupGuessRatio")
	proto.RegisterType((*GS_WarCupAttainObjValueChanged)(nil), "msg.GS_WarCupAttainObjValueChanged")
	proto.RegisterType((*C_WarCupGuessInfo)(nil), "msg.C_WarCupGuessInfo")
	proto.RegisterType((*GS_WarCupGuessInfo_R)(nil), "msg.GS_WarCupGuessInfo_R")
	proto.RegisterType((*C_WarCupSelfInfo)(nil), "msg.C_WarCupSelfInfo")
	proto.RegisterType((*GS_WarCupSelfInfo_R)(nil), "msg.GS_WarCupSelfInfo_R")
	proto.RegisterType((*C_WarCupTop64Info)(nil), "msg.C_WarCupTop64Info")
	proto.RegisterType((*GS_WarCupTop64Info_R)(nil), "msg.GS_WarCupTop64Info_R")
	proto.RegisterType((*C_WarCupTop8Info)(nil), "msg.C_WarCupTop8Info")
	proto.RegisterType((*GS_WarCupTop8Info_R)(nil), "msg.GS_WarCupTop8Info_R")
	proto.RegisterType((*C_WarCupGuess)(nil), "msg.C_WarCupGuess")
	proto.RegisterType((*GS_WarCupGuess_R)(nil), "msg.GS_WarCupGuess_R")
	proto.RegisterType((*C_WarCupAuditionRank)(nil), "msg.C_WarCupAuditionRank")
	proto.RegisterType((*GS_WarCupAuditionRank_R)(nil), "msg.GS_WarCupAuditionRank_R")
	proto.RegisterType((*C_WarCupChatSend)(nil), "msg.C_WarCupChatSend")
	proto.RegisterType((*GS_WarCupChatSend_R)(nil), "msg.GS_WarCupChatSend_R")
	proto.RegisterType((*C_WarCupGetReplay)(nil), "msg.C_WarCupGetReplay")
	proto.RegisterType((*GS_WarCupGetReplay_R)(nil), "msg.GS_WarCupGetReplay_R")
	proto.RegisterType((*C_WarCupTop1Info)(nil), "msg.C_WarCupTop1Info")
	proto.RegisterType((*GS_WarCupTop1Info_R)(nil), "msg.GS_WarCupTop1Info_R")
	proto.RegisterType((*C_WarCupTaskTake)(nil), "msg.C_WarCupTaskTake")
	proto.RegisterType((*GS_WarCupTaskTake_R)(nil), "msg.GS_WarCupTaskTake_R")
	proto.RegisterType((*C_WarCupWatch)(nil), "msg.C_WarCupWatch")
	proto.RegisterType((*C_WarCupGuessRecords)(nil), "msg.C_WarCupGuessRecords")
	proto.RegisterType((*GS_WarCupGuessRecords_R)(nil), "msg.GS_WarCupGuessRecords_R")
}
func (m *WarCupData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarCupData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Stage != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.Stage))
	}
	if m.Ts2 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.Ts2))
	}
	if m.Round != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.Round))
	}
	if m.RoundPiece != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.RoundPiece))
	}
	if m.PieceEndTs != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.PieceEndTs))
	}
	if len(m.Attain) > 0 {
		for _, msg := range m.Attain {
			dAtA[i] = 0x32
			i++
			i = encodeVarintCGs_60Warcup(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TaskTaken) > 0 {
		dAtA2 := make([]byte, len(m.TaskTaken)*10)
		var j1 int
		for _, num1 := range m.TaskTaken {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if len(m.Chat) > 0 {
		for _, msg := range m.Chat {
			dAtA[i] = 0x42
			i++
			i = encodeVarintCGs_60Warcup(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *WarCupGuessData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarCupGuessData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GuessScore != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.GuessScore))
	}
	if m.GuessHas {
		dAtA[i] = 0x10
		i++
		if m.GuessHas {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Replay != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.Replay.Size()))
		n3, err := m.Replay.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.GuessWin != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.GuessWin))
	}
	if m.GuessNum != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.GuessNum))
	}
	if m.GuessRatio != 0 {
		dAtA[i] = 0x35
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.GuessRatio))))
		i += 4
	}
	if m.GuessWinRatio1 != 0 {
		dAtA[i] = 0x3d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.GuessWinRatio1))))
		i += 4
	}
	if m.GuessWinRatio2 != 0 {
		dAtA[i] = 0x45
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.GuessWinRatio2))))
		i += 4
	}
	return i, nil
}

func (m *WarCupPlrGuessOne) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarCupPlrGuessOne) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Stage != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.Stage))
	}
	if m.Round != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.Round))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Num != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.Num))
	}
	if m.Add != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.Add))
	}
	if m.IsFin {
		dAtA[i] = 0x30
		i++
		if m.IsFin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *WarCupVsData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarCupVsData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VsSeq != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.VsSeq))
	}
	if m.Stage != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.Stage))
	}
	if m.Round != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.Round))
	}
	if m.Plr1 != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.Plr1.Size()))
		n4, err := m.Plr1.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Plr2 != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.Plr2.Size()))
		n5, err := m.Plr2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Winner != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.Winner))
	}
	if m.AddScore != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.AddScore))
	}
	return i, nil
}

func (m *WarCupAttainObj) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarCupAttainObj) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.OId))
	}
	if m.Val != 0 {
		dAtA[i] = 0x11
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Val))))
		i += 8
	}
	return i, nil
}

func (m *WarCupChatOne) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarCupChatOne) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	return i, nil
}

func (m *GS_WarCupStageUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_WarCupStageUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Stage != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.Stage))
	}
	if m.Ts2 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.Ts2))
	}
	if m.Round != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.Round))
	}
	if m.RoundPiece != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.RoundPiece))
	}
	if m.PieceEndTs != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.PieceEndTs))
	}
	return i, nil
}

func (m *GS_WarCupChat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_WarCupChat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	return i, nil
}

func (m *GS_WarCupGuessRatio) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_WarCupGuessRatio) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GuessRatio != 0 {
		dAtA[i] = 0xd
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.GuessRatio))))
		i += 4
	}
	if m.GuessWinRatio1 != 0 {
		dAtA[i] = 0x15
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.GuessWinRatio1))))
		i += 4
	}
	if m.GuessWinRatio2 != 0 {
		dAtA[i] = 0x1d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.GuessWinRatio2))))
		i += 4
	}
	return i, nil
}

func (m *GS_WarCupAttainObjValueChanged) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_WarCupAttainObjValueChanged) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.OId))
	}
	if m.Val != 0 {
		dAtA[i] = 0x11
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Val))))
		i += 8
	}
	return i, nil
}

func (m *C_WarCupGuessInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_WarCupGuessInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GS_WarCupGuessInfo_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_WarCupGuessInfo_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Guess != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.Guess.Size()))
		n6, err := m.Guess.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *C_WarCupSelfInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_WarCupSelfInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GS_WarCupSelfInfo_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_WarCupSelfInfo_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.VsData) > 0 {
		for _, msg := range m.VsData {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCGs_60Warcup(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CurReplay != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.CurReplay.Size()))
		n7, err := m.CurReplay.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *C_WarCupTop64Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_WarCupTop64Info) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Grp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.Grp))
	}
	return i, nil
}

func (m *GS_WarCupTop64Info_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_WarCupTop64Info_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.VsData) > 0 {
		for _, msg := range m.VsData {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCGs_60Warcup(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *C_WarCupTop8Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_WarCupTop8Info) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GS_WarCupTop8Info_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_WarCupTop8Info_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.VsData) > 0 {
		for _, msg := range m.VsData {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCGs_60Warcup(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *C_WarCupGuess) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_WarCupGuess) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GuessWin != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.GuessWin))
	}
	if m.GuessNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.GuessNum))
	}
	return i, nil
}

func (m *GS_WarCupGuess_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_WarCupGuess_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.ErrorCode))
	}
	if m.GuessScore != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.GuessScore))
	}
	return i, nil
}

func (m *C_WarCupAuditionRank) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_WarCupAuditionRank) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Top != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.Top))
	}
	if m.N != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.N))
	}
	return i, nil
}

func (m *GS_WarCupAuditionRank_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_WarCupAuditionRank_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.Rows) > 0 {
		for _, msg := range m.Rows {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCGs_60Warcup(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *C_WarCupChatSend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_WarCupChatSend) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Content) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	return i, nil
}

func (m *GS_WarCupChatSend_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_WarCupChatSend_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *C_WarCupGetReplay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_WarCupGetReplay) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VsSeq != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.VsSeq))
	}
	return i, nil
}

func (m *GS_WarCupGetReplay_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_WarCupGetReplay_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Replay != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.Replay.Size()))
		n8, err := m.Replay.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *C_WarCupTop1Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_WarCupTop1Info) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GS_WarCupTop1Info_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_WarCupTop1Info_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Plr != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.Plr.Size()))
		n9, err := m.Plr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.HeroId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.HeroId))
	}
	if m.HeroStar != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.HeroStar))
	}
	if m.HeroSkin != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.HeroSkin))
	}
	return i, nil
}

func (m *C_WarCupTaskTake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_WarCupTaskTake) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *GS_WarCupTaskTake_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_WarCupTaskTake_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Rewards != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.Rewards.Size()))
		n10, err := m.Rewards.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *C_WarCupWatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_WarCupWatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *C_WarCupGuessRecords) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_WarCupGuessRecords) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GS_WarCupGuessRecords_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_WarCupGuessRecords_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_60Warcup(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.Records) > 0 {
		for _, msg := range m.Records {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCGs_60Warcup(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintCGs_60Warcup(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *WarCupData) Size() (n int) {
	var l int
	_ = l
	if m.Stage != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.Stage))
	}
	if m.Ts2 != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.Ts2))
	}
	if m.Round != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.Round))
	}
	if m.RoundPiece != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.RoundPiece))
	}
	if m.PieceEndTs != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.PieceEndTs))
	}
	if len(m.Attain) > 0 {
		for _, e := range m.Attain {
			l = e.Size()
			n += 1 + l + sovCGs_60Warcup(uint64(l))
		}
	}
	if len(m.TaskTaken) > 0 {
		l = 0
		for _, e := range m.TaskTaken {
			l += sovCGs_60Warcup(uint64(e))
		}
		n += 1 + sovCGs_60Warcup(uint64(l)) + l
	}
	if len(m.Chat) > 0 {
		for _, e := range m.Chat {
			l = e.Size()
			n += 1 + l + sovCGs_60Warcup(uint64(l))
		}
	}
	return n
}

func (m *WarCupGuessData) Size() (n int) {
	var l int
	_ = l
	if m.GuessScore != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.GuessScore))
	}
	if m.GuessHas {
		n += 2
	}
	if m.Replay != nil {
		l = m.Replay.Size()
		n += 1 + l + sovCGs_60Warcup(uint64(l))
	}
	if m.GuessWin != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.GuessWin))
	}
	if m.GuessNum != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.GuessNum))
	}
	if m.GuessRatio != 0 {
		n += 5
	}
	if m.GuessWinRatio1 != 0 {
		n += 5
	}
	if m.GuessWinRatio2 != 0 {
		n += 5
	}
	return n
}

func (m *WarCupPlrGuessOne) Size() (n int) {
	var l int
	_ = l
	if m.Stage != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.Stage))
	}
	if m.Round != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.Round))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCGs_60Warcup(uint64(l))
	}
	if m.Num != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.Num))
	}
	if m.Add != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.Add))
	}
	if m.IsFin {
		n += 2
	}
	return n
}

func (m *WarCupVsData) Size() (n int) {
	var l int
	_ = l
	if m.VsSeq != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.VsSeq))
	}
	if m.Stage != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.Stage))
	}
	if m.Round != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.Round))
	}
	if m.Plr1 != nil {
		l = m.Plr1.Size()
		n += 1 + l + sovCGs_60Warcup(uint64(l))
	}
	if m.Plr2 != nil {
		l = m.Plr2.Size()
		n += 1 + l + sovCGs_60Warcup(uint64(l))
	}
	if m.Winner != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.Winner))
	}
	if m.AddScore != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.AddScore))
	}
	return n
}

func (m *WarCupAttainObj) Size() (n int) {
	var l int
	_ = l
	if m.OId != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.OId))
	}
	if m.Val != 0 {
		n += 9
	}
	return n
}

func (m *WarCupChatOne) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCGs_60Warcup(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovCGs_60Warcup(uint64(l))
	}
	return n
}

func (m *GS_WarCupStageUpdate) Size() (n int) {
	var l int
	_ = l
	if m.Stage != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.Stage))
	}
	if m.Ts2 != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.Ts2))
	}
	if m.Round != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.Round))
	}
	if m.RoundPiece != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.RoundPiece))
	}
	if m.PieceEndTs != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.PieceEndTs))
	}
	return n
}

func (m *GS_WarCupChat) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCGs_60Warcup(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovCGs_60Warcup(uint64(l))
	}
	return n
}

func (m *GS_WarCupGuessRatio) Size() (n int) {
	var l int
	_ = l
	if m.GuessRatio != 0 {
		n += 5
	}
	if m.GuessWinRatio1 != 0 {
		n += 5
	}
	if m.GuessWinRatio2 != 0 {
		n += 5
	}
	return n
}

func (m *GS_WarCupAttainObjValueChanged) Size() (n int) {
	var l int
	_ = l
	if m.OId != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.OId))
	}
	if m.Val != 0 {
		n += 9
	}
	return n
}

func (m *C_WarCupGuessInfo) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GS_WarCupGuessInfo_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.ErrorCode))
	}
	if m.Guess != nil {
		l = m.Guess.Size()
		n += 1 + l + sovCGs_60Warcup(uint64(l))
	}
	return n
}

func (m *C_WarCupSelfInfo) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GS_WarCupSelfInfo_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.ErrorCode))
	}
	if len(m.VsData) > 0 {
		for _, e := range m.VsData {
			l = e.Size()
			n += 1 + l + sovCGs_60Warcup(uint64(l))
		}
	}
	if m.CurReplay != nil {
		l = m.CurReplay.Size()
		n += 1 + l + sovCGs_60Warcup(uint64(l))
	}
	return n
}

func (m *C_WarCupTop64Info) Size() (n int) {
	var l int
	_ = l
	if m.Grp != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.Grp))
	}
	return n
}

func (m *GS_WarCupTop64Info_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.ErrorCode))
	}
	if len(m.VsData) > 0 {
		for _, e := range m.VsData {
			l = e.Size()
			n += 1 + l + sovCGs_60Warcup(uint64(l))
		}
	}
	return n
}

func (m *C_WarCupTop8Info) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GS_WarCupTop8Info_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.ErrorCode))
	}
	if len(m.VsData) > 0 {
		for _, e := range m.VsData {
			l = e.Size()
			n += 1 + l + sovCGs_60Warcup(uint64(l))
		}
	}
	return n
}

func (m *C_WarCupGuess) Size() (n int) {
	var l int
	_ = l
	if m.GuessWin != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.GuessWin))
	}
	if m.GuessNum != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.GuessNum))
	}
	return n
}

func (m *GS_WarCupGuess_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.ErrorCode))
	}
	if m.GuessScore != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.GuessScore))
	}
	return n
}

func (m *C_WarCupAuditionRank) Size() (n int) {
	var l int
	_ = l
	if m.Top != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.Top))
	}
	if m.N != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.N))
	}
	return n
}

func (m *GS_WarCupAuditionRank_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.ErrorCode))
	}
	if len(m.Rows) > 0 {
		for _, e := range m.Rows {
			l = e.Size()
			n += 1 + l + sovCGs_60Warcup(uint64(l))
		}
	}
	return n
}

func (m *C_WarCupChatSend) Size() (n int) {
	var l int
	_ = l
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovCGs_60Warcup(uint64(l))
	}
	return n
}

func (m *GS_WarCupChatSend_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.ErrorCode))
	}
	return n
}

func (m *C_WarCupGetReplay) Size() (n int) {
	var l int
	_ = l
	if m.VsSeq != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.VsSeq))
	}
	return n
}

func (m *GS_WarCupGetReplay_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.ErrorCode))
	}
	if m.Replay != nil {
		l = m.Replay.Size()
		n += 1 + l + sovCGs_60Warcup(uint64(l))
	}
	return n
}

func (m *C_WarCupTop1Info) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GS_WarCupTop1Info_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.ErrorCode))
	}
	if m.Plr != nil {
		l = m.Plr.Size()
		n += 1 + l + sovCGs_60Warcup(uint64(l))
	}
	if m.HeroId != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.HeroId))
	}
	if m.HeroStar != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.HeroStar))
	}
	if m.HeroSkin != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.HeroSkin))
	}
	return n
}

func (m *C_WarCupTaskTake) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.Id))
	}
	return n
}

func (m *GS_WarCupTaskTake_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.ErrorCode))
	}
	if m.Rewards != nil {
		l = m.Rewards.Size()
		n += 1 + l + sovCGs_60Warcup(uint64(l))
	}
	return n
}

func (m *C_WarCupWatch) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *C_WarCupGuessRecords) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GS_WarCupGuessRecords_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_60Warcup(uint64(m.ErrorCode))
	}
	if len(m.Records) > 0 {
		for _, e := range m.Records {
			l = e.Size()
			n += 1 + l + sovCGs_60Warcup(uint64(l))
		}
	}
	return n
}

func sovCGs_60Warcup(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCGs_60Warcup(x uint64) (n int) {
	return sovCGs_60Warcup(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *WarCupData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarCupData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarCupData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stage", wireType)
			}
			m.Stage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts2", wireType)
			}
			m.Ts2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts2 |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundPiece", wireType)
			}
			m.RoundPiece = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoundPiece |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PieceEndTs", wireType)
			}
			m.PieceEndTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PieceEndTs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attain = append(m.Attain, &WarCupAttainObj{})
			if err := m.Attain[len(m.Attain)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_60Warcup
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TaskTaken = append(m.TaskTaken, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_60Warcup
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCGs_60Warcup
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_60Warcup
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TaskTaken = append(m.TaskTaken, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskTaken", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chat = append(m.Chat, &WarCupChatOne{})
			if err := m.Chat[len(m.Chat)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarCupGuessData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarCupGuessData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarCupGuessData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuessScore", wireType)
			}
			m.GuessScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuessScore |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuessHas", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GuessHas = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Replay == nil {
				m.Replay = &BattleReplay{}
			}
			if err := m.Replay.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuessWin", wireType)
			}
			m.GuessWin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuessWin |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuessNum", wireType)
			}
			m.GuessNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuessNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuessRatio", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.GuessRatio = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuessWinRatio1", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.GuessWinRatio1 = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuessWinRatio2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.GuessWinRatio2 = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarCupPlrGuessOne) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarCupPlrGuessOne: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarCupPlrGuessOne: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stage", wireType)
			}
			m.Stage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Add", wireType)
			}
			m.Add = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Add |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFin = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarCupVsData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarCupVsData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarCupVsData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VsSeq", wireType)
			}
			m.VsSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VsSeq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stage", wireType)
			}
			m.Stage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plr1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Plr1 == nil {
				m.Plr1 = &PlayerSimpleInfo{}
			}
			if err := m.Plr1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plr2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Plr2 == nil {
				m.Plr2 = &PlayerSimpleInfo{}
			}
			if err := m.Plr2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Winner", wireType)
			}
			m.Winner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Winner |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddScore", wireType)
			}
			m.AddScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddScore |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarCupAttainObj) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarCupAttainObj: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarCupAttainObj: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OId", wireType)
			}
			m.OId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Val = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarCupChatOne) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarCupChatOne: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarCupChatOne: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_WarCupStageUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_WarCupStageUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_WarCupStageUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stage", wireType)
			}
			m.Stage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts2", wireType)
			}
			m.Ts2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts2 |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundPiece", wireType)
			}
			m.RoundPiece = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoundPiece |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PieceEndTs", wireType)
			}
			m.PieceEndTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PieceEndTs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_WarCupChat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_WarCupChat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_WarCupChat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_WarCupGuessRatio) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_WarCupGuessRatio: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_WarCupGuessRatio: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuessRatio", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.GuessRatio = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuessWinRatio1", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.GuessWinRatio1 = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuessWinRatio2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.GuessWinRatio2 = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_WarCupAttainObjValueChanged) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_WarCupAttainObjValueChanged: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_WarCupAttainObjValueChanged: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OId", wireType)
			}
			m.OId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Val = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_WarCupGuessInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_WarCupGuessInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_WarCupGuessInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_WarCupGuessInfo_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_WarCupGuessInfo_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_WarCupGuessInfo_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Guess", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Guess == nil {
				m.Guess = &WarCupGuessData{}
			}
			if err := m.Guess.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_WarCupSelfInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_WarCupSelfInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_WarCupSelfInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_WarCupSelfInfo_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_WarCupSelfInfo_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_WarCupSelfInfo_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VsData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VsData = append(m.VsData, &WarCupVsData{})
			if err := m.VsData[len(m.VsData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurReplay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CurReplay == nil {
				m.CurReplay = &BattleReplay{}
			}
			if err := m.CurReplay.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_WarCupTop64Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_WarCupTop64Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_WarCupTop64Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grp", wireType)
			}
			m.Grp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Grp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_WarCupTop64Info_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_WarCupTop64Info_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_WarCupTop64Info_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VsData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VsData = append(m.VsData, &WarCupVsData{})
			if err := m.VsData[len(m.VsData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_WarCupTop8Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_WarCupTop8Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_WarCupTop8Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_WarCupTop8Info_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_WarCupTop8Info_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_WarCupTop8Info_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VsData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VsData = append(m.VsData, &WarCupVsData{})
			if err := m.VsData[len(m.VsData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_WarCupGuess) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_WarCupGuess: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_WarCupGuess: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuessWin", wireType)
			}
			m.GuessWin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuessWin |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuessNum", wireType)
			}
			m.GuessNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuessNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_WarCupGuess_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_WarCupGuess_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_WarCupGuess_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuessScore", wireType)
			}
			m.GuessScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuessScore |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_WarCupAuditionRank) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_WarCupAuditionRank: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_WarCupAuditionRank: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Top", wireType)
			}
			m.Top = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Top |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			m.N = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.N |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_WarCupAuditionRank_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_WarCupAuditionRank_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_WarCupAuditionRank_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rows = append(m.Rows, &RankRow{})
			if err := m.Rows[len(m.Rows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_WarCupChatSend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_WarCupChatSend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_WarCupChatSend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_WarCupChatSend_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_WarCupChatSend_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_WarCupChatSend_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_WarCupGetReplay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_WarCupGetReplay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_WarCupGetReplay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VsSeq", wireType)
			}
			m.VsSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VsSeq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_WarCupGetReplay_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_WarCupGetReplay_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_WarCupGetReplay_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Replay == nil {
				m.Replay = &BattleReplay{}
			}
			if err := m.Replay.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_WarCupTop1Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_WarCupTop1Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_WarCupTop1Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_WarCupTop1Info_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_WarCupTop1Info_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_WarCupTop1Info_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Plr == nil {
				m.Plr = &PlayerSimpleInfo{}
			}
			if err := m.Plr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroId", wireType)
			}
			m.HeroId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroStar", wireType)
			}
			m.HeroStar = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroStar |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroSkin", wireType)
			}
			m.HeroSkin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroSkin |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_WarCupTaskTake) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_WarCupTaskTake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_WarCupTaskTake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_WarCupTaskTake_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_WarCupTaskTake_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_WarCupTaskTake_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rewards == nil {
				m.Rewards = &Rewards{}
			}
			if err := m.Rewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_WarCupWatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_WarCupWatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_WarCupWatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_WarCupGuessRecords) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_WarCupGuessRecords: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_WarCupGuessRecords: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_WarCupGuessRecords_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_WarCupGuessRecords_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_WarCupGuessRecords_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Records", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Records = append(m.Records, &WarCupPlrGuessOne{})
			if err := m.Records[len(m.Records)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_60Warcup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_60Warcup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCGs_60Warcup(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCGs_60Warcup
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCGs_60Warcup
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCGs_60Warcup
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCGs_60Warcup
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCGs_60Warcup(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCGs_60Warcup = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCGs_60Warcup   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("c_gs.60.warcup.proto", fileDescriptorCGs_60Warcup) }

var fileDescriptorCGs_60Warcup = []byte{
	// 1070 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x56, 0x41, 0x6f, 0x1b, 0x45,
	0x14, 0xee, 0xac, 0x63, 0x27, 0x79, 0x4d, 0xdb, 0x64, 0xeb, 0x86, 0x55, 0x84, 0x2c, 0x6b, 0x24,
	0x42, 0x82, 0x2a, 0x93, 0xb8, 0x25, 0xe2, 0xc2, 0x21, 0x75, 0x4b, 0x9a, 0x4b, 0x62, 0x8d, 0x4d,
	0x22, 0x84, 0x44, 0x98, 0x7a, 0xa7, 0x8e, 0x89, 0xbd, 0xb3, 0xcc, 0xee, 0x2a, 0xea, 0x0f, 0xe0,
	0x88, 0xe0, 0xc0, 0x0f, 0xe0, 0x07, 0xf0, 0x43, 0x7a, 0xe4, 0xcc, 0x09, 0xc2, 0xff, 0x40, 0x68,
	0xde, 0xec, 0xac, 0x67, 0x43, 0x5a, 0x1b, 0xa9, 0x12, 0xb7, 0x79, 0xef, 0x7d, 0x3b, 0xf3, 0xde,
	0x37, 0xdf, 0xbc, 0xb7, 0x50, 0x1f, 0x9c, 0x0d, 0x93, 0xd6, 0xde, 0x4e, 0xeb, 0x92, 0xab, 0x41,
	0x16, 0xb7, 0x62, 0x25, 0x53, 0xe9, 0x57, 0x26, 0xc9, 0x70, 0x03, 0x86, 0x72, 0x28, 0x8d, 0x63,
	0xe3, 0x01, 0xc2, 0x76, 0x76, 0x5a, 0x49, 0xaa, 0xb2, 0x41, 0x9a, 0xe4, 0x6e, 0x1f, 0xdd, 0xed,
	0xc7, 0x2d, 0xc5, 0xa3, 0x0b, 0xe3, 0xa3, 0x7f, 0x13, 0x80, 0x53, 0xae, 0x3a, 0x59, 0xfc, 0x94,
	0xa7, 0xdc, 0xaf, 0x43, 0xb5, 0x97, 0xf2, 0xa1, 0x08, 0x48, 0x93, 0x6c, 0x55, 0x99, 0x31, 0xfc,
	0x55, 0xa8, 0xf4, 0x93, 0x76, 0xe0, 0x35, 0xc9, 0x56, 0x85, 0xe9, 0xa5, 0xc6, 0x31, 0x99, 0x45,
	0x61, 0x50, 0x31, 0x38, 0x34, 0xfc, 0x06, 0x00, 0x2e, 0xba, 0x23, 0x31, 0x10, 0xc1, 0x02, 0x86,
	0x1c, 0x8f, 0x8e, 0xe3, 0xe2, 0x59, 0x14, 0xf6, 0x93, 0xa0, 0x8a, 0xdb, 0x39, 0x1e, 0xff, 0x21,
	0xd4, 0xf6, 0xd3, 0x94, 0x8f, 0xa2, 0xa0, 0xd6, 0xac, 0x6c, 0xdd, 0x6e, 0xd7, 0x5b, 0x93, 0x64,
	0xd8, 0x32, 0xe9, 0x99, 0xc0, 0xf1, 0x8b, 0x6f, 0x59, 0x8e, 0xf1, 0xdf, 0x87, 0xe5, 0x3e, 0x4f,
	0x2e, 0xfa, 0xfc, 0x42, 0x44, 0xc1, 0x62, 0xb3, 0xb2, 0x55, 0x65, 0x53, 0x87, 0xbf, 0x09, 0x0b,
	0x9d, 0x73, 0x9e, 0x06, 0x4b, 0xb8, 0x93, 0xef, 0xec, 0xa4, 0xdd, 0xc7, 0x91, 0x60, 0x18, 0xa7,
	0xbf, 0x78, 0x70, 0xcf, 0xf8, 0x0f, 0x32, 0x91, 0x24, 0xc8, 0x42, 0x03, 0x00, 0x8d, 0xde, 0x40,
	0x2a, 0x4b, 0x85, 0xe3, 0xf1, 0x37, 0x60, 0x09, 0xad, 0xe7, 0x3c, 0x41, 0x52, 0x96, 0x58, 0x61,
	0xfb, 0xdb, 0x50, 0x63, 0x22, 0x1e, 0xf3, 0x57, 0x48, 0xcd, 0xed, 0xf6, 0x1a, 0x9e, 0xfc, 0x84,
	0xa7, 0xe9, 0x58, 0x98, 0x00, 0xcb, 0x01, 0xc5, 0x36, 0xa7, 0xa3, 0x28, 0x27, 0xab, 0xb0, 0x8b,
	0xd8, 0x51, 0x36, 0x41, 0xa2, 0x6c, 0xec, 0x28, 0x9b, 0x14, 0xe9, 0x31, 0x9e, 0x8e, 0x64, 0x50,
	0x6b, 0x92, 0x2d, 0x8f, 0x39, 0x1e, 0x7f, 0x13, 0xee, 0xda, 0x7d, 0xd0, 0xb1, 0x1b, 0x2c, 0x22,
	0xe6, 0x9a, 0xf7, 0x5f, 0xb8, 0x76, 0xb0, 0x74, 0x03, 0xae, 0x4d, 0x7f, 0x20, 0xb0, 0x66, 0x28,
	0xea, 0x8e, 0x15, 0xc6, 0x8e, 0x23, 0xf1, 0x06, 0xa9, 0x14, 0xc2, 0xf0, 0x5c, 0x61, 0xf8, 0xb0,
	0x70, 0xc4, 0x27, 0x02, 0x29, 0x59, 0x66, 0xb8, 0xd6, 0xa2, 0xd2, 0xc5, 0x99, 0xc2, 0xf5, 0x52,
	0x7b, 0xf6, 0xc3, 0x30, 0x2f, 0x57, 0x2f, 0xf5, 0x6e, 0x87, 0xc9, 0xe7, 0xa8, 0x07, 0xcd, 0xb2,
	0x31, 0xe8, 0xef, 0x04, 0x56, 0x4c, 0x3e, 0x27, 0x89, 0x55, 0xed, 0x49, 0xd2, 0x13, 0xdf, 0xd9,
	0x54, 0xd0, 0x98, 0x26, 0xe8, 0xdd, 0x98, 0x60, 0x49, 0xb9, 0xdb, 0xb0, 0xd0, 0x1d, 0xab, 0x5d,
	0xcc, 0xe6, 0x76, 0xfb, 0x01, 0xde, 0x59, 0x77, 0xcc, 0x5f, 0x09, 0xd5, 0x1b, 0x4d, 0xe2, 0xb1,
	0x38, 0x8c, 0x5e, 0x4a, 0x86, 0x90, 0x1c, 0xda, 0xc6, 0x34, 0xdf, 0x0a, 0x6d, 0xfb, 0xeb, 0x50,
	0x3b, 0x1d, 0x45, 0x91, 0x50, 0x98, 0x7f, 0x95, 0xe5, 0x96, 0xbe, 0xdc, 0xfd, 0x30, 0x34, 0xea,
	0x5a, 0x34, 0x97, 0x6b, 0x6d, 0xfa, 0x89, 0x95, 0x63, 0x21, 0x78, 0xcd, 0xcb, 0xf1, 0x61, 0x98,
	0x17, 0xa7, 0x97, 0xda, 0x73, 0xc2, 0xc7, 0x58, 0x18, 0x61, 0x7a, 0x49, 0x3f, 0x83, 0x3b, 0x25,
	0x75, 0x17, 0x94, 0x13, 0x87, 0xf2, 0x00, 0x16, 0x3b, 0x32, 0x4a, 0x45, 0x94, 0xe2, 0xa7, 0xcb,
	0xcc, 0x9a, 0xf4, 0x67, 0x02, 0xf5, 0x83, 0xde, 0x99, 0xd9, 0x02, 0x89, 0xfa, 0x22, 0x0e, 0x79,
	0x2a, 0xfe, 0xdf, 0x86, 0xa0, 0xab, 0x2a, 0xb2, 0xd2, 0x85, 0xfd, 0xc7, 0xaa, 0xbe, 0x27, 0x70,
	0xbf, 0xf8, 0xde, 0x79, 0x20, 0xe5, 0x07, 0x44, 0xe6, 0x78, 0x40, 0xde, 0x9c, 0x0f, 0xa8, 0x72,
	0xe3, 0x03, 0x7a, 0x0a, 0x8d, 0x22, 0x8d, 0xe2, 0x5a, 0x4f, 0xf8, 0x38, 0x13, 0x9d, 0x73, 0x1e,
	0x0d, 0x45, 0x38, 0xd7, 0x15, 0xdf, 0x87, 0xb5, 0x8e, 0x5b, 0x8b, 0x16, 0x1a, 0xfd, 0xc6, 0xb9,
	0xb7, 0xc2, 0x7b, 0xc6, 0x74, 0x73, 0x7c, 0xa6, 0x94, 0x54, 0x1d, 0x19, 0xda, 0xbb, 0x9b, 0x3a,
	0xfc, 0x8f, 0xa0, 0x8a, 0x60, 0xdc, 0xbe, 0xdc, 0x67, 0x8b, 0x2e, 0xc8, 0x0c, 0x84, 0xfa, 0xb0,
	0x6a, 0x8f, 0xed, 0x89, 0xf1, 0x4b, 0x3c, 0xf5, 0x47, 0x97, 0x58, 0xeb, 0x9d, 0x79, 0xea, 0x36,
	0xd4, 0xcc, 0x83, 0x0d, 0x3c, 0x6c, 0xca, 0x6b, 0xce, 0xb1, 0x26, 0xc0, 0x72, 0x80, 0xff, 0x31,
	0x2c, 0x77, 0x32, 0x35, 0xab, 0x91, 0x4e, 0x31, 0xf4, 0x83, 0x29, 0x39, 0x7d, 0x19, 0xef, 0x3d,
	0xd6, 0x09, 0x69, 0x0e, 0x0f, 0x54, 0x6c, 0x59, 0x3d, 0x50, 0x31, 0x3d, 0x73, 0xe8, 0x2a, 0x70,
	0xef, 0x30, 0x71, 0x97, 0xad, 0xbe, 0x8c, 0x3f, 0x45, 0xb6, 0xbe, 0x76, 0xc8, 0xb2, 0xce, 0x77,
	0x79, 0xe6, 0x01, 0xdc, 0x29, 0x09, 0xa3, 0x34, 0x58, 0xc8, 0x5b, 0x06, 0x8b, 0x57, 0x1e, 0x2c,
	0xb4, 0x0b, 0xab, 0x65, 0x31, 0xcd, 0xcc, 0xb2, 0x3c, 0x29, 0xbd, 0xeb, 0x93, 0x92, 0xee, 0x41,
	0xdd, 0xa6, 0xb6, 0x9f, 0x85, 0xa3, 0x74, 0x24, 0x23, 0xc6, 0xa3, 0x0b, 0x6c, 0x20, 0xb2, 0xb8,
	0x99, 0xbe, 0x8c, 0xfd, 0x15, 0x20, 0x47, 0xf9, 0x06, 0xe4, 0x88, 0x7e, 0x09, 0xef, 0x4d, 0x5f,
	0x8c, 0xf3, 0xe1, 0xcc, 0x84, 0x9a, 0xb0, 0xc0, 0xe4, 0x65, 0x92, 0x93, 0xb6, 0x82, 0xa4, 0xe9,
	0x0f, 0x99, 0xbc, 0x64, 0x18, 0xa1, 0x0f, 0xa7, 0x37, 0xa4, 0x5b, 0x4a, 0x4f, 0x44, 0xa1, 0xdb,
	0x42, 0x48, 0xb9, 0x85, 0x3c, 0x72, 0xee, 0xce, 0xc2, 0x67, 0x25, 0x41, 0xb7, 0x9d, 0x97, 0x2a,
	0xd2, 0x7c, 0xda, 0xdf, 0x38, 0xa4, 0x4a, 0x82, 0x2c, 0xb0, 0xf3, 0x88, 0x23, 0x7f, 0x1b, 0xde,
	0x8c, 0x9f, 0x8c, 0x6b, 0x82, 0xdc, 0x45, 0x41, 0xfe, 0x4a, 0xca, 0x8a, 0xdc, 0x9d, 0x4b, 0x91,
	0x1f, 0x42, 0xa5, 0x3b, 0x56, 0xf9, 0x89, 0x6f, 0x98, 0x7b, 0x1a, 0xa1, 0xc7, 0xde, 0x73, 0xa1,
	0xe4, 0xa1, 0x1d, 0x06, 0xb9, 0xa5, 0xa5, 0xa7, 0x57, 0xbd, 0x94, 0x2b, 0xfb, 0xbf, 0x63, 0xed,
	0x22, 0x76, 0x31, 0x8a, 0xec, 0xff, 0x8e, 0xb5, 0x29, 0x75, 0x4a, 0xc8, 0xff, 0xef, 0xfc, 0xbb,
	0xe0, 0x15, 0xfd, 0xd2, 0x3b, 0x0c, 0xe9, 0x57, 0x6e, 0x45, 0x39, 0x68, 0x66, 0x45, 0x9b, 0xb0,
	0xc8, 0xc4, 0x25, 0x57, 0xa1, 0x6d, 0x84, 0xb9, 0x5e, 0x8c, 0x8f, 0xd9, 0x20, 0xbd, 0x37, 0x7d,
	0x60, 0xa7, 0x3c, 0x1d, 0x9c, 0xd3, 0xf5, 0xa9, 0xac, 0xcd, 0xd8, 0x10, 0x03, 0xa9, 0x81, 0x23,
	0x47, 0xb6, 0x6e, 0x60, 0x66, 0x26, 0x3b, 0x3a, 0x13, 0x84, 0xe6, 0xca, 0x5d, 0x77, 0x9e, 0xbb,
	0xf3, 0xd7, 0xc5, 0x2c, 0xec, 0x49, 0xfd, 0xf5, 0x9f, 0x8d, 0x5b, 0xaf, 0xaf, 0x1a, 0xe4, 0xb7,
	0xab, 0x06, 0xf9, 0xe3, 0xaa, 0x41, 0x7e, 0xfa, 0xab, 0x71, 0xeb, 0x45, 0x0d, 0xff, 0xea, 0x1f,
	0xfd, 0x13, 0x00, 0x00, 0xff, 0xff, 0x42, 0x62, 0x45, 0x71, 0x29, 0x0c, 0x00, 0x00,
}
