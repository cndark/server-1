// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: c_gs.00.structs.proto

package msg

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// 玩家简要信息
type PlayerSimpleInfo struct {
	Id       string `protobuf:"bytes,1,opt,name=Id,proto3" json:""`
	Name     string `protobuf:"bytes,2,opt,name=Name,proto3" json:""`
	Lv       int32  `protobuf:"varint,3,opt,name=Lv,proto3" json:""`
	Exp      int32  `protobuf:"varint,4,opt,name=Exp,proto3" json:""`
	Head     string `protobuf:"bytes,5,opt,name=Head,proto3" json:""`
	HFrame   int32  `protobuf:"varint,6,opt,name=HFrame,proto3" json:""`
	Vip      int32  `protobuf:"varint,7,opt,name=Vip,proto3" json:""`
	SvrId    int32  `protobuf:"varint,8,opt,name=SvrId,proto3" json:""`
	AtkPwr   int32  `protobuf:"varint,9,opt,name=AtkPwr,proto3" json:""`
	GName    string `protobuf:"bytes,10,opt,name=GName,proto3" json:""`
	ShowHero int32  `protobuf:"varint,11,opt,name=ShowHero,proto3" json:""`
}

func (m *PlayerSimpleInfo) Reset()                    { *m = PlayerSimpleInfo{} }
func (m *PlayerSimpleInfo) String() string            { return proto.CompactTextString(m) }
func (*PlayerSimpleInfo) ProtoMessage()               {}
func (*PlayerSimpleInfo) Descriptor() ([]byte, []int) { return fileDescriptorCGs_00Structs, []int{0} }

// 货币
type Ccy struct {
	Id  int32 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	Val int64 `protobuf:"varint,2,opt,name=Val,proto3" json:"Val,omitempty"`
}

func (m *Ccy) Reset()                    { *m = Ccy{} }
func (m *Ccy) String() string            { return proto.CompactTextString(m) }
func (*Ccy) ProtoMessage()               {}
func (*Ccy) Descriptor() ([]byte, []int) { return fileDescriptorCGs_00Structs, []int{1} }

// 道具
type Item struct {
	Id  int32 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	Num int32 `protobuf:"varint,2,opt,name=Num,proto3" json:"Num,omitempty"`
}

func (m *Item) Reset()                    { *m = Item{} }
func (m *Item) String() string            { return proto.CompactTextString(m) }
func (*Item) ProtoMessage()               {}
func (*Item) Descriptor() ([]byte, []int) { return fileDescriptorCGs_00Structs, []int{2} }

// 英雄
type Hero struct {
	Seq      int64             `protobuf:"varint,1,opt,name=Seq,proto3" json:"Seq,omitempty"`
	Id       int32             `protobuf:"varint,2,opt,name=Id,proto3" json:"Id,omitempty"`
	Lv       int32             `protobuf:"varint,3,opt,name=Lv,proto3" json:"Lv,omitempty"`
	Star     int32             `protobuf:"varint,4,opt,name=Star,proto3" json:"Star,omitempty"`
	Trinket  *Trinket          `protobuf:"bytes,5,opt,name=Trinket" json:"Trinket,omitempty"`
	Props    map[int32]float32 `protobuf:"bytes,6,rep,name=Props" json:"Props,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	Locked   bool              `protobuf:"varint,7,opt,name=Locked,proto3" json:"Locked,omitempty"`
	AtkPwr   int32             `protobuf:"varint,8,opt,name=AtkPwr,proto3" json:"AtkPwr,omitempty"`
	ChangeId int32             `protobuf:"varint,9,opt,name=ChangeId,proto3" json:"ChangeId,omitempty"`
	Skin     int32             `protobuf:"varint,10,opt,name=Skin,proto3" json:"Skin,omitempty"`
}

func (m *Hero) Reset()                    { *m = Hero{} }
func (m *Hero) String() string            { return proto.CompactTextString(m) }
func (*Hero) ProtoMessage()               {}
func (*Hero) Descriptor() ([]byte, []int) { return fileDescriptorCGs_00Structs, []int{3} }

// 英雄详情(加装备)
type HeroDetail struct {
	Hero   *Hero           `protobuf:"bytes,1,opt,name=Hero" json:"Hero,omitempty"`
	Armors []int32         `protobuf:"varint,2,rep,packed,name=Armors" json:"Armors,omitempty"`
	Relic  map[int32]int32 `protobuf:"bytes,3,rep,name=Relic" json:"Relic,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *HeroDetail) Reset()                    { *m = HeroDetail{} }
func (m *HeroDetail) String() string            { return proto.CompactTextString(m) }
func (*HeroDetail) ProtoMessage()               {}
func (*HeroDetail) Descriptor() ([]byte, []int) { return fileDescriptorCGs_00Structs, []int{4} }

type Trinket struct {
	Lv    int32   `protobuf:"varint,1,opt,name=Lv,proto3" json:"Lv,omitempty"`
	Props []int32 `protobuf:"varint,2,rep,packed,name=Props" json:"Props,omitempty"`
}

func (m *Trinket) Reset()                    { *m = Trinket{} }
func (m *Trinket) String() string            { return proto.CompactTextString(m) }
func (*Trinket) ProtoMessage()               {}
func (*Trinket) Descriptor() ([]byte, []int) { return fileDescriptorCGs_00Structs, []int{5} }

// 装备
type Armor struct {
	Seq     int64 `protobuf:"varint,1,opt,name=Seq,proto3" json:"Seq,omitempty"`
	Id      int32 `protobuf:"varint,2,opt,name=Id,proto3" json:"Id,omitempty"`
	HeroSeq int64 `protobuf:"varint,3,opt,name=HeroSeq,proto3" json:"HeroSeq,omitempty"`
}

func (m *Armor) Reset()                    { *m = Armor{} }
func (m *Armor) String() string            { return proto.CompactTextString(m) }
func (*Armor) ProtoMessage()               {}
func (*Armor) Descriptor() ([]byte, []int) { return fileDescriptorCGs_00Structs, []int{6} }

type Relic struct {
	Seq     int64 `protobuf:"varint,1,opt,name=Seq,proto3" json:"Seq,omitempty"`
	Id      int32 `protobuf:"varint,2,opt,name=Id,proto3" json:"Id,omitempty"`
	Star    int32 `protobuf:"varint,3,opt,name=Star,proto3" json:"Star,omitempty"`
	Xp      int32 `protobuf:"varint,4,opt,name=Xp,proto3" json:"Xp,omitempty"`
	HeroSeq int64 `protobuf:"varint,5,opt,name=HeroSeq,proto3" json:"HeroSeq,omitempty"`
}

func (m *Relic) Reset()                    { *m = Relic{} }
func (m *Relic) String() string            { return proto.CompactTextString(m) }
func (*Relic) ProtoMessage()               {}
func (*Relic) Descriptor() ([]byte, []int) { return fileDescriptorCGs_00Structs, []int{7} }

// 奖励
type Rewards struct {
	Ccy    []*Ccy  `protobuf:"bytes,1,rep,name=Ccy" json:"Ccy,omitempty"`
	Items  []*Item `protobuf:"bytes,2,rep,name=Items" json:"Items,omitempty"`
	Heroes []int64 `protobuf:"varint,3,rep,packed,name=Heroes" json:"Heroes,omitempty"`
	Relics []int64 `protobuf:"varint,4,rep,packed,name=Relics" json:"Relics,omitempty"`
}

func (m *Rewards) Reset()                    { *m = Rewards{} }
func (m *Rewards) String() string            { return proto.CompactTextString(m) }
func (*Rewards) ProtoMessage()               {}
func (*Rewards) Descriptor() ([]byte, []int) { return fileDescriptorCGs_00Structs, []int{8} }

// 队伍布阵
type TeamFormation struct {
	Formation map[int64]int32 `protobuf:"bytes,1,rep,name=Formation" json:"Formation,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *TeamFormation) Reset()                    { *m = TeamFormation{} }
func (m *TeamFormation) String() string            { return proto.CompactTextString(m) }
func (*TeamFormation) ProtoMessage()               {}
func (*TeamFormation) Descriptor() ([]byte, []int) { return fileDescriptorCGs_00Structs, []int{9} }

type BattleFighter struct {
	Seq    int64             `protobuf:"varint,1,opt,name=Seq,proto3" json:""`
	Id     int32             `protobuf:"varint,2,opt,name=Id,proto3" json:""`
	Lv     int32             `protobuf:"varint,3,opt,name=Lv,proto3" json:""`
	Star   int32             `protobuf:"varint,4,opt,name=Star,proto3" json:""`
	Props  map[int32]float32 `protobuf:"bytes,5,rep,name=Props" json:"" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	Pos    int32             `protobuf:"varint,6,opt,name=Pos,proto3" json:""`
	AtkPwr int32             `protobuf:"varint,7,opt,name=AtkPwr,proto3" json:""`
	Skin   int32             `protobuf:"varint,8,opt,name=Skin,proto3" json:""`
}

func (m *BattleFighter) Reset()                    { *m = BattleFighter{} }
func (m *BattleFighter) String() string            { return proto.CompactTextString(m) }
func (*BattleFighter) ProtoMessage()               {}
func (*BattleFighter) Descriptor() ([]byte, []int) { return fileDescriptorCGs_00Structs, []int{10} }

type BattleTeam struct {
	Player   *PlayerSimpleInfo `protobuf:"bytes,1,opt,name=Player" json:"Player,omitempty"`
	Fighters []*BattleFighter  `protobuf:"bytes,2,rep,name=Fighters" json:"Fighters,omitempty"`
}

func (m *BattleTeam) Reset()                    { *m = BattleTeam{} }
func (m *BattleTeam) String() string            { return proto.CompactTextString(m) }
func (*BattleTeam) ProtoMessage()               {}
func (*BattleTeam) Descriptor() ([]byte, []int) { return fileDescriptorCGs_00Structs, []int{11} }

type BattleInput struct {
	T1   *BattleTeam       `protobuf:"bytes,1,opt,name=T1" json:"T1,omitempty"`
	T2   *BattleTeam       `protobuf:"bytes,2,opt,name=T2" json:"T2,omitempty"`
	Args map[string]string `protobuf:"bytes,3,rep,name=Args" json:"Args,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *BattleInput) Reset()                    { *m = BattleInput{} }
func (m *BattleInput) String() string            { return proto.CompactTextString(m) }
func (*BattleInput) ProtoMessage()               {}
func (*BattleInput) Descriptor() ([]byte, []int) { return fileDescriptorCGs_00Structs, []int{12} }

type BattleResult struct {
	Winner int32             `protobuf:"varint,1,opt,name=Winner,proto3" json:"Winner,omitempty"`
	Args   map[string]string `protobuf:"bytes,2,rep,name=Args" json:"Args,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *BattleResult) Reset()                    { *m = BattleResult{} }
func (m *BattleResult) String() string            { return proto.CompactTextString(m) }
func (*BattleResult) ProtoMessage()               {}
func (*BattleResult) Descriptor() ([]byte, []int) { return fileDescriptorCGs_00Structs, []int{13} }

type BattleReplay struct {
	Id string        `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty"`
	Ts int64         `protobuf:"varint,2,opt,name=Ts,proto3" json:"Ts,omitempty"`
	Bi *BattleInput  `protobuf:"bytes,3,opt,name=Bi" json:"Bi,omitempty"`
	Br *BattleResult `protobuf:"bytes,4,opt,name=Br" json:"Br,omitempty"`
}

func (m *BattleReplay) Reset()                    { *m = BattleReplay{} }
func (m *BattleReplay) String() string            { return proto.CompactTextString(m) }
func (*BattleReplay) ProtoMessage()               {}
func (*BattleReplay) Descriptor() ([]byte, []int) { return fileDescriptorCGs_00Structs, []int{14} }

// loading page info
type ForLoading struct {
}

func (m *ForLoading) Reset()                    { *m = ForLoading{} }
func (m *ForLoading) String() string            { return proto.CompactTextString(m) }
func (*ForLoading) ProtoMessage()               {}
func (*ForLoading) Descriptor() ([]byte, []int) { return fileDescriptorCGs_00Structs, []int{15} }

func init() {
	proto.RegisterType((*PlayerSimpleInfo)(nil), "msg.PlayerSimpleInfo")
	proto.RegisterType((*Ccy)(nil), "msg.Ccy")
	proto.RegisterType((*Item)(nil), "msg.Item")
	proto.RegisterType((*Hero)(nil), "msg.Hero")
	proto.RegisterType((*HeroDetail)(nil), "msg.HeroDetail")
	proto.RegisterType((*Trinket)(nil), "msg.Trinket")
	proto.RegisterType((*Armor)(nil), "msg.Armor")
	proto.RegisterType((*Relic)(nil), "msg.Relic")
	proto.RegisterType((*Rewards)(nil), "msg.Rewards")
	proto.RegisterType((*TeamFormation)(nil), "msg.TeamFormation")
	proto.RegisterType((*BattleFighter)(nil), "msg.BattleFighter")
	proto.RegisterType((*BattleTeam)(nil), "msg.BattleTeam")
	proto.RegisterType((*BattleInput)(nil), "msg.BattleInput")
	proto.RegisterType((*BattleResult)(nil), "msg.BattleResult")
	proto.RegisterType((*BattleReplay)(nil), "msg.BattleReplay")
	proto.RegisterType((*ForLoading)(nil), "msg.ForLoading")
}
func (m *PlayerSimpleInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerSimpleInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Lv != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Lv))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Exp))
	}
	if len(m.Head) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(len(m.Head)))
		i += copy(dAtA[i:], m.Head)
	}
	if m.HFrame != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.HFrame))
	}
	if m.Vip != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Vip))
	}
	if m.SvrId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.SvrId))
	}
	if m.AtkPwr != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.AtkPwr))
	}
	if len(m.GName) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(len(m.GName)))
		i += copy(dAtA[i:], m.GName)
	}
	if m.ShowHero != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.ShowHero))
	}
	return i, nil
}

func (m *Ccy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ccy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Id))
	}
	if m.Val != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Val))
	}
	return i, nil
}

func (m *Item) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Item) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Id))
	}
	if m.Num != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Num))
	}
	return i, nil
}

func (m *Hero) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Hero) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seq != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Seq))
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Id))
	}
	if m.Lv != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Lv))
	}
	if m.Star != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Star))
	}
	if m.Trinket != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Trinket.Size()))
		n1, err := m.Trinket.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Props) > 0 {
		for k, _ := range m.Props {
			dAtA[i] = 0x32
			i++
			v := m.Props[k]
			mapSize := 1 + sovCGs_00Structs(uint64(k)) + 1 + 4
			i = encodeVarintCGs_00Structs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCGs_00Structs(dAtA, i, uint64(k))
			dAtA[i] = 0x15
			i++
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(v))))
			i += 4
		}
	}
	if m.Locked {
		dAtA[i] = 0x38
		i++
		if m.Locked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AtkPwr != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.AtkPwr))
	}
	if m.ChangeId != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.ChangeId))
	}
	if m.Skin != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Skin))
	}
	return i, nil
}

func (m *HeroDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroDetail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Hero != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Hero.Size()))
		n2, err := m.Hero.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Armors) > 0 {
		dAtA4 := make([]byte, len(m.Armors)*10)
		var j3 int
		for _, num1 := range m.Armors {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if len(m.Relic) > 0 {
		for k, _ := range m.Relic {
			dAtA[i] = 0x1a
			i++
			v := m.Relic[k]
			mapSize := 1 + sovCGs_00Structs(uint64(k)) + 1 + sovCGs_00Structs(uint64(v))
			i = encodeVarintCGs_00Structs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCGs_00Structs(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCGs_00Structs(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *Trinket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Trinket) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Lv != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Lv))
	}
	if len(m.Props) > 0 {
		dAtA6 := make([]byte, len(m.Props)*10)
		var j5 int
		for _, num1 := range m.Props {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	return i, nil
}

func (m *Armor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Armor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seq != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Seq))
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Id))
	}
	if m.HeroSeq != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.HeroSeq))
	}
	return i, nil
}

func (m *Relic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Relic) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seq != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Seq))
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Id))
	}
	if m.Star != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Star))
	}
	if m.Xp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Xp))
	}
	if m.HeroSeq != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.HeroSeq))
	}
	return i, nil
}

func (m *Rewards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rewards) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ccy) > 0 {
		for _, msg := range m.Ccy {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCGs_00Structs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCGs_00Structs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Heroes) > 0 {
		dAtA8 := make([]byte, len(m.Heroes)*10)
		var j7 int
		for _, num1 := range m.Heroes {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	if len(m.Relics) > 0 {
		dAtA10 := make([]byte, len(m.Relics)*10)
		var j9 int
		for _, num1 := range m.Relics {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(j9))
		i += copy(dAtA[i:], dAtA10[:j9])
	}
	return i, nil
}

func (m *TeamFormation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TeamFormation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Formation) > 0 {
		for k, _ := range m.Formation {
			dAtA[i] = 0xa
			i++
			v := m.Formation[k]
			mapSize := 1 + sovCGs_00Structs(uint64(k)) + 1 + sovCGs_00Structs(uint64(v))
			i = encodeVarintCGs_00Structs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCGs_00Structs(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCGs_00Structs(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *BattleFighter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BattleFighter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seq != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Seq))
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Id))
	}
	if m.Lv != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Lv))
	}
	if m.Star != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Star))
	}
	if len(m.Props) > 0 {
		for k, _ := range m.Props {
			dAtA[i] = 0x2a
			i++
			v := m.Props[k]
			mapSize := 1 + sovCGs_00Structs(uint64(k)) + 1 + 4
			i = encodeVarintCGs_00Structs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCGs_00Structs(dAtA, i, uint64(k))
			dAtA[i] = 0x15
			i++
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(v))))
			i += 4
		}
	}
	if m.Pos != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Pos))
	}
	if m.AtkPwr != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.AtkPwr))
	}
	if m.Skin != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Skin))
	}
	return i, nil
}

func (m *BattleTeam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BattleTeam) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Player != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Player.Size()))
		n11, err := m.Player.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.Fighters) > 0 {
		for _, msg := range m.Fighters {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCGs_00Structs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BattleInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BattleInput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.T1 != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.T1.Size()))
		n12, err := m.T1.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.T2 != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.T2.Size()))
		n13, err := m.T2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.Args) > 0 {
		for k, _ := range m.Args {
			dAtA[i] = 0x1a
			i++
			v := m.Args[k]
			mapSize := 1 + len(k) + sovCGs_00Structs(uint64(len(k))) + 1 + len(v) + sovCGs_00Structs(uint64(len(v)))
			i = encodeVarintCGs_00Structs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCGs_00Structs(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintCGs_00Structs(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *BattleResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BattleResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Winner != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Winner))
	}
	if len(m.Args) > 0 {
		for k, _ := range m.Args {
			dAtA[i] = 0x12
			i++
			v := m.Args[k]
			mapSize := 1 + len(k) + sovCGs_00Structs(uint64(len(k))) + 1 + len(v) + sovCGs_00Structs(uint64(len(v)))
			i = encodeVarintCGs_00Structs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCGs_00Structs(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintCGs_00Structs(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *BattleReplay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BattleReplay) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Ts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Ts))
	}
	if m.Bi != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Bi.Size()))
		n14, err := m.Bi.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Br != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCGs_00Structs(dAtA, i, uint64(m.Br.Size()))
		n15, err := m.Br.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *ForLoading) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForLoading) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintCGs_00Structs(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *PlayerSimpleInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCGs_00Structs(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCGs_00Structs(uint64(l))
	}
	if m.Lv != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.Lv))
	}
	if m.Exp != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.Exp))
	}
	l = len(m.Head)
	if l > 0 {
		n += 1 + l + sovCGs_00Structs(uint64(l))
	}
	if m.HFrame != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.HFrame))
	}
	if m.Vip != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.Vip))
	}
	if m.SvrId != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.SvrId))
	}
	if m.AtkPwr != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.AtkPwr))
	}
	l = len(m.GName)
	if l > 0 {
		n += 1 + l + sovCGs_00Structs(uint64(l))
	}
	if m.ShowHero != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.ShowHero))
	}
	return n
}

func (m *Ccy) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.Id))
	}
	if m.Val != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.Val))
	}
	return n
}

func (m *Item) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.Id))
	}
	if m.Num != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.Num))
	}
	return n
}

func (m *Hero) Size() (n int) {
	var l int
	_ = l
	if m.Seq != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.Seq))
	}
	if m.Id != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.Id))
	}
	if m.Lv != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.Lv))
	}
	if m.Star != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.Star))
	}
	if m.Trinket != nil {
		l = m.Trinket.Size()
		n += 1 + l + sovCGs_00Structs(uint64(l))
	}
	if len(m.Props) > 0 {
		for k, v := range m.Props {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCGs_00Structs(uint64(k)) + 1 + 4
			n += mapEntrySize + 1 + sovCGs_00Structs(uint64(mapEntrySize))
		}
	}
	if m.Locked {
		n += 2
	}
	if m.AtkPwr != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.AtkPwr))
	}
	if m.ChangeId != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.ChangeId))
	}
	if m.Skin != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.Skin))
	}
	return n
}

func (m *HeroDetail) Size() (n int) {
	var l int
	_ = l
	if m.Hero != nil {
		l = m.Hero.Size()
		n += 1 + l + sovCGs_00Structs(uint64(l))
	}
	if len(m.Armors) > 0 {
		l = 0
		for _, e := range m.Armors {
			l += sovCGs_00Structs(uint64(e))
		}
		n += 1 + sovCGs_00Structs(uint64(l)) + l
	}
	if len(m.Relic) > 0 {
		for k, v := range m.Relic {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCGs_00Structs(uint64(k)) + 1 + sovCGs_00Structs(uint64(v))
			n += mapEntrySize + 1 + sovCGs_00Structs(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Trinket) Size() (n int) {
	var l int
	_ = l
	if m.Lv != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.Lv))
	}
	if len(m.Props) > 0 {
		l = 0
		for _, e := range m.Props {
			l += sovCGs_00Structs(uint64(e))
		}
		n += 1 + sovCGs_00Structs(uint64(l)) + l
	}
	return n
}

func (m *Armor) Size() (n int) {
	var l int
	_ = l
	if m.Seq != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.Seq))
	}
	if m.Id != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.Id))
	}
	if m.HeroSeq != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.HeroSeq))
	}
	return n
}

func (m *Relic) Size() (n int) {
	var l int
	_ = l
	if m.Seq != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.Seq))
	}
	if m.Id != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.Id))
	}
	if m.Star != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.Star))
	}
	if m.Xp != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.Xp))
	}
	if m.HeroSeq != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.HeroSeq))
	}
	return n
}

func (m *Rewards) Size() (n int) {
	var l int
	_ = l
	if len(m.Ccy) > 0 {
		for _, e := range m.Ccy {
			l = e.Size()
			n += 1 + l + sovCGs_00Structs(uint64(l))
		}
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovCGs_00Structs(uint64(l))
		}
	}
	if len(m.Heroes) > 0 {
		l = 0
		for _, e := range m.Heroes {
			l += sovCGs_00Structs(uint64(e))
		}
		n += 1 + sovCGs_00Structs(uint64(l)) + l
	}
	if len(m.Relics) > 0 {
		l = 0
		for _, e := range m.Relics {
			l += sovCGs_00Structs(uint64(e))
		}
		n += 1 + sovCGs_00Structs(uint64(l)) + l
	}
	return n
}

func (m *TeamFormation) Size() (n int) {
	var l int
	_ = l
	if len(m.Formation) > 0 {
		for k, v := range m.Formation {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCGs_00Structs(uint64(k)) + 1 + sovCGs_00Structs(uint64(v))
			n += mapEntrySize + 1 + sovCGs_00Structs(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *BattleFighter) Size() (n int) {
	var l int
	_ = l
	if m.Seq != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.Seq))
	}
	if m.Id != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.Id))
	}
	if m.Lv != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.Lv))
	}
	if m.Star != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.Star))
	}
	if len(m.Props) > 0 {
		for k, v := range m.Props {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCGs_00Structs(uint64(k)) + 1 + 4
			n += mapEntrySize + 1 + sovCGs_00Structs(uint64(mapEntrySize))
		}
	}
	if m.Pos != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.Pos))
	}
	if m.AtkPwr != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.AtkPwr))
	}
	if m.Skin != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.Skin))
	}
	return n
}

func (m *BattleTeam) Size() (n int) {
	var l int
	_ = l
	if m.Player != nil {
		l = m.Player.Size()
		n += 1 + l + sovCGs_00Structs(uint64(l))
	}
	if len(m.Fighters) > 0 {
		for _, e := range m.Fighters {
			l = e.Size()
			n += 1 + l + sovCGs_00Structs(uint64(l))
		}
	}
	return n
}

func (m *BattleInput) Size() (n int) {
	var l int
	_ = l
	if m.T1 != nil {
		l = m.T1.Size()
		n += 1 + l + sovCGs_00Structs(uint64(l))
	}
	if m.T2 != nil {
		l = m.T2.Size()
		n += 1 + l + sovCGs_00Structs(uint64(l))
	}
	if len(m.Args) > 0 {
		for k, v := range m.Args {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCGs_00Structs(uint64(len(k))) + 1 + len(v) + sovCGs_00Structs(uint64(len(v)))
			n += mapEntrySize + 1 + sovCGs_00Structs(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *BattleResult) Size() (n int) {
	var l int
	_ = l
	if m.Winner != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.Winner))
	}
	if len(m.Args) > 0 {
		for k, v := range m.Args {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCGs_00Structs(uint64(len(k))) + 1 + len(v) + sovCGs_00Structs(uint64(len(v)))
			n += mapEntrySize + 1 + sovCGs_00Structs(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *BattleReplay) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCGs_00Structs(uint64(l))
	}
	if m.Ts != 0 {
		n += 1 + sovCGs_00Structs(uint64(m.Ts))
	}
	if m.Bi != nil {
		l = m.Bi.Size()
		n += 1 + l + sovCGs_00Structs(uint64(l))
	}
	if m.Br != nil {
		l = m.Br.Size()
		n += 1 + l + sovCGs_00Structs(uint64(l))
	}
	return n
}

func (m *ForLoading) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovCGs_00Structs(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCGs_00Structs(x uint64) (n int) {
	return sovCGs_00Structs(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PlayerSimpleInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_00Structs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerSimpleInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerSimpleInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Head = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HFrame", wireType)
			}
			m.HFrame = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HFrame |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			m.Vip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vip |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SvrId", wireType)
			}
			m.SvrId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SvrId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkPwr", wireType)
			}
			m.AtkPwr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AtkPwr |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowHero", wireType)
			}
			m.ShowHero = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShowHero |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_00Structs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ccy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_00Structs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ccy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ccy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			m.Val = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Val |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_00Structs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Item) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_00Structs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_00Structs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Hero) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_00Structs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Hero: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Hero: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			m.Star = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Star |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trinket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Trinket == nil {
				m.Trinket = &Trinket{}
			}
			if err := m.Trinket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Props", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Props == nil {
				m.Props = make(map[int32]float32)
			}
			var mapkey int32
			var mapvalue float32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_00Structs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_00Structs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					mapvalue = math.Float32frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCGs_00Structs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCGs_00Structs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Props[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Locked = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkPwr", wireType)
			}
			m.AtkPwr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AtkPwr |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeId", wireType)
			}
			m.ChangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skin", wireType)
			}
			m.Skin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Skin |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_00Structs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_00Structs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hero", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hero == nil {
				m.Hero = &Hero{}
			}
			if err := m.Hero.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_00Structs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Armors = append(m.Armors, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_00Structs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCGs_00Structs
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_00Structs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Armors = append(m.Armors, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Armors", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Relic == nil {
				m.Relic = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_00Structs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_00Structs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_00Structs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCGs_00Structs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCGs_00Structs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Relic[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_00Structs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Trinket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_00Structs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Trinket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Trinket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_00Structs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Props = append(m.Props, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_00Structs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCGs_00Structs
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_00Structs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Props = append(m.Props, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Props", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_00Structs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Armor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_00Structs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Armor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Armor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroSeq", wireType)
			}
			m.HeroSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroSeq |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_00Structs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Relic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_00Structs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Relic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Relic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			m.Star = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Star |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Xp", wireType)
			}
			m.Xp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Xp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroSeq", wireType)
			}
			m.HeroSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroSeq |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_00Structs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rewards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_00Structs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rewards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rewards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ccy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ccy = append(m.Ccy, &Ccy{})
			if err := m.Ccy[len(m.Ccy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Item{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_00Structs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Heroes = append(m.Heroes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_00Structs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCGs_00Structs
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_00Structs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Heroes = append(m.Heroes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Heroes", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_00Structs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Relics = append(m.Relics, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_00Structs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCGs_00Structs
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_00Structs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Relics = append(m.Relics, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Relics", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_00Structs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TeamFormation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_00Structs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TeamFormation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TeamFormation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Formation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Formation == nil {
				m.Formation = make(map[int64]int32)
			}
			var mapkey int64
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_00Structs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_00Structs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_00Structs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCGs_00Structs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCGs_00Structs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Formation[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_00Structs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BattleFighter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_00Structs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BattleFighter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BattleFighter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			m.Star = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Star |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Props", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Props == nil {
				m.Props = make(map[int32]float32)
			}
			var mapkey int32
			var mapvalue float32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_00Structs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_00Structs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					mapvalue = math.Float32frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCGs_00Structs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCGs_00Structs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Props[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkPwr", wireType)
			}
			m.AtkPwr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AtkPwr |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skin", wireType)
			}
			m.Skin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Skin |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_00Structs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BattleTeam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_00Structs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BattleTeam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BattleTeam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Player == nil {
				m.Player = &PlayerSimpleInfo{}
			}
			if err := m.Player.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fighters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fighters = append(m.Fighters, &BattleFighter{})
			if err := m.Fighters[len(m.Fighters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_00Structs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BattleInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_00Structs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BattleInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BattleInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field T1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.T1 == nil {
				m.T1 = &BattleTeam{}
			}
			if err := m.T1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field T2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.T2 == nil {
				m.T2 = &BattleTeam{}
			}
			if err := m.T2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Args == nil {
				m.Args = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_00Structs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_00Structs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCGs_00Structs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_00Structs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCGs_00Structs
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCGs_00Structs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCGs_00Structs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Args[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_00Structs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BattleResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_00Structs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BattleResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BattleResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Winner", wireType)
			}
			m.Winner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Winner |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Args == nil {
				m.Args = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_00Structs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_00Structs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCGs_00Structs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_00Structs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCGs_00Structs
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCGs_00Structs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCGs_00Structs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Args[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_00Structs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BattleReplay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_00Structs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BattleReplay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BattleReplay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			m.Ts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bi == nil {
				m.Bi = &BattleInput{}
			}
			if err := m.Bi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Br", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Br == nil {
				m.Br = &BattleResult{}
			}
			if err := m.Br.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_00Structs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForLoading) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_00Structs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForLoading: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForLoading: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_00Structs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_00Structs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCGs_00Structs(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCGs_00Structs
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCGs_00Structs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCGs_00Structs
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCGs_00Structs
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCGs_00Structs(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCGs_00Structs = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCGs_00Structs   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("c_gs.00.structs.proto", fileDescriptorCGs_00Structs) }

var fileDescriptorCGs_00Structs = []byte{
	// 978 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xdf, 0x6e, 0x1b, 0xc5,
	0x17, 0xce, 0xce, 0x7a, 0xfd, 0xe7, 0x38, 0xcd, 0x2f, 0xbf, 0x91, 0x5b, 0x8d, 0x0c, 0x75, 0xdc,
	0xbd, 0x80, 0x08, 0x89, 0x6d, 0x6a, 0x2e, 0x28, 0x08, 0x09, 0xd5, 0xa1, 0x21, 0x96, 0xa2, 0x2a,
	0x1a, 0x5b, 0xa1, 0x77, 0x68, 0xb1, 0x87, 0xcd, 0xca, 0xf6, 0xae, 0x99, 0x5d, 0x3b, 0xf8, 0x25,
	0x50, 0xdf, 0x04, 0x89, 0xab, 0x8a, 0x27, 0xe8, 0x25, 0x4f, 0x80, 0x20, 0xdc, 0xf1, 0x14, 0x68,
	0xce, 0xcc, 0xae, 0xc7, 0xad, 0xa5, 0x56, 0x82, 0xbb, 0x39, 0xdf, 0x9c, 0x73, 0xe6, 0x9b, 0xef,
	0xcc, 0x39, 0xbb, 0x70, 0x77, 0xfc, 0x6d, 0x94, 0x05, 0x27, 0x27, 0x41, 0x96, 0xcb, 0xe5, 0x38,
	0xcf, 0x82, 0x85, 0x4c, 0xf3, 0x94, 0xba, 0xf3, 0x2c, 0x6a, 0x43, 0x94, 0x46, 0xa9, 0x06, 0xfc,
	0x97, 0x04, 0x0e, 0x2f, 0x67, 0xe1, 0x5a, 0xc8, 0x61, 0x3c, 0x5f, 0xcc, 0xc4, 0x20, 0xf9, 0x3e,
	0xa5, 0x2d, 0x20, 0x83, 0x09, 0x73, 0xba, 0xce, 0x71, 0xa3, 0x5f, 0xf9, 0xfb, 0xf7, 0xa3, 0x3d,
	0x4e, 0x06, 0x13, 0xca, 0xa0, 0xf2, 0x2c, 0x9c, 0x0b, 0x46, 0x2c, 0x1c, 0x11, 0xe5, 0x7f, 0xb1,
	0x62, 0x6e, 0xd7, 0x39, 0xf6, 0x0a, 0xff, 0x8b, 0x15, 0xbd, 0x07, 0xee, 0xd3, 0x1f, 0x17, 0xac,
	0x62, 0xc1, 0x0a, 0x50, 0x79, 0xce, 0x45, 0x38, 0x61, 0x9e, 0x9d, 0x47, 0x21, 0xf4, 0x7d, 0xa8,
	0x9e, 0x9f, 0x49, 0x75, 0x46, 0xd5, 0x0a, 0x32, 0x98, 0xca, 0x77, 0x15, 0x2f, 0x58, 0xcd, 0xce,
	0x77, 0x15, 0x2f, 0x68, 0x1b, 0xbc, 0xe1, 0x4a, 0x0e, 0x26, 0xac, 0x6e, 0xed, 0x68, 0x48, 0x65,
	0x7c, 0x92, 0x4f, 0x2f, 0x6f, 0x24, 0x6b, 0xd8, 0x19, 0x35, 0xa6, 0x22, 0xbf, 0xc6, 0x2b, 0x81,
	0x45, 0x45, 0x43, 0xb4, 0x0b, 0xf5, 0xe1, 0x75, 0x7a, 0x73, 0x2e, 0x64, 0xca, 0x9a, 0x56, 0x6c,
	0x89, 0xfa, 0x1f, 0x82, 0x7b, 0x3a, 0x5e, 0xd3, 0x83, 0x52, 0x2c, 0x0f, 0x65, 0x3a, 0x04, 0xf7,
	0x2a, 0x9c, 0xa1, 0x4a, 0x2e, 0x57, 0x4b, 0xff, 0x18, 0x2a, 0x83, 0x5c, 0xcc, 0x77, 0x79, 0x3e,
	0x5b, 0xce, 0xd1, 0xd3, 0xe3, 0x6a, 0xe9, 0xff, 0x4a, 0x94, 0x36, 0x32, 0x55, 0x5b, 0x43, 0xf1,
	0x03, 0xfa, 0xba, 0x5c, 0x2d, 0x4d, 0x30, 0x29, 0x83, 0x0f, 0x36, 0x9a, 0xa3, 0xda, 0x14, 0x2a,
	0xc3, 0x3c, 0x94, 0x5a, 0x6e, 0x8e, 0x6b, 0xfa, 0x01, 0xd4, 0x46, 0x32, 0x4e, 0xa6, 0x22, 0x47,
	0xb1, 0x9b, 0xbd, 0xfd, 0x60, 0x9e, 0x45, 0x81, 0xc1, 0x78, 0xb1, 0x49, 0x3f, 0x02, 0xef, 0x52,
	0xa6, 0x8b, 0x8c, 0x55, 0xbb, 0xee, 0x71, 0xb3, 0xd7, 0x42, 0x2f, 0xc5, 0x23, 0x40, 0xf8, 0x69,
	0x92, 0xcb, 0x35, 0xd7, 0x2e, 0xf4, 0x1e, 0x54, 0x2f, 0xd2, 0xf1, 0x54, 0x4c, 0xb0, 0x10, 0x75,
	0x6e, 0x2c, 0x85, 0x1b, 0xa5, 0xb1, 0x0c, 0x96, 0xc6, 0xf5, 0xd3, 0xeb, 0x30, 0x89, 0xc4, 0x60,
	0xa2, 0x6b, 0xc0, 0x4b, 0x1b, 0x39, 0x4f, 0xe3, 0x04, 0xe5, 0x57, 0x9c, 0xa7, 0x71, 0xd2, 0x7e,
	0x0c, 0xb0, 0x39, 0x54, 0xe9, 0x30, 0x15, 0x6b, 0xa3, 0x99, 0x5a, 0xd2, 0x16, 0x78, 0xab, 0x70,
	0xb6, 0xd4, 0xcf, 0x90, 0x70, 0x6d, 0x7c, 0x4e, 0x1e, 0x3b, 0xfe, 0xcf, 0x0e, 0x80, 0x22, 0xfd,
	0x95, 0xc8, 0xc3, 0x78, 0x46, 0xef, 0x6b, 0x29, 0x31, 0xb6, 0xd9, 0x6b, 0x94, 0x77, 0xe2, 0x5a,
	0x61, 0xc5, 0x57, 0xce, 0x53, 0x99, 0x31, 0xd2, 0x75, 0x91, 0x2f, 0x5a, 0xf4, 0x04, 0x3c, 0x2e,
	0x66, 0xf1, 0x98, 0xb9, 0xa8, 0x45, 0xbb, 0x8c, 0xd3, 0x69, 0x03, 0xdc, 0x34, 0x8a, 0xe0, 0x5a,
	0x31, 0xde, 0x80, 0x6f, 0x63, 0xec, 0xd9, 0x8c, 0x1f, 0x96, 0xf5, 0x31, 0xe5, 0x74, 0xca, 0x72,
	0xb6, 0x8a, 0x92, 0x68, 0x76, 0xda, 0xf0, 0x4f, 0xc1, 0x43, 0x9a, 0xef, 0xf0, 0x3e, 0x18, 0xd4,
	0x14, 0x6b, 0xe5, 0xe5, 0xa2, 0x57, 0x61, 0xfa, 0x91, 0xb9, 0xe1, 0x3b, 0x24, 0x29, 0x1e, 0x95,
	0x6b, 0x3d, 0xaa, 0x03, 0x20, 0xcf, 0x4d, 0x57, 0x73, 0xf2, 0x7c, 0x61, 0x1f, 0xe4, 0x6d, 0x1f,
	0xb4, 0x82, 0x1a, 0x17, 0x37, 0xa1, 0x9c, 0x64, 0xb4, 0x8d, 0xbd, 0xc2, 0x1c, 0xd4, 0xb4, 0x8e,
	0x9a, 0x9e, 0x8e, 0xd7, 0x1c, 0x1b, 0xe8, 0x08, 0x3c, 0xd5, 0x1e, 0xfa, 0xaa, 0x45, 0xa5, 0x14,
	0xc2, 0x35, 0xae, 0x4a, 0xa5, 0x52, 0x8a, 0x0c, 0x6b, 0xe2, 0x72, 0x63, 0x29, 0x1c, 0x2f, 0x92,
	0xb1, 0x8a, 0xc6, 0xb5, 0xe5, 0xff, 0xe4, 0xc0, 0x9d, 0x91, 0x08, 0xe7, 0x67, 0xa9, 0x9c, 0x87,
	0x79, 0x9c, 0x26, 0xf4, 0x4b, 0x68, 0x94, 0x86, 0x21, 0xf1, 0x40, 0xb7, 0x82, 0xed, 0x16, 0x94,
	0x2b, 0x5d, 0xdf, 0x4d, 0x4c, 0xfb, 0x0b, 0x38, 0xd8, 0xde, 0xb4, 0xeb, 0xec, 0xbe, 0xad, 0xce,
	0xbf, 0x10, 0xb8, 0xd3, 0x0f, 0xf3, 0x7c, 0x26, 0xce, 0xe2, 0xe8, 0x3a, 0x17, 0x52, 0xcd, 0xb2,
	0x52, 0xfa, 0x62, 0x96, 0xa9, 0x02, 0xb4, 0x36, 0x05, 0xb0, 0x26, 0xef, 0xee, 0xf9, 0xca, 0xec,
	0x8e, 0x2f, 0xe6, 0x28, 0x96, 0xe8, 0xb3, 0xe2, 0xf1, 0x78, 0x78, 0xd5, 0xfb, 0x78, 0xd5, 0x2d,
	0x02, 0x56, 0x63, 0x17, 0x63, 0xaf, 0x68, 0x6f, 0xf7, 0x32, 0xcd, 0xb6, 0xe6, 0xaf, 0x02, 0xac,
	0x41, 0x5a, 0xdb, 0x31, 0x48, 0x99, 0x69, 0xe4, 0xfa, 0x16, 0x95, 0x7f, 0xd7, 0xce, 0x53, 0x00,
	0x4d, 0x59, 0xd5, 0x88, 0x7e, 0x0c, 0x55, 0xfd, 0x99, 0x32, 0xfd, 0x7c, 0x17, 0xef, 0xf4, 0xfa,
	0x97, 0x8b, 0x1b, 0x27, 0x1a, 0x40, 0xdd, 0xdc, 0xb4, 0x78, 0x56, 0xf4, 0x4d, 0x11, 0x78, 0xe9,
	0xe3, 0xbf, 0x74, 0xa0, 0xa9, 0xf7, 0x06, 0xc9, 0x62, 0x99, 0xd3, 0x23, 0x20, 0xa3, 0x47, 0xe6,
	0xa8, 0xff, 0x59, 0x91, 0x8a, 0x0b, 0x27, 0xa3, 0x47, 0xe8, 0xd0, 0x43, 0xd2, 0x3b, 0x1d, 0x7a,
	0x34, 0x80, 0xca, 0x13, 0x19, 0x65, 0x5b, 0x63, 0xc4, 0x3a, 0x21, 0x50, 0x9b, 0xfa, 0x99, 0xa1,
	0x5f, 0xfb, 0x53, 0x68, 0x94, 0x90, 0xad, 0x53, 0x63, 0x87, 0x4e, 0x0d, 0x5b, 0xa7, 0x17, 0x0e,
	0xec, 0xeb, 0xc4, 0x5c, 0x64, 0xcb, 0x59, 0xae, 0xda, 0xe2, 0x9b, 0x38, 0x49, 0x8c, 0x54, 0x1e,
	0x37, 0x16, 0x7d, 0x68, 0x18, 0x69, 0x3d, 0xde, 0xb3, 0x18, 0xe9, 0xc0, 0xff, 0x8e, 0x52, 0xb6,
	0x61, 0xb4, 0x98, 0x85, 0xf6, 0x27, 0xb2, 0x51, 0x7c, 0xbb, 0x46, 0x99, 0xf9, 0x42, 0x92, 0x51,
	0x46, 0xbb, 0x40, 0xfa, 0x31, 0xbe, 0xef, 0x66, 0xef, 0xf0, 0x75, 0xa5, 0x38, 0xe9, 0xc7, 0xf4,
	0x01, 0x90, 0xbe, 0x7e, 0xe9, 0xcd, 0xde, 0xff, 0xdf, 0x60, 0xce, 0x49, 0x5f, 0xfa, 0xfb, 0x00,
	0x67, 0xa9, 0xbc, 0x48, 0xc3, 0x49, 0x9c, 0x44, 0xfd, 0xd6, 0xab, 0x3f, 0x3b, 0x7b, 0xaf, 0x6e,
	0x3b, 0xce, 0x6f, 0xb7, 0x1d, 0xe7, 0x8f, 0xdb, 0x8e, 0xf3, 0xe2, 0xaf, 0xce, 0xde, 0x77, 0x55,
	0xfc, 0xe9, 0xf9, 0xe4, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x4d, 0x01, 0x8a, 0xb8, 0x1e, 0x09,
	0x00, 0x00,
}
