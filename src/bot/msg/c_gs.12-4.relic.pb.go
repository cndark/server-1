// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: c_gs.12-4.relic.proto

package msg

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// 神器更新
type GS_RelicUpdate_HeroSeq struct {
	Seq     int64 `protobuf:"varint,1,opt,name=Seq,proto3" json:"Seq,omitempty"`
	HeroSeq int64 `protobuf:"varint,2,opt,name=HeroSeq,proto3" json:"HeroSeq,omitempty"`
}

func (m *GS_RelicUpdate_HeroSeq) Reset()         { *m = GS_RelicUpdate_HeroSeq{} }
func (m *GS_RelicUpdate_HeroSeq) String() string { return proto.CompactTextString(m) }
func (*GS_RelicUpdate_HeroSeq) ProtoMessage()    {}
func (*GS_RelicUpdate_HeroSeq) Descriptor() ([]byte, []int) {
	return fileDescriptorCGs_12_4Relic, []int{0}
}

type GS_RelicUpdate_Star struct {
	Seq  int64 `protobuf:"varint,1,opt,name=Seq,proto3" json:"Seq,omitempty"`
	Star int32 `protobuf:"varint,2,opt,name=Star,proto3" json:"Star,omitempty"`
	Xp   int32 `protobuf:"varint,3,opt,name=Xp,proto3" json:"Xp,omitempty"`
}

func (m *GS_RelicUpdate_Star) Reset()                    { *m = GS_RelicUpdate_Star{} }
func (m *GS_RelicUpdate_Star) String() string            { return proto.CompactTextString(m) }
func (*GS_RelicUpdate_Star) ProtoMessage()               {}
func (*GS_RelicUpdate_Star) Descriptor() ([]byte, []int) { return fileDescriptorCGs_12_4Relic, []int{1} }

// 穿
type C_RelicEquip struct {
	HeroSeq int64 `protobuf:"varint,1,opt,name=HeroSeq,proto3" json:"HeroSeq,omitempty"`
	Seq     int64 `protobuf:"varint,2,opt,name=Seq,proto3" json:"Seq,omitempty"`
}

func (m *C_RelicEquip) Reset()                    { *m = C_RelicEquip{} }
func (m *C_RelicEquip) String() string            { return proto.CompactTextString(m) }
func (*C_RelicEquip) ProtoMessage()               {}
func (*C_RelicEquip) Descriptor() ([]byte, []int) { return fileDescriptorCGs_12_4Relic, []int{2} }

type GS_RelicEquip_R struct {
	ErrorCode int32 `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
}

func (m *GS_RelicEquip_R) Reset()                    { *m = GS_RelicEquip_R{} }
func (m *GS_RelicEquip_R) String() string            { return proto.CompactTextString(m) }
func (*GS_RelicEquip_R) ProtoMessage()               {}
func (*GS_RelicEquip_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_12_4Relic, []int{3} }

// 卸
type C_RelicUnequip struct {
	HeroSeq int64 `protobuf:"varint,1,opt,name=HeroSeq,proto3" json:"HeroSeq,omitempty"`
}

func (m *C_RelicUnequip) Reset()                    { *m = C_RelicUnequip{} }
func (m *C_RelicUnequip) String() string            { return proto.CompactTextString(m) }
func (*C_RelicUnequip) ProtoMessage()               {}
func (*C_RelicUnequip) Descriptor() ([]byte, []int) { return fileDescriptorCGs_12_4Relic, []int{4} }

type GS_RelicUnequip_R struct {
	ErrorCode int32 `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
}

func (m *GS_RelicUnequip_R) Reset()                    { *m = GS_RelicUnequip_R{} }
func (m *GS_RelicUnequip_R) String() string            { return proto.CompactTextString(m) }
func (*GS_RelicUnequip_R) ProtoMessage()               {}
func (*GS_RelicUnequip_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_12_4Relic, []int{5} }

// 神器吃
type C_RelicEat struct {
	Seq     int64   `protobuf:"varint,1,opt,name=Seq,proto3" json:"Seq,omitempty"`
	EatSeqs []int64 `protobuf:"varint,2,rep,packed,name=EatSeqs" json:"EatSeqs,omitempty"`
}

func (m *C_RelicEat) Reset()                    { *m = C_RelicEat{} }
func (m *C_RelicEat) String() string            { return proto.CompactTextString(m) }
func (*C_RelicEat) ProtoMessage()               {}
func (*C_RelicEat) Descriptor() ([]byte, []int) { return fileDescriptorCGs_12_4Relic, []int{6} }

type GS_RelicEat_R struct {
	ErrorCode int32 `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
}

func (m *GS_RelicEat_R) Reset()                    { *m = GS_RelicEat_R{} }
func (m *GS_RelicEat_R) String() string            { return proto.CompactTextString(m) }
func (*GS_RelicEat_R) ProtoMessage()               {}
func (*GS_RelicEat_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_12_4Relic, []int{7} }

func init() {
	proto.RegisterType((*GS_RelicUpdate_HeroSeq)(nil), "msg.GS_RelicUpdate_HeroSeq")
	proto.RegisterType((*GS_RelicUpdate_Star)(nil), "msg.GS_RelicUpdate_Star")
	proto.RegisterType((*C_RelicEquip)(nil), "msg.C_RelicEquip")
	proto.RegisterType((*GS_RelicEquip_R)(nil), "msg.GS_RelicEquip_R")
	proto.RegisterType((*C_RelicUnequip)(nil), "msg.C_RelicUnequip")
	proto.RegisterType((*GS_RelicUnequip_R)(nil), "msg.GS_RelicUnequip_R")
	proto.RegisterType((*C_RelicEat)(nil), "msg.C_RelicEat")
	proto.RegisterType((*GS_RelicEat_R)(nil), "msg.GS_RelicEat_R")
}
func (m *GS_RelicUpdate_HeroSeq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_RelicUpdate_HeroSeq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seq != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_12_4Relic(dAtA, i, uint64(m.Seq))
	}
	if m.HeroSeq != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_12_4Relic(dAtA, i, uint64(m.HeroSeq))
	}
	return i, nil
}

func (m *GS_RelicUpdate_Star) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_RelicUpdate_Star) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seq != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_12_4Relic(dAtA, i, uint64(m.Seq))
	}
	if m.Star != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_12_4Relic(dAtA, i, uint64(m.Star))
	}
	if m.Xp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCGs_12_4Relic(dAtA, i, uint64(m.Xp))
	}
	return i, nil
}

func (m *C_RelicEquip) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_RelicEquip) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HeroSeq != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_12_4Relic(dAtA, i, uint64(m.HeroSeq))
	}
	if m.Seq != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_12_4Relic(dAtA, i, uint64(m.Seq))
	}
	return i, nil
}

func (m *GS_RelicEquip_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_RelicEquip_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_12_4Relic(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *C_RelicUnequip) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_RelicUnequip) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HeroSeq != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_12_4Relic(dAtA, i, uint64(m.HeroSeq))
	}
	return i, nil
}

func (m *GS_RelicUnequip_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_RelicUnequip_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_12_4Relic(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *C_RelicEat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_RelicEat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seq != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_12_4Relic(dAtA, i, uint64(m.Seq))
	}
	if len(m.EatSeqs) > 0 {
		dAtA2 := make([]byte, len(m.EatSeqs)*10)
		var j1 int
		for _, num1 := range m.EatSeqs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_12_4Relic(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *GS_RelicEat_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_RelicEat_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_12_4Relic(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func encodeVarintCGs_12_4Relic(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GS_RelicUpdate_HeroSeq) Size() (n int) {
	var l int
	_ = l
	if m.Seq != 0 {
		n += 1 + sovCGs_12_4Relic(uint64(m.Seq))
	}
	if m.HeroSeq != 0 {
		n += 1 + sovCGs_12_4Relic(uint64(m.HeroSeq))
	}
	return n
}

func (m *GS_RelicUpdate_Star) Size() (n int) {
	var l int
	_ = l
	if m.Seq != 0 {
		n += 1 + sovCGs_12_4Relic(uint64(m.Seq))
	}
	if m.Star != 0 {
		n += 1 + sovCGs_12_4Relic(uint64(m.Star))
	}
	if m.Xp != 0 {
		n += 1 + sovCGs_12_4Relic(uint64(m.Xp))
	}
	return n
}

func (m *C_RelicEquip) Size() (n int) {
	var l int
	_ = l
	if m.HeroSeq != 0 {
		n += 1 + sovCGs_12_4Relic(uint64(m.HeroSeq))
	}
	if m.Seq != 0 {
		n += 1 + sovCGs_12_4Relic(uint64(m.Seq))
	}
	return n
}

func (m *GS_RelicEquip_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_12_4Relic(uint64(m.ErrorCode))
	}
	return n
}

func (m *C_RelicUnequip) Size() (n int) {
	var l int
	_ = l
	if m.HeroSeq != 0 {
		n += 1 + sovCGs_12_4Relic(uint64(m.HeroSeq))
	}
	return n
}

func (m *GS_RelicUnequip_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_12_4Relic(uint64(m.ErrorCode))
	}
	return n
}

func (m *C_RelicEat) Size() (n int) {
	var l int
	_ = l
	if m.Seq != 0 {
		n += 1 + sovCGs_12_4Relic(uint64(m.Seq))
	}
	if len(m.EatSeqs) > 0 {
		l = 0
		for _, e := range m.EatSeqs {
			l += sovCGs_12_4Relic(uint64(e))
		}
		n += 1 + sovCGs_12_4Relic(uint64(l)) + l
	}
	return n
}

func (m *GS_RelicEat_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_12_4Relic(uint64(m.ErrorCode))
	}
	return n
}

func sovCGs_12_4Relic(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCGs_12_4Relic(x uint64) (n int) {
	return sovCGs_12_4Relic(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GS_RelicUpdate_HeroSeq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_12_4Relic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_RelicUpdate_HeroSeq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_RelicUpdate_HeroSeq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_12_4Relic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroSeq", wireType)
			}
			m.HeroSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_12_4Relic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroSeq |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_12_4Relic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_12_4Relic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_RelicUpdate_Star) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_12_4Relic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_RelicUpdate_Star: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_RelicUpdate_Star: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_12_4Relic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			m.Star = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_12_4Relic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Star |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Xp", wireType)
			}
			m.Xp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_12_4Relic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Xp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_12_4Relic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_12_4Relic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_RelicEquip) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_12_4Relic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_RelicEquip: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_RelicEquip: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroSeq", wireType)
			}
			m.HeroSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_12_4Relic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroSeq |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_12_4Relic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_12_4Relic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_12_4Relic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_RelicEquip_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_12_4Relic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_RelicEquip_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_RelicEquip_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_12_4Relic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_12_4Relic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_12_4Relic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_RelicUnequip) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_12_4Relic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_RelicUnequip: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_RelicUnequip: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroSeq", wireType)
			}
			m.HeroSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_12_4Relic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroSeq |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_12_4Relic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_12_4Relic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_RelicUnequip_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_12_4Relic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_RelicUnequip_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_RelicUnequip_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_12_4Relic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_12_4Relic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_12_4Relic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_RelicEat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_12_4Relic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_RelicEat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_RelicEat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_12_4Relic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_12_4Relic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EatSeqs = append(m.EatSeqs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_12_4Relic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCGs_12_4Relic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_12_4Relic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EatSeqs = append(m.EatSeqs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EatSeqs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_12_4Relic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_12_4Relic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_RelicEat_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_12_4Relic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_RelicEat_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_RelicEat_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_12_4Relic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_12_4Relic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_12_4Relic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCGs_12_4Relic(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCGs_12_4Relic
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCGs_12_4Relic
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCGs_12_4Relic
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCGs_12_4Relic
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCGs_12_4Relic
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCGs_12_4Relic(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCGs_12_4Relic = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCGs_12_4Relic   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("c_gs.12-4.relic.proto", fileDescriptorCGs_12_4Relic) }

var fileDescriptorCGs_12_4Relic = []byte{
	// 286 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x4d, 0x8e, 0x4f, 0x2f,
	0xd6, 0x33, 0x34, 0xd2, 0x35, 0xd1, 0x2b, 0x4a, 0xcd, 0xc9, 0x4c, 0xd6, 0x2b, 0x28, 0xca, 0x2f,
	0xc9, 0x17, 0x62, 0xce, 0x2d, 0x4e, 0x97, 0xe2, 0x4a, 0xcf, 0x4f, 0xcf, 0x87, 0x08, 0x28, 0xb9,
	0x70, 0x89, 0xb9, 0x07, 0xc7, 0x07, 0x81, 0x94, 0x84, 0x16, 0xa4, 0x24, 0x96, 0xa4, 0xc6, 0x7b,
	0xa4, 0x16, 0xe5, 0x07, 0xa7, 0x16, 0x0a, 0x09, 0x70, 0x31, 0x07, 0xa7, 0x16, 0x4a, 0x30, 0x2a,
	0x30, 0x6a, 0x30, 0x07, 0x81, 0x98, 0x42, 0x12, 0x5c, 0xec, 0x50, 0x49, 0x09, 0x26, 0xb0, 0x28,
	0x8c, 0xab, 0xe4, 0xcd, 0x25, 0x8c, 0x66, 0x4a, 0x70, 0x49, 0x62, 0x11, 0x16, 0x23, 0x84, 0xb8,
	0x58, 0x40, 0x32, 0x60, 0xfd, 0xac, 0x41, 0x60, 0xb6, 0x10, 0x1f, 0x17, 0x53, 0x44, 0x81, 0x04,
	0x33, 0x58, 0x84, 0x29, 0xa2, 0x40, 0xc9, 0x8a, 0x8b, 0xc7, 0x19, 0x62, 0x96, 0x6b, 0x61, 0x69,
	0x66, 0x01, 0xb2, 0xb5, 0x8c, 0x28, 0xd6, 0xc2, 0xcc, 0x67, 0x82, 0x9b, 0xaf, 0xa4, 0xcf, 0xc5,
	0x0f, 0x73, 0x08, 0x58, 0x73, 0x7c, 0x90, 0x90, 0x0c, 0x17, 0xa7, 0x6b, 0x51, 0x51, 0x7e, 0x91,
	0x73, 0x7e, 0x4a, 0x2a, 0xd8, 0x00, 0xd6, 0x20, 0x84, 0x80, 0x92, 0x16, 0x17, 0x1f, 0xd4, 0xb2,
	0xd0, 0xbc, 0x54, 0xfc, 0xd6, 0x29, 0x19, 0x72, 0x09, 0xc2, 0x7d, 0x09, 0x51, 0x4c, 0xd0, 0x78,
	0x0b, 0x2e, 0x2e, 0x98, 0x5f, 0x12, 0x4b, 0xb0, 0x07, 0xa9, 0x6b, 0x62, 0x49, 0x70, 0x6a, 0x61,
	0xb1, 0x04, 0x93, 0x02, 0x33, 0xc8, 0x32, 0x28, 0x57, 0x49, 0x97, 0x8b, 0x17, 0xee, 0x93, 0xc4,
	0x12, 0x42, 0x16, 0x39, 0x89, 0x9c, 0x78, 0x28, 0xc7, 0x70, 0xe2, 0x91, 0x1c, 0xe3, 0x85, 0x47,
	0x72, 0x8c, 0x0f, 0x1e, 0xc9, 0x31, 0x4e, 0x78, 0x2c, 0xc7, 0x90, 0xc4, 0x06, 0x8e, 0x64, 0x63,
	0x40, 0x00, 0x00, 0x00, 0xff, 0xff, 0x2c, 0x8c, 0xd4, 0xb8, 0x0e, 0x02, 0x00, 0x00,
}
