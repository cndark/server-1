// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: c_gs.40.act.proto

package msg

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// 统计值到达
type ActAttainObj struct {
	OId int32   `protobuf:"varint,1,opt,name=OId,proto3" json:"OId,omitempty"`
	Val float64 `protobuf:"fixed64,2,opt,name=Val,proto3" json:"Val,omitempty"`
}

func (m *ActAttainObj) Reset()                    { *m = ActAttainObj{} }
func (m *ActAttainObj) String() string            { return proto.CompactTextString(m) }
func (*ActAttainObj) ProtoMessage()               {}
func (*ActAttainObj) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{0} }

type ActRushLocalRankData struct {
	ActName     string  `protobuf:"bytes,1,opt,name=ActName,proto3" json:"ActName,omitempty"`
	RankId      int32   `protobuf:"varint,2,opt,name=RankId,proto3" json:"RankId,omitempty"`
	Take        bool    `protobuf:"varint,3,opt,name=Take,proto3" json:"Take,omitempty"`
	SelfScore   float64 `protobuf:"fixed64,4,opt,name=SelfScore,proto3" json:"SelfScore,omitempty"`
	CachedScore float64 `protobuf:"fixed64,5,opt,name=CachedScore,proto3" json:"CachedScore,omitempty"`
}

func (m *ActRushLocalRankData) Reset()                    { *m = ActRushLocalRankData{} }
func (m *ActRushLocalRankData) String() string            { return proto.CompactTextString(m) }
func (*ActRushLocalRankData) ProtoMessage()               {}
func (*ActRushLocalRankData) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{1} }

type C_ActRushLocalGetInfo struct {
	ActName string `protobuf:"bytes,1,opt,name=ActName,proto3" json:"ActName,omitempty"`
	RankId  int32  `protobuf:"varint,2,opt,name=RankId,proto3" json:"RankId,omitempty"`
}

func (m *C_ActRushLocalGetInfo) Reset()                    { *m = C_ActRushLocalGetInfo{} }
func (m *C_ActRushLocalGetInfo) String() string            { return proto.CompactTextString(m) }
func (*C_ActRushLocalGetInfo) ProtoMessage()               {}
func (*C_ActRushLocalGetInfo) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{2} }

type GS_ActRushLocalGetInfo_R struct {
	ErrorCode int32                   `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Data      []*ActRushLocalRankData `protobuf:"bytes,2,rep,name=Data" json:"Data,omitempty"`
}

func (m *GS_ActRushLocalGetInfo_R) Reset()         { *m = GS_ActRushLocalGetInfo_R{} }
func (m *GS_ActRushLocalGetInfo_R) String() string { return proto.CompactTextString(m) }
func (*GS_ActRushLocalGetInfo_R) ProtoMessage()    {}
func (*GS_ActRushLocalGetInfo_R) Descriptor() ([]byte, []int) {
	return fileDescriptorCGs_40Act, []int{3}
}

type C_ActRushLocalTake struct {
	ActName string `protobuf:"bytes,1,opt,name=ActName,proto3" json:"ActName,omitempty"`
	RankId  int32  `protobuf:"varint,2,opt,name=RankId,proto3" json:"RankId,omitempty"`
}

func (m *C_ActRushLocalTake) Reset()                    { *m = C_ActRushLocalTake{} }
func (m *C_ActRushLocalTake) String() string            { return proto.CompactTextString(m) }
func (*C_ActRushLocalTake) ProtoMessage()               {}
func (*C_ActRushLocalTake) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{4} }

type GS_ActRushLocalTake_R struct {
	ErrorCode int32    `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	ActName   string   `protobuf:"bytes,2,opt,name=ActName,proto3" json:"ActName,omitempty"`
	RankId    int32    `protobuf:"varint,3,opt,name=RankId,proto3" json:"RankId,omitempty"`
	Rewards   *Rewards `protobuf:"bytes,4,opt,name=Rewards" json:"Rewards,omitempty"`
}

func (m *GS_ActRushLocalTake_R) Reset()                    { *m = GS_ActRushLocalTake_R{} }
func (m *GS_ActRushLocalTake_R) String() string            { return proto.CompactTextString(m) }
func (*GS_ActRushLocalTake_R) ProtoMessage()               {}
func (*GS_ActRushLocalTake_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{5} }

type ActBillLtTotalData struct {
	Total int64   `protobuf:"varint,1,opt,name=Total,proto3" json:"Total,omitempty"`
	Taken []int32 `protobuf:"varint,2,rep,packed,name=Taken" json:"Taken,omitempty"`
}

func (m *ActBillLtTotalData) Reset()                    { *m = ActBillLtTotalData{} }
func (m *ActBillLtTotalData) String() string            { return proto.CompactTextString(m) }
func (*ActBillLtTotalData) ProtoMessage()               {}
func (*ActBillLtTotalData) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{6} }

type GS_ActBillLtTotal struct {
	Total int64 `protobuf:"varint,1,opt,name=Total,proto3" json:"Total,omitempty"`
}

func (m *GS_ActBillLtTotal) Reset()                    { *m = GS_ActBillLtTotal{} }
func (m *GS_ActBillLtTotal) String() string            { return proto.CompactTextString(m) }
func (*GS_ActBillLtTotal) ProtoMessage()               {}
func (*GS_ActBillLtTotal) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{7} }

type C_ActBillLtTotalInfo struct {
}

func (m *C_ActBillLtTotalInfo) Reset()                    { *m = C_ActBillLtTotalInfo{} }
func (m *C_ActBillLtTotalInfo) String() string            { return proto.CompactTextString(m) }
func (*C_ActBillLtTotalInfo) ProtoMessage()               {}
func (*C_ActBillLtTotalInfo) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{8} }

type GS_ActBillLtTotalInfo_R struct {
	ErrorCode int32               `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Data      *ActBillLtTotalData `protobuf:"bytes,2,opt,name=Data" json:"Data,omitempty"`
}

func (m *GS_ActBillLtTotalInfo_R) Reset()                    { *m = GS_ActBillLtTotalInfo_R{} }
func (m *GS_ActBillLtTotalInfo_R) String() string            { return proto.CompactTextString(m) }
func (*GS_ActBillLtTotalInfo_R) ProtoMessage()               {}
func (*GS_ActBillLtTotalInfo_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{9} }

type C_ActBillLtTotalTake struct {
	Id int32 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
}

func (m *C_ActBillLtTotalTake) Reset()                    { *m = C_ActBillLtTotalTake{} }
func (m *C_ActBillLtTotalTake) String() string            { return proto.CompactTextString(m) }
func (*C_ActBillLtTotalTake) ProtoMessage()               {}
func (*C_ActBillLtTotalTake) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{10} }

type GS_ActBillLtTotalTake_R struct {
	ErrorCode int32    `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Id        int32    `protobuf:"varint,2,opt,name=Id,proto3" json:"Id,omitempty"`
	Rewards   *Rewards `protobuf:"bytes,3,opt,name=Rewards" json:"Rewards,omitempty"`
}

func (m *GS_ActBillLtTotalTake_R) Reset()         { *m = GS_ActBillLtTotalTake_R{} }
func (m *GS_ActBillLtTotalTake_R) String() string { return proto.CompactTextString(m) }
func (*GS_ActBillLtTotalTake_R) ProtoMessage()    {}
func (*GS_ActBillLtTotalTake_R) Descriptor() ([]byte, []int) {
	return fileDescriptorCGs_40Act, []int{11}
}

type ActBillLtDayData struct {
	Taken   []int32 `protobuf:"varint,1,rep,packed,name=Taken" json:"Taken,omitempty"`
	BillDay int32   `protobuf:"varint,2,opt,name=BillDay,proto3" json:"BillDay,omitempty"`
}

func (m *ActBillLtDayData) Reset()                    { *m = ActBillLtDayData{} }
func (m *ActBillLtDayData) String() string            { return proto.CompactTextString(m) }
func (*ActBillLtDayData) ProtoMessage()               {}
func (*ActBillLtDayData) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{12} }

type C_ActBillLtDayInfo struct {
}

func (m *C_ActBillLtDayInfo) Reset()                    { *m = C_ActBillLtDayInfo{} }
func (m *C_ActBillLtDayInfo) String() string            { return proto.CompactTextString(m) }
func (*C_ActBillLtDayInfo) ProtoMessage()               {}
func (*C_ActBillLtDayInfo) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{13} }

type GS_ActBillLtDayInfo_R struct {
	ErrorCode int32             `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Data      *ActBillLtDayData `protobuf:"bytes,2,opt,name=Data" json:"Data,omitempty"`
}

func (m *GS_ActBillLtDayInfo_R) Reset()                    { *m = GS_ActBillLtDayInfo_R{} }
func (m *GS_ActBillLtDayInfo_R) String() string            { return proto.CompactTextString(m) }
func (*GS_ActBillLtDayInfo_R) ProtoMessage()               {}
func (*GS_ActBillLtDayInfo_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{14} }

type C_ActBillLtDayTake struct {
	Id int32 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
}

func (m *C_ActBillLtDayTake) Reset()                    { *m = C_ActBillLtDayTake{} }
func (m *C_ActBillLtDayTake) String() string            { return proto.CompactTextString(m) }
func (*C_ActBillLtDayTake) ProtoMessage()               {}
func (*C_ActBillLtDayTake) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{15} }

type GS_ActBillLtDayTake_R struct {
	ErrorCode int32    `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Rewards   *Rewards `protobuf:"bytes,2,opt,name=Rewards" json:"Rewards,omitempty"`
}

func (m *GS_ActBillLtDayTake_R) Reset()                    { *m = GS_ActBillLtDayTake_R{} }
func (m *GS_ActBillLtDayTake_R) String() string            { return proto.CompactTextString(m) }
func (*GS_ActBillLtDayTake_R) ProtoMessage()               {}
func (*GS_ActBillLtDayTake_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{16} }

type GS_ActGiftNew struct {
	Id      int32    `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	Rewards *Rewards `protobuf:"bytes,2,opt,name=Rewards" json:"Rewards,omitempty"`
}

func (m *GS_ActGiftNew) Reset()                    { *m = GS_ActGiftNew{} }
func (m *GS_ActGiftNew) String() string            { return proto.CompactTextString(m) }
func (*GS_ActGiftNew) ProtoMessage()               {}
func (*GS_ActGiftNew) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{17} }

type ActSummonData struct {
	NormalCnt int32           `protobuf:"varint,1,opt,name=NormalCnt,proto3" json:"NormalCnt,omitempty"`
	DesireCnt int32           `protobuf:"varint,2,opt,name=DesireCnt,proto3" json:"DesireCnt,omitempty"`
	DiamCnt   int32           `protobuf:"varint,3,opt,name=DiamCnt,proto3" json:"DiamCnt,omitempty"`
	UpCnt     int32           `protobuf:"varint,4,opt,name=UpCnt,proto3" json:"UpCnt,omitempty"`
	LastTs    int64           `protobuf:"varint,5,opt,name=LastTs,proto3" json:"LastTs,omitempty"`
	HeroPos   map[int32]int32 `protobuf:"bytes,6,rep,name=HeroPos" json:"HeroPos,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	ActGift   map[int32]int32 `protobuf:"bytes,7,rep,name=ActGift" json:"ActGift,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *ActSummonData) Reset()                    { *m = ActSummonData{} }
func (m *ActSummonData) String() string            { return proto.CompactTextString(m) }
func (*ActSummonData) ProtoMessage()               {}
func (*ActSummonData) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{18} }

type C_ActSummonInfo struct {
}

func (m *C_ActSummonInfo) Reset()                    { *m = C_ActSummonInfo{} }
func (m *C_ActSummonInfo) String() string            { return proto.CompactTextString(m) }
func (*C_ActSummonInfo) ProtoMessage()               {}
func (*C_ActSummonInfo) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{19} }

type GS_ActSummonInfo_R struct {
	ErrorCode int32          `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Data      *ActSummonData `protobuf:"bytes,2,opt,name=Data" json:"Data,omitempty"`
}

func (m *GS_ActSummonInfo_R) Reset()                    { *m = GS_ActSummonInfo_R{} }
func (m *GS_ActSummonInfo_R) String() string            { return proto.CompactTextString(m) }
func (*GS_ActSummonInfo_R) ProtoMessage()               {}
func (*GS_ActSummonInfo_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{20} }

// 选定Up或心愿英雄
type C_ActSummonPick struct {
	HeroPos map[int32]int32 `protobuf:"bytes,1,rep,name=HeroPos" json:"HeroPos,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *C_ActSummonPick) Reset()                    { *m = C_ActSummonPick{} }
func (m *C_ActSummonPick) String() string            { return proto.CompactTextString(m) }
func (*C_ActSummonPick) ProtoMessage()               {}
func (*C_ActSummonPick) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{21} }

type GS_ActSummonPick_R struct {
	ErrorCode int32 `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
}

func (m *GS_ActSummonPick_R) Reset()                    { *m = GS_ActSummonPick_R{} }
func (m *GS_ActSummonPick_R) String() string            { return proto.CompactTextString(m) }
func (*GS_ActSummonPick_R) ProtoMessage()               {}
func (*GS_ActSummonPick_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{22} }

// 召唤
type C_ActSummonDraw struct {
	IsDiam bool  `protobuf:"varint,1,opt,name=IsDiam,proto3" json:"IsDiam,omitempty"`
	N      int32 `protobuf:"varint,2,opt,name=N,proto3" json:"N,omitempty"`
}

func (m *C_ActSummonDraw) Reset()                    { *m = C_ActSummonDraw{} }
func (m *C_ActSummonDraw) String() string            { return proto.CompactTextString(m) }
func (*C_ActSummonDraw) ProtoMessage()               {}
func (*C_ActSummonDraw) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{23} }

type GS_ActSummonDraw_R struct {
	ErrorCode int32    `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	LastTs    int64    `protobuf:"varint,2,opt,name=LastTs,proto3" json:"LastTs,omitempty"`
	NormalCnt int32    `protobuf:"varint,3,opt,name=NormalCnt,proto3" json:"NormalCnt,omitempty"`
	DesireCnt int32    `protobuf:"varint,4,opt,name=DesireCnt,proto3" json:"DesireCnt,omitempty"`
	UpCnt     int32    `protobuf:"varint,5,opt,name=UpCnt,proto3" json:"UpCnt,omitempty"`
	DiamCnt   int32    `protobuf:"varint,6,opt,name=DiamCnt,proto3" json:"DiamCnt,omitempty"`
	Items     []*Item  `protobuf:"bytes,7,rep,name=Items" json:"Items,omitempty"`
	Rewards   *Rewards `protobuf:"bytes,8,opt,name=Rewards" json:"Rewards,omitempty"`
}

func (m *GS_ActSummonDraw_R) Reset()                    { *m = GS_ActSummonDraw_R{} }
func (m *GS_ActSummonDraw_R) String() string            { return proto.CompactTextString(m) }
func (*GS_ActSummonDraw_R) ProtoMessage()               {}
func (*GS_ActSummonDraw_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{24} }

type ActTargetTaskData struct {
	Attain  []*ActAttainObj `protobuf:"bytes,1,rep,name=Attain" json:"Attain,omitempty"`
	Taken   []int32         `protobuf:"varint,2,rep,packed,name=Taken" json:"Taken,omitempty"`
	ActGift map[int32]int32 `protobuf:"bytes,3,rep,name=ActGift" json:"ActGift,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *ActTargetTaskData) Reset()                    { *m = ActTargetTaskData{} }
func (m *ActTargetTaskData) String() string            { return proto.CompactTextString(m) }
func (*ActTargetTaskData) ProtoMessage()               {}
func (*ActTargetTaskData) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{25} }

// 通知: 进度变化
type GS_ActTargetTaskObjValueChanged struct {
	OId int32   `protobuf:"varint,1,opt,name=OId,proto3" json:"OId,omitempty"`
	Val float64 `protobuf:"fixed64,2,opt,name=Val,proto3" json:"Val,omitempty"`
}

func (m *GS_ActTargetTaskObjValueChanged) Reset()         { *m = GS_ActTargetTaskObjValueChanged{} }
func (m *GS_ActTargetTaskObjValueChanged) String() string { return proto.CompactTextString(m) }
func (*GS_ActTargetTaskObjValueChanged) ProtoMessage()    {}
func (*GS_ActTargetTaskObjValueChanged) Descriptor() ([]byte, []int) {
	return fileDescriptorCGs_40Act, []int{26}
}

type C_ActTargetTaskInfo struct {
}

func (m *C_ActTargetTaskInfo) Reset()                    { *m = C_ActTargetTaskInfo{} }
func (m *C_ActTargetTaskInfo) String() string            { return proto.CompactTextString(m) }
func (*C_ActTargetTaskInfo) ProtoMessage()               {}
func (*C_ActTargetTaskInfo) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{27} }

type GS_ActTargetTaskInfo_R struct {
	ErrorCode int32              `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Data      *ActTargetTaskData `protobuf:"bytes,2,opt,name=Data" json:"Data,omitempty"`
}

func (m *GS_ActTargetTaskInfo_R) Reset()                    { *m = GS_ActTargetTaskInfo_R{} }
func (m *GS_ActTargetTaskInfo_R) String() string            { return proto.CompactTextString(m) }
func (*GS_ActTargetTaskInfo_R) ProtoMessage()               {}
func (*GS_ActTargetTaskInfo_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{28} }

// 任务领奖
type C_ActTargetTaskTake struct {
	Id int32 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
}

func (m *C_ActTargetTaskTake) Reset()                    { *m = C_ActTargetTaskTake{} }
func (m *C_ActTargetTaskTake) String() string            { return proto.CompactTextString(m) }
func (*C_ActTargetTaskTake) ProtoMessage()               {}
func (*C_ActTargetTaskTake) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{29} }

type GS_ActTargetTaskTake_R struct {
	ErrorCode int32    `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Rewards   *Rewards `protobuf:"bytes,3,opt,name=Rewards" json:"Rewards,omitempty"`
}

func (m *GS_ActTargetTaskTake_R) Reset()                    { *m = GS_ActTargetTaskTake_R{} }
func (m *GS_ActTargetTaskTake_R) String() string            { return proto.CompactTextString(m) }
func (*GS_ActTargetTaskTake_R) ProtoMessage()               {}
func (*GS_ActTargetTaskTake_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{30} }

type ActHeroSkinData struct {
	ActGift map[int32]int32 `protobuf:"bytes,1,rep,name=ActGift" json:"ActGift,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *ActHeroSkinData) Reset()                    { *m = ActHeroSkinData{} }
func (m *ActHeroSkinData) String() string            { return proto.CompactTextString(m) }
func (*ActHeroSkinData) ProtoMessage()               {}
func (*ActHeroSkinData) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{31} }

type C_ActHeroSkinInfo struct {
}

func (m *C_ActHeroSkinInfo) Reset()                    { *m = C_ActHeroSkinInfo{} }
func (m *C_ActHeroSkinInfo) String() string            { return proto.CompactTextString(m) }
func (*C_ActHeroSkinInfo) ProtoMessage()               {}
func (*C_ActHeroSkinInfo) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{32} }

type GS_ActHeroSkinInfo_R struct {
	ErrorCode int32            `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Data      *ActHeroSkinData `protobuf:"bytes,2,opt,name=Data" json:"Data,omitempty"`
}

func (m *GS_ActHeroSkinInfo_R) Reset()                    { *m = GS_ActHeroSkinInfo_R{} }
func (m *GS_ActHeroSkinInfo_R) String() string            { return proto.CompactTextString(m) }
func (*GS_ActHeroSkinInfo_R) ProtoMessage()               {}
func (*GS_ActHeroSkinInfo_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{33} }

type ActMSummonData struct {
	NormalCnt int32           `protobuf:"varint,1,opt,name=NormalCnt,proto3" json:"NormalCnt,omitempty"`
	MagicCnt  int32           `protobuf:"varint,2,opt,name=MagicCnt,proto3" json:"MagicCnt,omitempty"`
	DiamCnt   int32           `protobuf:"varint,3,opt,name=DiamCnt,proto3" json:"DiamCnt,omitempty"`
	LastTs    int64           `protobuf:"varint,4,opt,name=LastTs,proto3" json:"LastTs,omitempty"`
	ActGift   map[int32]int32 `protobuf:"bytes,5,rep,name=ActGift" json:"ActGift,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *ActMSummonData) Reset()                    { *m = ActMSummonData{} }
func (m *ActMSummonData) String() string            { return proto.CompactTextString(m) }
func (*ActMSummonData) ProtoMessage()               {}
func (*ActMSummonData) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{34} }

type C_ActMSummonInfo struct {
}

func (m *C_ActMSummonInfo) Reset()                    { *m = C_ActMSummonInfo{} }
func (m *C_ActMSummonInfo) String() string            { return proto.CompactTextString(m) }
func (*C_ActMSummonInfo) ProtoMessage()               {}
func (*C_ActMSummonInfo) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{35} }

type GS_ActMSummonInfo_R struct {
	ErrorCode int32           `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Data      *ActMSummonData `protobuf:"bytes,2,opt,name=Data" json:"Data,omitempty"`
}

func (m *GS_ActMSummonInfo_R) Reset()                    { *m = GS_ActMSummonInfo_R{} }
func (m *GS_ActMSummonInfo_R) String() string            { return proto.CompactTextString(m) }
func (*GS_ActMSummonInfo_R) ProtoMessage()               {}
func (*GS_ActMSummonInfo_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{36} }

// 召唤
type C_ActMSummonDraw struct {
	IsDiam bool  `protobuf:"varint,1,opt,name=IsDiam,proto3" json:"IsDiam,omitempty"`
	N      int32 `protobuf:"varint,2,opt,name=N,proto3" json:"N,omitempty"`
}

func (m *C_ActMSummonDraw) Reset()                    { *m = C_ActMSummonDraw{} }
func (m *C_ActMSummonDraw) String() string            { return proto.CompactTextString(m) }
func (*C_ActMSummonDraw) ProtoMessage()               {}
func (*C_ActMSummonDraw) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{37} }

type GS_ActMSummonDraw_R struct {
	ErrorCode int32    `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	MagicCnt  int32    `protobuf:"varint,2,opt,name=MagicCnt,proto3" json:"MagicCnt,omitempty"`
	LastTs    int64    `protobuf:"varint,3,opt,name=LastTs,proto3" json:"LastTs,omitempty"`
	DiamCnt   int32    `protobuf:"varint,4,opt,name=DiamCnt,proto3" json:"DiamCnt,omitempty"`
	NormalCnt int32    `protobuf:"varint,5,opt,name=NormalCnt,proto3" json:"NormalCnt,omitempty"`
	Rewards   *Rewards `protobuf:"bytes,6,opt,name=Rewards" json:"Rewards,omitempty"`
}

func (m *GS_ActMSummonDraw_R) Reset()                    { *m = GS_ActMSummonDraw_R{} }
func (m *GS_ActMSummonDraw_R) String() string            { return proto.CompactTextString(m) }
func (*GS_ActMSummonDraw_R) ProtoMessage()               {}
func (*GS_ActMSummonDraw_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{38} }

// ============================================================================
// 大富翁
type ActMonopolyData struct {
	Seq        int32                 `protobuf:"varint,1,opt,name=Seq,proto3" json:"Seq,omitempty"`
	Pos        int32                 `protobuf:"varint,2,opt,name=Pos,proto3" json:"Pos,omitempty"`
	RepeatCnt  int32                 `protobuf:"varint,3,opt,name=RepeatCnt,proto3" json:"RepeatCnt,omitempty"`
	AdvPosInfo map[int32]int32       `protobuf:"bytes,4,rep,name=AdvPosInfo" json:"AdvPosInfo,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	TaskTaken  []int32               `protobuf:"varint,5,rep,packed,name=TaskTaken" json:"TaskTaken,omitempty"`
	NormalBat  []*ActMonopolyAdvItem `protobuf:"bytes,6,rep,name=NormalBat" json:"NormalBat,omitempty"`
	Problems   []*ActMonopolyAdvItem `protobuf:"bytes,7,rep,name=Problems" json:"Problems,omitempty"`
	Shops      []*ActMonolyShopItem  `protobuf:"bytes,8,rep,name=Shops" json:"Shops,omitempty"`
	HeroBat    []*ActMonopolyBatItem `protobuf:"bytes,9,rep,name=HeroBat" json:"HeroBat,omitempty"`
	Attain     []*ActAttainObj       `protobuf:"bytes,10,rep,name=Attain" json:"Attain,omitempty"`
}

func (m *ActMonopolyData) Reset()                    { *m = ActMonopolyData{} }
func (m *ActMonopolyData) String() string            { return proto.CompactTextString(m) }
func (*ActMonopolyData) ProtoMessage()               {}
func (*ActMonopolyData) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{39} }

type ActMonolyShopItem struct {
	Id         int32   `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	ExpireTs   int64   `protobuf:"varint,2,opt,name=ExpireTs,proto3" json:"ExpireTs,omitempty"`
	DisCnt     int32   `protobuf:"varint,3,opt,name=DisCnt,proto3" json:"DisCnt,omitempty"`
	AlreadyBuy []int32 `protobuf:"varint,4,rep,packed,name=AlreadyBuy" json:"AlreadyBuy,omitempty"`
}

func (m *ActMonolyShopItem) Reset()                    { *m = ActMonolyShopItem{} }
func (m *ActMonolyShopItem) String() string            { return proto.CompactTextString(m) }
func (*ActMonolyShopItem) ProtoMessage()               {}
func (*ActMonolyShopItem) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{40} }

type ActMonopolyAdvItem struct {
	Id       int32 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	ExpireTs int64 `protobuf:"varint,2,opt,name=ExpireTs,proto3" json:"ExpireTs,omitempty"`
}

func (m *ActMonopolyAdvItem) Reset()                    { *m = ActMonopolyAdvItem{} }
func (m *ActMonopolyAdvItem) String() string            { return proto.CompactTextString(m) }
func (*ActMonopolyAdvItem) ProtoMessage()               {}
func (*ActMonopolyAdvItem) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{41} }

type ActMonopolyBatItem struct {
	Id        int32 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	ExpireTs  int64 `protobuf:"varint,2,opt,name=ExpireTs,proto3" json:"ExpireTs,omitempty"`
	HeroLv    int32 `protobuf:"varint,3,opt,name=HeroLv,proto3" json:"HeroLv,omitempty"`
	MonsterLv int32 `protobuf:"varint,4,opt,name=MonsterLv,proto3" json:"MonsterLv,omitempty"`
}

func (m *ActMonopolyBatItem) Reset()                    { *m = ActMonopolyBatItem{} }
func (m *ActMonopolyBatItem) String() string            { return proto.CompactTextString(m) }
func (*ActMonopolyBatItem) ProtoMessage()               {}
func (*ActMonopolyBatItem) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{42} }

type GS_ActMonopolyObjValueChanged struct {
	OId int32   `protobuf:"varint,1,opt,name=OId,proto3" json:"OId,omitempty"`
	Val float64 `protobuf:"fixed64,2,opt,name=Val,proto3" json:"Val,omitempty"`
}

func (m *GS_ActMonopolyObjValueChanged) Reset()         { *m = GS_ActMonopolyObjValueChanged{} }
func (m *GS_ActMonopolyObjValueChanged) String() string { return proto.CompactTextString(m) }
func (*GS_ActMonopolyObjValueChanged) ProtoMessage()    {}
func (*GS_ActMonopolyObjValueChanged) Descriptor() ([]byte, []int) {
	return fileDescriptorCGs_40Act, []int{43}
}

type GS_ActMonoPolyNextLv struct {
	Data *ActMonopolyData `protobuf:"bytes,2,opt,name=Data" json:"Data,omitempty"`
}

func (m *GS_ActMonoPolyNextLv) Reset()                    { *m = GS_ActMonoPolyNextLv{} }
func (m *GS_ActMonoPolyNextLv) String() string            { return proto.CompactTextString(m) }
func (*GS_ActMonoPolyNextLv) ProtoMessage()               {}
func (*GS_ActMonoPolyNextLv) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{44} }

type GS_ActMonopolyBoxReward struct {
	Rewards *Rewards `protobuf:"bytes,2,opt,name=Rewards" json:"Rewards,omitempty"`
}

func (m *GS_ActMonopolyBoxReward) Reset()         { *m = GS_ActMonopolyBoxReward{} }
func (m *GS_ActMonopolyBoxReward) String() string { return proto.CompactTextString(m) }
func (*GS_ActMonopolyBoxReward) ProtoMessage()    {}
func (*GS_ActMonopolyBoxReward) Descriptor() ([]byte, []int) {
	return fileDescriptorCGs_40Act, []int{45}
}

// Info
type C_ActMonopolyInfo struct {
}

func (m *C_ActMonopolyInfo) Reset()                    { *m = C_ActMonopolyInfo{} }
func (m *C_ActMonopolyInfo) String() string            { return proto.CompactTextString(m) }
func (*C_ActMonopolyInfo) ProtoMessage()               {}
func (*C_ActMonopolyInfo) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{46} }

type GS_ActMonoPolyInfo_R struct {
	ErrorCode int32            `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Data      *ActMonopolyData `protobuf:"bytes,2,opt,name=Data" json:"Data,omitempty"`
}

func (m *GS_ActMonoPolyInfo_R) Reset()                    { *m = GS_ActMonoPolyInfo_R{} }
func (m *GS_ActMonoPolyInfo_R) String() string            { return proto.CompactTextString(m) }
func (*GS_ActMonoPolyInfo_R) ProtoMessage()               {}
func (*GS_ActMonoPolyInfo_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{47} }

// 前进N步（Step为0，则随机）
type C_ActMonopolyNPos struct {
	Step int32 `protobuf:"varint,1,opt,name=Step,proto3" json:"Step,omitempty"`
}

func (m *C_ActMonopolyNPos) Reset()                    { *m = C_ActMonopolyNPos{} }
func (m *C_ActMonopolyNPos) String() string            { return proto.CompactTextString(m) }
func (*C_ActMonopolyNPos) ProtoMessage()               {}
func (*C_ActMonopolyNPos) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{48} }

type GS_ActMonopolyNPos_R struct {
	ErrorCode int32                 `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Step      int32                 `protobuf:"varint,2,opt,name=Step,proto3" json:"Step,omitempty"`
	NormalBat []*ActMonopolyAdvItem `protobuf:"bytes,3,rep,name=NormalBat" json:"NormalBat,omitempty"`
	Problems  []*ActMonopolyAdvItem `protobuf:"bytes,4,rep,name=Problems" json:"Problems,omitempty"`
	Shops     []*ActMonolyShopItem  `protobuf:"bytes,5,rep,name=Shops" json:"Shops,omitempty"`
	HeroBat   []*ActMonopolyBatItem `protobuf:"bytes,6,rep,name=HeroBat" json:"HeroBat,omitempty"`
	Rewards   *Rewards              `protobuf:"bytes,7,opt,name=Rewards" json:"Rewards,omitempty"`
}

func (m *GS_ActMonopolyNPos_R) Reset()                    { *m = GS_ActMonopolyNPos_R{} }
func (m *GS_ActMonopolyNPos_R) String() string            { return proto.CompactTextString(m) }
func (*GS_ActMonopolyNPos_R) ProtoMessage()               {}
func (*GS_ActMonopolyNPos_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{49} }

// 答题(Idx为对应列表下标)
type C_ActMonopolyAnswer struct {
	Idx       int32 `protobuf:"varint,1,opt,name=Idx,proto3" json:"Idx,omitempty"`
	AnswerIdx int32 `protobuf:"varint,2,opt,name=AnswerIdx,proto3" json:"AnswerIdx,omitempty"`
}

func (m *C_ActMonopolyAnswer) Reset()                    { *m = C_ActMonopolyAnswer{} }
func (m *C_ActMonopolyAnswer) String() string            { return proto.CompactTextString(m) }
func (*C_ActMonopolyAnswer) ProtoMessage()               {}
func (*C_ActMonopolyAnswer) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{50} }

type GS_ActMonopolyAnswer_R struct {
	ErrorCode int32    `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Rewards   *Rewards `protobuf:"bytes,2,opt,name=Rewards" json:"Rewards,omitempty"`
}

func (m *GS_ActMonopolyAnswer_R) Reset()                    { *m = GS_ActMonopolyAnswer_R{} }
func (m *GS_ActMonopolyAnswer_R) String() string            { return proto.CompactTextString(m) }
func (*GS_ActMonopolyAnswer_R) ProtoMessage()               {}
func (*GS_ActMonopolyAnswer_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{51} }

// 商店折扣(ShopId为对应列表下标、ItemId为商品Id)
type C_ActMonopolyBuy struct {
	ShopIdx int32 `protobuf:"varint,1,opt,name=ShopIdx,proto3" json:"ShopIdx,omitempty"`
	ItemIdx int32 `protobuf:"varint,2,opt,name=ItemIdx,proto3" json:"ItemIdx,omitempty"`
}

func (m *C_ActMonopolyBuy) Reset()                    { *m = C_ActMonopolyBuy{} }
func (m *C_ActMonopolyBuy) String() string            { return proto.CompactTextString(m) }
func (*C_ActMonopolyBuy) ProtoMessage()               {}
func (*C_ActMonopolyBuy) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{52} }

type GS_ActMonopolyBuy_R struct {
	ErrorCode int32    `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Rewards   *Rewards `protobuf:"bytes,2,opt,name=Rewards" json:"Rewards,omitempty"`
}

func (m *GS_ActMonopolyBuy_R) Reset()                    { *m = GS_ActMonopolyBuy_R{} }
func (m *GS_ActMonopolyBuy_R) String() string            { return proto.CompactTextString(m) }
func (*GS_ActMonopolyBuy_R) ProtoMessage()               {}
func (*GS_ActMonopolyBuy_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{53} }

// Idx为对应列表(英雄或普通战斗)下标、Tp为战斗类型（1：普通战斗、2：英雄战斗）
type C_ActMonopolyBattle struct {
	Tp  int32          `protobuf:"varint,1,opt,name=Tp,proto3" json:"Tp,omitempty"`
	Idx int32          `protobuf:"varint,2,opt,name=Idx,proto3" json:"Idx,omitempty"`
	T   *TeamFormation `protobuf:"bytes,3,opt,name=T" json:"T,omitempty"`
}

func (m *C_ActMonopolyBattle) Reset()                    { *m = C_ActMonopolyBattle{} }
func (m *C_ActMonopolyBattle) String() string            { return proto.CompactTextString(m) }
func (*C_ActMonopolyBattle) ProtoMessage()               {}
func (*C_ActMonopolyBattle) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{54} }

type GS_ActMonopolyBattle_R struct {
	ErrorCode int32         `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Replay    *BattleReplay `protobuf:"bytes,2,opt,name=Replay" json:"Replay,omitempty"`
	Rewards   *Rewards      `protobuf:"bytes,3,opt,name=Rewards" json:"Rewards,omitempty"`
}

func (m *GS_ActMonopolyBattle_R) Reset()                    { *m = GS_ActMonopolyBattle_R{} }
func (m *GS_ActMonopolyBattle_R) String() string            { return proto.CompactTextString(m) }
func (*GS_ActMonopolyBattle_R) ProtoMessage()               {}
func (*GS_ActMonopolyBattle_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{55} }

// 活动任务领奖
type C_ActMonopolyTaskTake struct {
	Id int32 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
}

func (m *C_ActMonopolyTaskTake) Reset()                    { *m = C_ActMonopolyTaskTake{} }
func (m *C_ActMonopolyTaskTake) String() string            { return proto.CompactTextString(m) }
func (*C_ActMonopolyTaskTake) ProtoMessage()               {}
func (*C_ActMonopolyTaskTake) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{56} }

type GS_ActMonopolyTaskTake_R struct {
	ErrorCode int32    `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Rewards   *Rewards `protobuf:"bytes,2,opt,name=Rewards" json:"Rewards,omitempty"`
}

func (m *GS_ActMonopolyTaskTake_R) Reset()         { *m = GS_ActMonopolyTaskTake_R{} }
func (m *GS_ActMonopolyTaskTake_R) String() string { return proto.CompactTextString(m) }
func (*GS_ActMonopolyTaskTake_R) ProtoMessage()    {}
func (*GS_ActMonopolyTaskTake_R) Descriptor() ([]byte, []int) {
	return fileDescriptorCGs_40Act, []int{57}
}

// ============================================================================
// 迷宫
type ActMazeData struct {
	Lv         int32                 `protobuf:"varint,1,opt,name=Lv,proto3" json:"Lv,omitempty"`
	Clicked    map[int32]bool        `protobuf:"bytes,2,rep,name=Clicked" json:"Clicked,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Taken      []int32               `protobuf:"varint,3,rep,packed,name=Taken" json:"Taken,omitempty"`
	Score      int32                 `protobuf:"varint,4,opt,name=Score,proto3" json:"Score,omitempty"`
	Points     map[int32]int32       `protobuf:"bytes,5,rep,name=Points" json:"Points,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Box        map[int32]int32       `protobuf:"bytes,6,rep,name=Box" json:"Box,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Mine       map[int32]int32       `protobuf:"bytes,7,rep,name=Mine" json:"Mine,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Item       map[int32]int32       `protobuf:"bytes,8,rep,name=Item" json:"Item,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Battle     map[int32]*BattleData `protobuf:"bytes,9,rep,name=Battle" json:"Battle,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	TradeLimit map[int32]*TradeData  `protobuf:"bytes,10,rep,name=TradeLimit" json:"TradeLimit,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Attain     []*ActAttainObj       `protobuf:"bytes,11,rep,name=Attain" json:"Attain,omitempty"`
}

func (m *ActMazeData) Reset()                    { *m = ActMazeData{} }
func (m *ActMazeData) String() string            { return proto.CompactTextString(m) }
func (*ActMazeData) ProtoMessage()               {}
func (*ActMazeData) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{58} }

type TradeData struct {
	Data map[int32]int32 `protobuf:"bytes,1,rep,name=Data" json:"Data,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *TradeData) Reset()                    { *m = TradeData{} }
func (m *TradeData) String() string            { return proto.CompactTextString(m) }
func (*TradeData) ProtoMessage()               {}
func (*TradeData) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{59} }

type BattleData struct {
	Lv  int32 `protobuf:"varint,1,opt,name=Lv,proto3" json:"Lv,omitempty"`
	Seq int32 `protobuf:"varint,2,opt,name=Seq,proto3" json:"Seq,omitempty"`
	Tp  int32 `protobuf:"varint,3,opt,name=Tp,proto3" json:"Tp,omitempty"`
}

func (m *BattleData) Reset()                    { *m = BattleData{} }
func (m *BattleData) String() string            { return proto.CompactTextString(m) }
func (*BattleData) ProtoMessage()               {}
func (*BattleData) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{60} }

type GS_ActMazeObjValueChanged struct {
	OId int32   `protobuf:"varint,1,opt,name=OId,proto3" json:"OId,omitempty"`
	Val float64 `protobuf:"fixed64,2,opt,name=Val,proto3" json:"Val,omitempty"`
}

func (m *GS_ActMazeObjValueChanged) Reset()         { *m = GS_ActMazeObjValueChanged{} }
func (m *GS_ActMazeObjValueChanged) String() string { return proto.CompactTextString(m) }
func (*GS_ActMazeObjValueChanged) ProtoMessage()    {}
func (*GS_ActMazeObjValueChanged) Descriptor() ([]byte, []int) {
	return fileDescriptorCGs_40Act, []int{61}
}

type GS_ActMazeTaskTaken struct {
	Taken []int32 `protobuf:"varint,1,rep,packed,name=Taken" json:"Taken,omitempty"`
}

func (m *GS_ActMazeTaskTaken) Reset()                    { *m = GS_ActMazeTaskTaken{} }
func (m *GS_ActMazeTaskTaken) String() string            { return proto.CompactTextString(m) }
func (*GS_ActMazeTaskTaken) ProtoMessage()               {}
func (*GS_ActMazeTaskTaken) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{62} }

// 迷宫Info
type C_ActMazeInfo struct {
}

func (m *C_ActMazeInfo) Reset()                    { *m = C_ActMazeInfo{} }
func (m *C_ActMazeInfo) String() string            { return proto.CompactTextString(m) }
func (*C_ActMazeInfo) ProtoMessage()               {}
func (*C_ActMazeInfo) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{63} }

type GS_ActMazeInfo_R struct {
	ErrorCode int32        `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Data      *ActMazeData `protobuf:"bytes,2,opt,name=Data" json:"Data,omitempty"`
}

func (m *GS_ActMazeInfo_R) Reset()                    { *m = GS_ActMazeInfo_R{} }
func (m *GS_ActMazeInfo_R) String() string            { return proto.CompactTextString(m) }
func (*GS_ActMazeInfo_R) ProtoMessage()               {}
func (*GS_ActMazeInfo_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{64} }

// 迷宫翻格子（陷阱扣血）
type C_ActMazeClick struct {
	Pos int32 `protobuf:"varint,1,opt,name=Pos,proto3" json:"Pos,omitempty"`
}

func (m *C_ActMazeClick) Reset()                    { *m = C_ActMazeClick{} }
func (m *C_ActMazeClick) String() string            { return proto.CompactTextString(m) }
func (*C_ActMazeClick) ProtoMessage()               {}
func (*C_ActMazeClick) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{65} }

type GS_ActMazeClick_R struct {
	ErrorCode int32       `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Rewards   *Rewards    `protobuf:"bytes,2,opt,name=Rewards" json:"Rewards,omitempty"`
	Seq       int32       `protobuf:"varint,3,opt,name=Seq,proto3" json:"Seq,omitempty"`
	Battle    *BattleData `protobuf:"bytes,4,opt,name=Battle" json:"Battle,omitempty"`
	Score     int32       `protobuf:"varint,5,opt,name=Score,proto3" json:"Score,omitempty"`
}

func (m *GS_ActMazeClick_R) Reset()                    { *m = GS_ActMazeClick_R{} }
func (m *GS_ActMazeClick_R) String() string            { return proto.CompactTextString(m) }
func (*GS_ActMazeClick_R) ProtoMessage()               {}
func (*GS_ActMazeClick_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{66} }

// 迷宫点击出口、下一关
type C_ActMazeClickNext struct {
}

func (m *C_ActMazeClickNext) Reset()                    { *m = C_ActMazeClickNext{} }
func (m *C_ActMazeClickNext) String() string            { return proto.CompactTextString(m) }
func (*C_ActMazeClickNext) ProtoMessage()               {}
func (*C_ActMazeClickNext) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{67} }

type GS_ActMazeClickNext_R struct {
	ErrorCode int32        `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Data      *ActMazeData `protobuf:"bytes,2,opt,name=Data" json:"Data,omitempty"`
}

func (m *GS_ActMazeClickNext_R) Reset()                    { *m = GS_ActMazeClickNext_R{} }
func (m *GS_ActMazeClickNext_R) String() string            { return proto.CompactTextString(m) }
func (*GS_ActMazeClickNext_R) ProtoMessage()               {}
func (*GS_ActMazeClickNext_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{68} }

// 迷宫商人
type C_ActMazeClickTrade struct {
	Pos int32 `protobuf:"varint,1,opt,name=Pos,proto3" json:"Pos,omitempty"`
	Seq int32 `protobuf:"varint,2,opt,name=Seq,proto3" json:"Seq,omitempty"`
}

func (m *C_ActMazeClickTrade) Reset()                    { *m = C_ActMazeClickTrade{} }
func (m *C_ActMazeClickTrade) String() string            { return proto.CompactTextString(m) }
func (*C_ActMazeClickTrade) ProtoMessage()               {}
func (*C_ActMazeClickTrade) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{69} }

type GS_ActMazeClickTrade_R struct {
	ErrorCode int32    `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Rewards   *Rewards `protobuf:"bytes,2,opt,name=Rewards" json:"Rewards,omitempty"`
}

func (m *GS_ActMazeClickTrade_R) Reset()                    { *m = GS_ActMazeClickTrade_R{} }
func (m *GS_ActMazeClickTrade_R) String() string            { return proto.CompactTextString(m) }
func (*GS_ActMazeClickTrade_R) ProtoMessage()               {}
func (*GS_ActMazeClickTrade_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{70} }

// 迷宫重置（从第1关开始）
type C_ActMazeReset struct {
}

func (m *C_ActMazeReset) Reset()                    { *m = C_ActMazeReset{} }
func (m *C_ActMazeReset) String() string            { return proto.CompactTextString(m) }
func (*C_ActMazeReset) ProtoMessage()               {}
func (*C_ActMazeReset) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{71} }

type GS_ActMazeReset_R struct {
	ErrorCode int32        `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Data      *ActMazeData `protobuf:"bytes,2,opt,name=Data" json:"Data,omitempty"`
}

func (m *GS_ActMazeReset_R) Reset()                    { *m = GS_ActMazeReset_R{} }
func (m *GS_ActMazeReset_R) String() string            { return proto.CompactTextString(m) }
func (*GS_ActMazeReset_R) ProtoMessage()               {}
func (*GS_ActMazeReset_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{72} }

// 迷宫领取物品（道具、宝箱、宝矿、体力、钥匙）
type C_ActMazeClickThing struct {
	Pos    int32 `protobuf:"varint,1,opt,name=Pos,proto3" json:"Pos,omitempty"`
	ItemId int32 `protobuf:"varint,2,opt,name=ItemId,proto3" json:"ItemId,omitempty"`
}

func (m *C_ActMazeClickThing) Reset()                    { *m = C_ActMazeClickThing{} }
func (m *C_ActMazeClickThing) String() string            { return proto.CompactTextString(m) }
func (*C_ActMazeClickThing) ProtoMessage()               {}
func (*C_ActMazeClickThing) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{73} }

type GS_ActMazeClickThing_R struct {
	ErrorCode int32    `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Score     int32    `protobuf:"varint,2,opt,name=Score,proto3" json:"Score,omitempty"`
	Rewards   *Rewards `protobuf:"bytes,3,opt,name=Rewards" json:"Rewards,omitempty"`
}

func (m *GS_ActMazeClickThing_R) Reset()                    { *m = GS_ActMazeClickThing_R{} }
func (m *GS_ActMazeClickThing_R) String() string            { return proto.CompactTextString(m) }
func (*GS_ActMazeClickThing_R) ProtoMessage()               {}
func (*GS_ActMazeClickThing_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{74} }

// 迷宫打怪
type C_ActMazeClickBattle struct {
	Pos int32          `protobuf:"varint,1,opt,name=Pos,proto3" json:"Pos,omitempty"`
	T   *TeamFormation `protobuf:"bytes,2,opt,name=T" json:"T,omitempty"`
	Seq int32          `protobuf:"varint,3,opt,name=Seq,proto3" json:"Seq,omitempty"`
}

func (m *C_ActMazeClickBattle) Reset()                    { *m = C_ActMazeClickBattle{} }
func (m *C_ActMazeClickBattle) String() string            { return proto.CompactTextString(m) }
func (*C_ActMazeClickBattle) ProtoMessage()               {}
func (*C_ActMazeClickBattle) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{75} }

type GS_ActMazeClickBattle_R struct {
	ErrorCode int32         `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Score     int32         `protobuf:"varint,2,opt,name=Score,proto3" json:"Score,omitempty"`
	Replay    *BattleReplay `protobuf:"bytes,3,opt,name=Replay" json:"Replay,omitempty"`
	Rewards   *Rewards      `protobuf:"bytes,4,opt,name=Rewards" json:"Rewards,omitempty"`
}

func (m *GS_ActMazeClickBattle_R) Reset()         { *m = GS_ActMazeClickBattle_R{} }
func (m *GS_ActMazeClickBattle_R) String() string { return proto.CompactTextString(m) }
func (*GS_ActMazeClickBattle_R) ProtoMessage()    {}
func (*GS_ActMazeClickBattle_R) Descriptor() ([]byte, []int) {
	return fileDescriptorCGs_40Act, []int{76}
}

// 迷宫任务领取（1:每日、2:成就）
type C_ActMazeTakeTask struct {
	Id int32 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
}

func (m *C_ActMazeTakeTask) Reset()                    { *m = C_ActMazeTakeTask{} }
func (m *C_ActMazeTakeTask) String() string            { return proto.CompactTextString(m) }
func (*C_ActMazeTakeTask) ProtoMessage()               {}
func (*C_ActMazeTakeTask) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{77} }

type GS_ActMazeTakeTask_R struct {
	ErrorCode int32    `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Id        int32    `protobuf:"varint,2,opt,name=Id,proto3" json:"Id,omitempty"`
	Rewards   *Rewards `protobuf:"bytes,3,opt,name=Rewards" json:"Rewards,omitempty"`
}

func (m *GS_ActMazeTakeTask_R) Reset()                    { *m = GS_ActMazeTakeTask_R{} }
func (m *GS_ActMazeTakeTask_R) String() string            { return proto.CompactTextString(m) }
func (*GS_ActMazeTakeTask_R) ProtoMessage()               {}
func (*GS_ActMazeTakeTask_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{78} }

// 获取迷宫加成数据
type C_ActMazeBuff struct {
}

func (m *C_ActMazeBuff) Reset()                    { *m = C_ActMazeBuff{} }
func (m *C_ActMazeBuff) String() string            { return proto.CompactTextString(m) }
func (*C_ActMazeBuff) ProtoMessage()               {}
func (*C_ActMazeBuff) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{79} }

type GS_ActMazeBuff_R struct {
	ErrorCode int32           `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	BuffIds   map[int32]int32 `protobuf:"bytes,2,rep,name=BuffIds" json:"BuffIds,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *GS_ActMazeBuff_R) Reset()                    { *m = GS_ActMazeBuff_R{} }
func (m *GS_ActMazeBuff_R) String() string            { return proto.CompactTextString(m) }
func (*GS_ActMazeBuff_R) ProtoMessage()               {}
func (*GS_ActMazeBuff_R) Descriptor() ([]byte, []int) { return fileDescriptorCGs_40Act, []int{80} }

func init() {
	proto.RegisterType((*ActAttainObj)(nil), "msg.ActAttainObj")
	proto.RegisterType((*ActRushLocalRankData)(nil), "msg.ActRushLocalRankData")
	proto.RegisterType((*C_ActRushLocalGetInfo)(nil), "msg.C_ActRushLocalGetInfo")
	proto.RegisterType((*GS_ActRushLocalGetInfo_R)(nil), "msg.GS_ActRushLocalGetInfo_R")
	proto.RegisterType((*C_ActRushLocalTake)(nil), "msg.C_ActRushLocalTake")
	proto.RegisterType((*GS_ActRushLocalTake_R)(nil), "msg.GS_ActRushLocalTake_R")
	proto.RegisterType((*ActBillLtTotalData)(nil), "msg.ActBillLtTotalData")
	proto.RegisterType((*GS_ActBillLtTotal)(nil), "msg.GS_ActBillLtTotal")
	proto.RegisterType((*C_ActBillLtTotalInfo)(nil), "msg.C_ActBillLtTotalInfo")
	proto.RegisterType((*GS_ActBillLtTotalInfo_R)(nil), "msg.GS_ActBillLtTotalInfo_R")
	proto.RegisterType((*C_ActBillLtTotalTake)(nil), "msg.C_ActBillLtTotalTake")
	proto.RegisterType((*GS_ActBillLtTotalTake_R)(nil), "msg.GS_ActBillLtTotalTake_R")
	proto.RegisterType((*ActBillLtDayData)(nil), "msg.ActBillLtDayData")
	proto.RegisterType((*C_ActBillLtDayInfo)(nil), "msg.C_ActBillLtDayInfo")
	proto.RegisterType((*GS_ActBillLtDayInfo_R)(nil), "msg.GS_ActBillLtDayInfo_R")
	proto.RegisterType((*C_ActBillLtDayTake)(nil), "msg.C_ActBillLtDayTake")
	proto.RegisterType((*GS_ActBillLtDayTake_R)(nil), "msg.GS_ActBillLtDayTake_R")
	proto.RegisterType((*GS_ActGiftNew)(nil), "msg.GS_ActGiftNew")
	proto.RegisterType((*ActSummonData)(nil), "msg.ActSummonData")
	proto.RegisterType((*C_ActSummonInfo)(nil), "msg.C_ActSummonInfo")
	proto.RegisterType((*GS_ActSummonInfo_R)(nil), "msg.GS_ActSummonInfo_R")
	proto.RegisterType((*C_ActSummonPick)(nil), "msg.C_ActSummonPick")
	proto.RegisterType((*GS_ActSummonPick_R)(nil), "msg.GS_ActSummonPick_R")
	proto.RegisterType((*C_ActSummonDraw)(nil), "msg.C_ActSummonDraw")
	proto.RegisterType((*GS_ActSummonDraw_R)(nil), "msg.GS_ActSummonDraw_R")
	proto.RegisterType((*ActTargetTaskData)(nil), "msg.ActTargetTaskData")
	proto.RegisterType((*GS_ActTargetTaskObjValueChanged)(nil), "msg.GS_ActTargetTaskObjValueChanged")
	proto.RegisterType((*C_ActTargetTaskInfo)(nil), "msg.C_ActTargetTaskInfo")
	proto.RegisterType((*GS_ActTargetTaskInfo_R)(nil), "msg.GS_ActTargetTaskInfo_R")
	proto.RegisterType((*C_ActTargetTaskTake)(nil), "msg.C_ActTargetTaskTake")
	proto.RegisterType((*GS_ActTargetTaskTake_R)(nil), "msg.GS_ActTargetTaskTake_R")
	proto.RegisterType((*ActHeroSkinData)(nil), "msg.ActHeroSkinData")
	proto.RegisterType((*C_ActHeroSkinInfo)(nil), "msg.C_ActHeroSkinInfo")
	proto.RegisterType((*GS_ActHeroSkinInfo_R)(nil), "msg.GS_ActHeroSkinInfo_R")
	proto.RegisterType((*ActMSummonData)(nil), "msg.ActMSummonData")
	proto.RegisterType((*C_ActMSummonInfo)(nil), "msg.C_ActMSummonInfo")
	proto.RegisterType((*GS_ActMSummonInfo_R)(nil), "msg.GS_ActMSummonInfo_R")
	proto.RegisterType((*C_ActMSummonDraw)(nil), "msg.C_ActMSummonDraw")
	proto.RegisterType((*GS_ActMSummonDraw_R)(nil), "msg.GS_ActMSummonDraw_R")
	proto.RegisterType((*ActMonopolyData)(nil), "msg.ActMonopolyData")
	proto.RegisterType((*ActMonolyShopItem)(nil), "msg.ActMonolyShopItem")
	proto.RegisterType((*ActMonopolyAdvItem)(nil), "msg.ActMonopolyAdvItem")
	proto.RegisterType((*ActMonopolyBatItem)(nil), "msg.ActMonopolyBatItem")
	proto.RegisterType((*GS_ActMonopolyObjValueChanged)(nil), "msg.GS_ActMonopolyObjValueChanged")
	proto.RegisterType((*GS_ActMonoPolyNextLv)(nil), "msg.GS_ActMonoPolyNextLv")
	proto.RegisterType((*GS_ActMonopolyBoxReward)(nil), "msg.GS_ActMonopolyBoxReward")
	proto.RegisterType((*C_ActMonopolyInfo)(nil), "msg.C_ActMonopolyInfo")
	proto.RegisterType((*GS_ActMonoPolyInfo_R)(nil), "msg.GS_ActMonoPolyInfo_R")
	proto.RegisterType((*C_ActMonopolyNPos)(nil), "msg.C_ActMonopolyNPos")
	proto.RegisterType((*GS_ActMonopolyNPos_R)(nil), "msg.GS_ActMonopolyNPos_R")
	proto.RegisterType((*C_ActMonopolyAnswer)(nil), "msg.C_ActMonopolyAnswer")
	proto.RegisterType((*GS_ActMonopolyAnswer_R)(nil), "msg.GS_ActMonopolyAnswer_R")
	proto.RegisterType((*C_ActMonopolyBuy)(nil), "msg.C_ActMonopolyBuy")
	proto.RegisterType((*GS_ActMonopolyBuy_R)(nil), "msg.GS_ActMonopolyBuy_R")
	proto.RegisterType((*C_ActMonopolyBattle)(nil), "msg.C_ActMonopolyBattle")
	proto.RegisterType((*GS_ActMonopolyBattle_R)(nil), "msg.GS_ActMonopolyBattle_R")
	proto.RegisterType((*C_ActMonopolyTaskTake)(nil), "msg.C_ActMonopolyTaskTake")
	proto.RegisterType((*GS_ActMonopolyTaskTake_R)(nil), "msg.GS_ActMonopolyTaskTake_R")
	proto.RegisterType((*ActMazeData)(nil), "msg.ActMazeData")
	proto.RegisterType((*TradeData)(nil), "msg.TradeData")
	proto.RegisterType((*BattleData)(nil), "msg.BattleData")
	proto.RegisterType((*GS_ActMazeObjValueChanged)(nil), "msg.GS_ActMazeObjValueChanged")
	proto.RegisterType((*GS_ActMazeTaskTaken)(nil), "msg.GS_ActMazeTaskTaken")
	proto.RegisterType((*C_ActMazeInfo)(nil), "msg.C_ActMazeInfo")
	proto.RegisterType((*GS_ActMazeInfo_R)(nil), "msg.GS_ActMazeInfo_R")
	proto.RegisterType((*C_ActMazeClick)(nil), "msg.C_ActMazeClick")
	proto.RegisterType((*GS_ActMazeClick_R)(nil), "msg.GS_ActMazeClick_R")
	proto.RegisterType((*C_ActMazeClickNext)(nil), "msg.C_ActMazeClickNext")
	proto.RegisterType((*GS_ActMazeClickNext_R)(nil), "msg.GS_ActMazeClickNext_R")
	proto.RegisterType((*C_ActMazeClickTrade)(nil), "msg.C_ActMazeClickTrade")
	proto.RegisterType((*GS_ActMazeClickTrade_R)(nil), "msg.GS_ActMazeClickTrade_R")
	proto.RegisterType((*C_ActMazeReset)(nil), "msg.C_ActMazeReset")
	proto.RegisterType((*GS_ActMazeReset_R)(nil), "msg.GS_ActMazeReset_R")
	proto.RegisterType((*C_ActMazeClickThing)(nil), "msg.C_ActMazeClickThing")
	proto.RegisterType((*GS_ActMazeClickThing_R)(nil), "msg.GS_ActMazeClickThing_R")
	proto.RegisterType((*C_ActMazeClickBattle)(nil), "msg.C_ActMazeClickBattle")
	proto.RegisterType((*GS_ActMazeClickBattle_R)(nil), "msg.GS_ActMazeClickBattle_R")
	proto.RegisterType((*C_ActMazeTakeTask)(nil), "msg.C_ActMazeTakeTask")
	proto.RegisterType((*GS_ActMazeTakeTask_R)(nil), "msg.GS_ActMazeTakeTask_R")
	proto.RegisterType((*C_ActMazeBuff)(nil), "msg.C_ActMazeBuff")
	proto.RegisterType((*GS_ActMazeBuff_R)(nil), "msg.GS_ActMazeBuff_R")
}
func (m *ActAttainObj) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActAttainObj) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.OId))
	}
	if m.Val != 0 {
		dAtA[i] = 0x11
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Val))))
		i += 8
	}
	return i, nil
}

func (m *ActRushLocalRankData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActRushLocalRankData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ActName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(len(m.ActName)))
		i += copy(dAtA[i:], m.ActName)
	}
	if m.RankId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.RankId))
	}
	if m.Take {
		dAtA[i] = 0x18
		i++
		if m.Take {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SelfScore != 0 {
		dAtA[i] = 0x21
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.SelfScore))))
		i += 8
	}
	if m.CachedScore != 0 {
		dAtA[i] = 0x29
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CachedScore))))
		i += 8
	}
	return i, nil
}

func (m *C_ActRushLocalGetInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ActRushLocalGetInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ActName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(len(m.ActName)))
		i += copy(dAtA[i:], m.ActName)
	}
	if m.RankId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.RankId))
	}
	return i, nil
}

func (m *GS_ActRushLocalGetInfo_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActRushLocalGetInfo_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *C_ActRushLocalTake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ActRushLocalTake) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ActName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(len(m.ActName)))
		i += copy(dAtA[i:], m.ActName)
	}
	if m.RankId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.RankId))
	}
	return i, nil
}

func (m *GS_ActRushLocalTake_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActRushLocalTake_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.ActName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(len(m.ActName)))
		i += copy(dAtA[i:], m.ActName)
	}
	if m.RankId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.RankId))
	}
	if m.Rewards != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Rewards.Size()))
		n1, err := m.Rewards.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *ActBillLtTotalData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActBillLtTotalData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Total != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Total))
	}
	if len(m.Taken) > 0 {
		dAtA3 := make([]byte, len(m.Taken)*10)
		var j2 int
		for _, num1 := range m.Taken {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	return i, nil
}

func (m *GS_ActBillLtTotal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActBillLtTotal) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Total != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Total))
	}
	return i, nil
}

func (m *C_ActBillLtTotalInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ActBillLtTotalInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GS_ActBillLtTotalInfo_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActBillLtTotalInfo_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Data != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Data.Size()))
		n4, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *C_ActBillLtTotalTake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ActBillLtTotalTake) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *GS_ActBillLtTotalTake_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActBillLtTotalTake_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Id))
	}
	if m.Rewards != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Rewards.Size()))
		n5, err := m.Rewards.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *ActBillLtDayData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActBillLtDayData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Taken) > 0 {
		dAtA7 := make([]byte, len(m.Taken)*10)
		var j6 int
		for _, num1 := range m.Taken {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	if m.BillDay != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.BillDay))
	}
	return i, nil
}

func (m *C_ActBillLtDayInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ActBillLtDayInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GS_ActBillLtDayInfo_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActBillLtDayInfo_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Data != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Data.Size()))
		n8, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *C_ActBillLtDayTake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ActBillLtDayTake) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *GS_ActBillLtDayTake_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActBillLtDayTake_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Rewards != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Rewards.Size()))
		n9, err := m.Rewards.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *GS_ActGiftNew) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActGiftNew) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Id))
	}
	if m.Rewards != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Rewards.Size()))
		n10, err := m.Rewards.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *ActSummonData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActSummonData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NormalCnt != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.NormalCnt))
	}
	if m.DesireCnt != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.DesireCnt))
	}
	if m.DiamCnt != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.DiamCnt))
	}
	if m.UpCnt != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.UpCnt))
	}
	if m.LastTs != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.LastTs))
	}
	if len(m.HeroPos) > 0 {
		for k, _ := range m.HeroPos {
			dAtA[i] = 0x32
			i++
			v := m.HeroPos[k]
			mapSize := 1 + sovCGs_40Act(uint64(k)) + 1 + sovCGs_40Act(uint64(v))
			i = encodeVarintCGs_40Act(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(v))
		}
	}
	if len(m.ActGift) > 0 {
		for k, _ := range m.ActGift {
			dAtA[i] = 0x3a
			i++
			v := m.ActGift[k]
			mapSize := 1 + sovCGs_40Act(uint64(k)) + 1 + sovCGs_40Act(uint64(v))
			i = encodeVarintCGs_40Act(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *C_ActSummonInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ActSummonInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GS_ActSummonInfo_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActSummonInfo_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Data != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Data.Size()))
		n11, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *C_ActSummonPick) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ActSummonPick) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HeroPos) > 0 {
		for k, _ := range m.HeroPos {
			dAtA[i] = 0xa
			i++
			v := m.HeroPos[k]
			mapSize := 1 + sovCGs_40Act(uint64(k)) + 1 + sovCGs_40Act(uint64(v))
			i = encodeVarintCGs_40Act(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *GS_ActSummonPick_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActSummonPick_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *C_ActSummonDraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ActSummonDraw) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsDiam {
		dAtA[i] = 0x8
		i++
		if m.IsDiam {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.N != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.N))
	}
	return i, nil
}

func (m *GS_ActSummonDraw_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActSummonDraw_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ErrorCode))
	}
	if m.LastTs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.LastTs))
	}
	if m.NormalCnt != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.NormalCnt))
	}
	if m.DesireCnt != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.DesireCnt))
	}
	if m.UpCnt != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.UpCnt))
	}
	if m.DiamCnt != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.DiamCnt))
	}
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Rewards != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Rewards.Size()))
		n12, err := m.Rewards.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *ActTargetTaskData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActTargetTaskData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Attain) > 0 {
		for _, msg := range m.Attain {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Taken) > 0 {
		dAtA14 := make([]byte, len(m.Taken)*10)
		var j13 int
		for _, num1 := range m.Taken {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	if len(m.ActGift) > 0 {
		for k, _ := range m.ActGift {
			dAtA[i] = 0x1a
			i++
			v := m.ActGift[k]
			mapSize := 1 + sovCGs_40Act(uint64(k)) + 1 + sovCGs_40Act(uint64(v))
			i = encodeVarintCGs_40Act(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *GS_ActTargetTaskObjValueChanged) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActTargetTaskObjValueChanged) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.OId))
	}
	if m.Val != 0 {
		dAtA[i] = 0x11
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Val))))
		i += 8
	}
	return i, nil
}

func (m *C_ActTargetTaskInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ActTargetTaskInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GS_ActTargetTaskInfo_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActTargetTaskInfo_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Data != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Data.Size()))
		n15, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *C_ActTargetTaskTake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ActTargetTaskTake) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *GS_ActTargetTaskTake_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActTargetTaskTake_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Rewards != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Rewards.Size()))
		n16, err := m.Rewards.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *ActHeroSkinData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActHeroSkinData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ActGift) > 0 {
		for k, _ := range m.ActGift {
			dAtA[i] = 0xa
			i++
			v := m.ActGift[k]
			mapSize := 1 + sovCGs_40Act(uint64(k)) + 1 + sovCGs_40Act(uint64(v))
			i = encodeVarintCGs_40Act(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *C_ActHeroSkinInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ActHeroSkinInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GS_ActHeroSkinInfo_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActHeroSkinInfo_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Data != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Data.Size()))
		n17, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *ActMSummonData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActMSummonData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NormalCnt != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.NormalCnt))
	}
	if m.MagicCnt != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.MagicCnt))
	}
	if m.DiamCnt != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.DiamCnt))
	}
	if m.LastTs != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.LastTs))
	}
	if len(m.ActGift) > 0 {
		for k, _ := range m.ActGift {
			dAtA[i] = 0x2a
			i++
			v := m.ActGift[k]
			mapSize := 1 + sovCGs_40Act(uint64(k)) + 1 + sovCGs_40Act(uint64(v))
			i = encodeVarintCGs_40Act(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *C_ActMSummonInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ActMSummonInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GS_ActMSummonInfo_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActMSummonInfo_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Data != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Data.Size()))
		n18, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *C_ActMSummonDraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ActMSummonDraw) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsDiam {
		dAtA[i] = 0x8
		i++
		if m.IsDiam {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.N != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.N))
	}
	return i, nil
}

func (m *GS_ActMSummonDraw_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActMSummonDraw_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ErrorCode))
	}
	if m.MagicCnt != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.MagicCnt))
	}
	if m.LastTs != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.LastTs))
	}
	if m.DiamCnt != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.DiamCnt))
	}
	if m.NormalCnt != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.NormalCnt))
	}
	if m.Rewards != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Rewards.Size()))
		n19, err := m.Rewards.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *ActMonopolyData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActMonopolyData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seq != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Seq))
	}
	if m.Pos != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Pos))
	}
	if m.RepeatCnt != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.RepeatCnt))
	}
	if len(m.AdvPosInfo) > 0 {
		for k, _ := range m.AdvPosInfo {
			dAtA[i] = 0x22
			i++
			v := m.AdvPosInfo[k]
			mapSize := 1 + sovCGs_40Act(uint64(k)) + 1 + sovCGs_40Act(uint64(v))
			i = encodeVarintCGs_40Act(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(v))
		}
	}
	if len(m.TaskTaken) > 0 {
		dAtA21 := make([]byte, len(m.TaskTaken)*10)
		var j20 int
		for _, num1 := range m.TaskTaken {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(j20))
		i += copy(dAtA[i:], dAtA21[:j20])
	}
	if len(m.NormalBat) > 0 {
		for _, msg := range m.NormalBat {
			dAtA[i] = 0x32
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Problems) > 0 {
		for _, msg := range m.Problems {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Shops) > 0 {
		for _, msg := range m.Shops {
			dAtA[i] = 0x42
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.HeroBat) > 0 {
		for _, msg := range m.HeroBat {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Attain) > 0 {
		for _, msg := range m.Attain {
			dAtA[i] = 0x52
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ActMonolyShopItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActMonolyShopItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Id))
	}
	if m.ExpireTs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ExpireTs))
	}
	if m.DisCnt != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.DisCnt))
	}
	if len(m.AlreadyBuy) > 0 {
		dAtA23 := make([]byte, len(m.AlreadyBuy)*10)
		var j22 int
		for _, num1 := range m.AlreadyBuy {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA23[j22] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j22++
			}
			dAtA23[j22] = uint8(num)
			j22++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(j22))
		i += copy(dAtA[i:], dAtA23[:j22])
	}
	return i, nil
}

func (m *ActMonopolyAdvItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActMonopolyAdvItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Id))
	}
	if m.ExpireTs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ExpireTs))
	}
	return i, nil
}

func (m *ActMonopolyBatItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActMonopolyBatItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Id))
	}
	if m.ExpireTs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ExpireTs))
	}
	if m.HeroLv != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.HeroLv))
	}
	if m.MonsterLv != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.MonsterLv))
	}
	return i, nil
}

func (m *GS_ActMonopolyObjValueChanged) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActMonopolyObjValueChanged) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.OId))
	}
	if m.Val != 0 {
		dAtA[i] = 0x11
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Val))))
		i += 8
	}
	return i, nil
}

func (m *GS_ActMonoPolyNextLv) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActMonoPolyNextLv) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Data.Size()))
		n24, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *GS_ActMonopolyBoxReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActMonopolyBoxReward) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rewards != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Rewards.Size()))
		n25, err := m.Rewards.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *C_ActMonopolyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ActMonopolyInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GS_ActMonoPolyInfo_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActMonoPolyInfo_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Data != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Data.Size()))
		n26, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *C_ActMonopolyNPos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ActMonopolyNPos) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Step != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Step))
	}
	return i, nil
}

func (m *GS_ActMonopolyNPos_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActMonopolyNPos_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Step != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Step))
	}
	if len(m.NormalBat) > 0 {
		for _, msg := range m.NormalBat {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Problems) > 0 {
		for _, msg := range m.Problems {
			dAtA[i] = 0x22
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Shops) > 0 {
		for _, msg := range m.Shops {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.HeroBat) > 0 {
		for _, msg := range m.HeroBat {
			dAtA[i] = 0x32
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Rewards != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Rewards.Size()))
		n27, err := m.Rewards.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}

func (m *C_ActMonopolyAnswer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ActMonopolyAnswer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Idx != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Idx))
	}
	if m.AnswerIdx != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.AnswerIdx))
	}
	return i, nil
}

func (m *GS_ActMonopolyAnswer_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActMonopolyAnswer_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Rewards != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Rewards.Size()))
		n28, err := m.Rewards.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}

func (m *C_ActMonopolyBuy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ActMonopolyBuy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ShopIdx != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ShopIdx))
	}
	if m.ItemIdx != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ItemIdx))
	}
	return i, nil
}

func (m *GS_ActMonopolyBuy_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActMonopolyBuy_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Rewards != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Rewards.Size()))
		n29, err := m.Rewards.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}

func (m *C_ActMonopolyBattle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ActMonopolyBattle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Tp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Tp))
	}
	if m.Idx != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Idx))
	}
	if m.T != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.T.Size()))
		n30, err := m.T.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}

func (m *GS_ActMonopolyBattle_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActMonopolyBattle_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Replay != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Replay.Size()))
		n31, err := m.Replay.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.Rewards != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Rewards.Size()))
		n32, err := m.Rewards.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func (m *C_ActMonopolyTaskTake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ActMonopolyTaskTake) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *GS_ActMonopolyTaskTake_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActMonopolyTaskTake_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Rewards != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Rewards.Size()))
		n33, err := m.Rewards.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}

func (m *ActMazeData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActMazeData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Lv != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Lv))
	}
	if len(m.Clicked) > 0 {
		for k, _ := range m.Clicked {
			dAtA[i] = 0x12
			i++
			v := m.Clicked[k]
			mapSize := 1 + sovCGs_40Act(uint64(k)) + 1 + 1
			i = encodeVarintCGs_40Act(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.Taken) > 0 {
		dAtA35 := make([]byte, len(m.Taken)*10)
		var j34 int
		for _, num1 := range m.Taken {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA35[j34] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j34++
			}
			dAtA35[j34] = uint8(num)
			j34++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(j34))
		i += copy(dAtA[i:], dAtA35[:j34])
	}
	if m.Score != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Score))
	}
	if len(m.Points) > 0 {
		for k, _ := range m.Points {
			dAtA[i] = 0x2a
			i++
			v := m.Points[k]
			mapSize := 1 + sovCGs_40Act(uint64(k)) + 1 + sovCGs_40Act(uint64(v))
			i = encodeVarintCGs_40Act(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(v))
		}
	}
	if len(m.Box) > 0 {
		for k, _ := range m.Box {
			dAtA[i] = 0x32
			i++
			v := m.Box[k]
			mapSize := 1 + sovCGs_40Act(uint64(k)) + 1 + sovCGs_40Act(uint64(v))
			i = encodeVarintCGs_40Act(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(v))
		}
	}
	if len(m.Mine) > 0 {
		for k, _ := range m.Mine {
			dAtA[i] = 0x3a
			i++
			v := m.Mine[k]
			mapSize := 1 + sovCGs_40Act(uint64(k)) + 1 + sovCGs_40Act(uint64(v))
			i = encodeVarintCGs_40Act(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(v))
		}
	}
	if len(m.Item) > 0 {
		for k, _ := range m.Item {
			dAtA[i] = 0x42
			i++
			v := m.Item[k]
			mapSize := 1 + sovCGs_40Act(uint64(k)) + 1 + sovCGs_40Act(uint64(v))
			i = encodeVarintCGs_40Act(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(v))
		}
	}
	if len(m.Battle) > 0 {
		for k, _ := range m.Battle {
			dAtA[i] = 0x4a
			i++
			v := m.Battle[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCGs_40Act(uint64(msgSize))
			}
			mapSize := 1 + sovCGs_40Act(uint64(k)) + msgSize
			i = encodeVarintCGs_40Act(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCGs_40Act(dAtA, i, uint64(v.Size()))
				n36, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n36
			}
		}
	}
	if len(m.TradeLimit) > 0 {
		for k, _ := range m.TradeLimit {
			dAtA[i] = 0x52
			i++
			v := m.TradeLimit[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCGs_40Act(uint64(msgSize))
			}
			mapSize := 1 + sovCGs_40Act(uint64(k)) + msgSize
			i = encodeVarintCGs_40Act(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCGs_40Act(dAtA, i, uint64(v.Size()))
				n37, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n37
			}
		}
	}
	if len(m.Attain) > 0 {
		for _, msg := range m.Attain {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TradeData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradeData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for k, _ := range m.Data {
			dAtA[i] = 0xa
			i++
			v := m.Data[k]
			mapSize := 1 + sovCGs_40Act(uint64(k)) + 1 + sovCGs_40Act(uint64(v))
			i = encodeVarintCGs_40Act(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *BattleData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BattleData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Lv != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Lv))
	}
	if m.Seq != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Seq))
	}
	if m.Tp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Tp))
	}
	return i, nil
}

func (m *GS_ActMazeObjValueChanged) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActMazeObjValueChanged) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.OId))
	}
	if m.Val != 0 {
		dAtA[i] = 0x11
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Val))))
		i += 8
	}
	return i, nil
}

func (m *GS_ActMazeTaskTaken) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActMazeTaskTaken) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Taken) > 0 {
		dAtA39 := make([]byte, len(m.Taken)*10)
		var j38 int
		for _, num1 := range m.Taken {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA39[j38] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j38++
			}
			dAtA39[j38] = uint8(num)
			j38++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(j38))
		i += copy(dAtA[i:], dAtA39[:j38])
	}
	return i, nil
}

func (m *C_ActMazeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ActMazeInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GS_ActMazeInfo_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActMazeInfo_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Data != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Data.Size()))
		n40, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}

func (m *C_ActMazeClick) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ActMazeClick) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pos != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Pos))
	}
	return i, nil
}

func (m *GS_ActMazeClick_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActMazeClick_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Rewards != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Rewards.Size()))
		n41, err := m.Rewards.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.Seq != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Seq))
	}
	if m.Battle != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Battle.Size()))
		n42, err := m.Battle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.Score != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Score))
	}
	return i, nil
}

func (m *C_ActMazeClickNext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ActMazeClickNext) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GS_ActMazeClickNext_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActMazeClickNext_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Data != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Data.Size()))
		n43, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	return i, nil
}

func (m *C_ActMazeClickTrade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ActMazeClickTrade) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pos != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Pos))
	}
	if m.Seq != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Seq))
	}
	return i, nil
}

func (m *GS_ActMazeClickTrade_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActMazeClickTrade_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Rewards != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Rewards.Size()))
		n44, err := m.Rewards.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	return i, nil
}

func (m *C_ActMazeReset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ActMazeReset) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GS_ActMazeReset_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActMazeReset_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Data != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Data.Size()))
		n45, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	return i, nil
}

func (m *C_ActMazeClickThing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ActMazeClickThing) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pos != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Pos))
	}
	if m.ItemId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ItemId))
	}
	return i, nil
}

func (m *GS_ActMazeClickThing_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActMazeClickThing_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Score != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Score))
	}
	if m.Rewards != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Rewards.Size()))
		n46, err := m.Rewards.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	return i, nil
}

func (m *C_ActMazeClickBattle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ActMazeClickBattle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pos != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Pos))
	}
	if m.T != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.T.Size()))
		n47, err := m.T.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	if m.Seq != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Seq))
	}
	return i, nil
}

func (m *GS_ActMazeClickBattle_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActMazeClickBattle_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Score != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Score))
	}
	if m.Replay != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Replay.Size()))
		n48, err := m.Replay.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	if m.Rewards != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Rewards.Size()))
		n49, err := m.Rewards.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	return i, nil
}

func (m *C_ActMazeTakeTask) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ActMazeTakeTask) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *GS_ActMazeTakeTask_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActMazeTakeTask_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Id))
	}
	if m.Rewards != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.Rewards.Size()))
		n50, err := m.Rewards.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	return i, nil
}

func (m *C_ActMazeBuff) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ActMazeBuff) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GS_ActMazeBuff_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GS_ActMazeBuff_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGs_40Act(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.BuffIds) > 0 {
		for k, _ := range m.BuffIds {
			dAtA[i] = 0x12
			i++
			v := m.BuffIds[k]
			mapSize := 1 + sovCGs_40Act(uint64(k)) + 1 + sovCGs_40Act(uint64(v))
			i = encodeVarintCGs_40Act(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCGs_40Act(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func encodeVarintCGs_40Act(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ActAttainObj) Size() (n int) {
	var l int
	_ = l
	if m.OId != 0 {
		n += 1 + sovCGs_40Act(uint64(m.OId))
	}
	if m.Val != 0 {
		n += 9
	}
	return n
}

func (m *ActRushLocalRankData) Size() (n int) {
	var l int
	_ = l
	l = len(m.ActName)
	if l > 0 {
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	if m.RankId != 0 {
		n += 1 + sovCGs_40Act(uint64(m.RankId))
	}
	if m.Take {
		n += 2
	}
	if m.SelfScore != 0 {
		n += 9
	}
	if m.CachedScore != 0 {
		n += 9
	}
	return n
}

func (m *C_ActRushLocalGetInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.ActName)
	if l > 0 {
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	if m.RankId != 0 {
		n += 1 + sovCGs_40Act(uint64(m.RankId))
	}
	return n
}

func (m *GS_ActRushLocalGetInfo_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ErrorCode))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovCGs_40Act(uint64(l))
		}
	}
	return n
}

func (m *C_ActRushLocalTake) Size() (n int) {
	var l int
	_ = l
	l = len(m.ActName)
	if l > 0 {
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	if m.RankId != 0 {
		n += 1 + sovCGs_40Act(uint64(m.RankId))
	}
	return n
}

func (m *GS_ActRushLocalTake_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ErrorCode))
	}
	l = len(m.ActName)
	if l > 0 {
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	if m.RankId != 0 {
		n += 1 + sovCGs_40Act(uint64(m.RankId))
	}
	if m.Rewards != nil {
		l = m.Rewards.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	return n
}

func (m *ActBillLtTotalData) Size() (n int) {
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Total))
	}
	if len(m.Taken) > 0 {
		l = 0
		for _, e := range m.Taken {
			l += sovCGs_40Act(uint64(e))
		}
		n += 1 + sovCGs_40Act(uint64(l)) + l
	}
	return n
}

func (m *GS_ActBillLtTotal) Size() (n int) {
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Total))
	}
	return n
}

func (m *C_ActBillLtTotalInfo) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GS_ActBillLtTotalInfo_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ErrorCode))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	return n
}

func (m *C_ActBillLtTotalTake) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Id))
	}
	return n
}

func (m *GS_ActBillLtTotalTake_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ErrorCode))
	}
	if m.Id != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Id))
	}
	if m.Rewards != nil {
		l = m.Rewards.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	return n
}

func (m *ActBillLtDayData) Size() (n int) {
	var l int
	_ = l
	if len(m.Taken) > 0 {
		l = 0
		for _, e := range m.Taken {
			l += sovCGs_40Act(uint64(e))
		}
		n += 1 + sovCGs_40Act(uint64(l)) + l
	}
	if m.BillDay != 0 {
		n += 1 + sovCGs_40Act(uint64(m.BillDay))
	}
	return n
}

func (m *C_ActBillLtDayInfo) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GS_ActBillLtDayInfo_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ErrorCode))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	return n
}

func (m *C_ActBillLtDayTake) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Id))
	}
	return n
}

func (m *GS_ActBillLtDayTake_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ErrorCode))
	}
	if m.Rewards != nil {
		l = m.Rewards.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	return n
}

func (m *GS_ActGiftNew) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Id))
	}
	if m.Rewards != nil {
		l = m.Rewards.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	return n
}

func (m *ActSummonData) Size() (n int) {
	var l int
	_ = l
	if m.NormalCnt != 0 {
		n += 1 + sovCGs_40Act(uint64(m.NormalCnt))
	}
	if m.DesireCnt != 0 {
		n += 1 + sovCGs_40Act(uint64(m.DesireCnt))
	}
	if m.DiamCnt != 0 {
		n += 1 + sovCGs_40Act(uint64(m.DiamCnt))
	}
	if m.UpCnt != 0 {
		n += 1 + sovCGs_40Act(uint64(m.UpCnt))
	}
	if m.LastTs != 0 {
		n += 1 + sovCGs_40Act(uint64(m.LastTs))
	}
	if len(m.HeroPos) > 0 {
		for k, v := range m.HeroPos {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCGs_40Act(uint64(k)) + 1 + sovCGs_40Act(uint64(v))
			n += mapEntrySize + 1 + sovCGs_40Act(uint64(mapEntrySize))
		}
	}
	if len(m.ActGift) > 0 {
		for k, v := range m.ActGift {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCGs_40Act(uint64(k)) + 1 + sovCGs_40Act(uint64(v))
			n += mapEntrySize + 1 + sovCGs_40Act(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *C_ActSummonInfo) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GS_ActSummonInfo_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ErrorCode))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	return n
}

func (m *C_ActSummonPick) Size() (n int) {
	var l int
	_ = l
	if len(m.HeroPos) > 0 {
		for k, v := range m.HeroPos {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCGs_40Act(uint64(k)) + 1 + sovCGs_40Act(uint64(v))
			n += mapEntrySize + 1 + sovCGs_40Act(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *GS_ActSummonPick_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ErrorCode))
	}
	return n
}

func (m *C_ActSummonDraw) Size() (n int) {
	var l int
	_ = l
	if m.IsDiam {
		n += 2
	}
	if m.N != 0 {
		n += 1 + sovCGs_40Act(uint64(m.N))
	}
	return n
}

func (m *GS_ActSummonDraw_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ErrorCode))
	}
	if m.LastTs != 0 {
		n += 1 + sovCGs_40Act(uint64(m.LastTs))
	}
	if m.NormalCnt != 0 {
		n += 1 + sovCGs_40Act(uint64(m.NormalCnt))
	}
	if m.DesireCnt != 0 {
		n += 1 + sovCGs_40Act(uint64(m.DesireCnt))
	}
	if m.UpCnt != 0 {
		n += 1 + sovCGs_40Act(uint64(m.UpCnt))
	}
	if m.DiamCnt != 0 {
		n += 1 + sovCGs_40Act(uint64(m.DiamCnt))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovCGs_40Act(uint64(l))
		}
	}
	if m.Rewards != nil {
		l = m.Rewards.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	return n
}

func (m *ActTargetTaskData) Size() (n int) {
	var l int
	_ = l
	if len(m.Attain) > 0 {
		for _, e := range m.Attain {
			l = e.Size()
			n += 1 + l + sovCGs_40Act(uint64(l))
		}
	}
	if len(m.Taken) > 0 {
		l = 0
		for _, e := range m.Taken {
			l += sovCGs_40Act(uint64(e))
		}
		n += 1 + sovCGs_40Act(uint64(l)) + l
	}
	if len(m.ActGift) > 0 {
		for k, v := range m.ActGift {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCGs_40Act(uint64(k)) + 1 + sovCGs_40Act(uint64(v))
			n += mapEntrySize + 1 + sovCGs_40Act(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *GS_ActTargetTaskObjValueChanged) Size() (n int) {
	var l int
	_ = l
	if m.OId != 0 {
		n += 1 + sovCGs_40Act(uint64(m.OId))
	}
	if m.Val != 0 {
		n += 9
	}
	return n
}

func (m *C_ActTargetTaskInfo) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GS_ActTargetTaskInfo_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ErrorCode))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	return n
}

func (m *C_ActTargetTaskTake) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Id))
	}
	return n
}

func (m *GS_ActTargetTaskTake_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ErrorCode))
	}
	if m.Rewards != nil {
		l = m.Rewards.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	return n
}

func (m *ActHeroSkinData) Size() (n int) {
	var l int
	_ = l
	if len(m.ActGift) > 0 {
		for k, v := range m.ActGift {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCGs_40Act(uint64(k)) + 1 + sovCGs_40Act(uint64(v))
			n += mapEntrySize + 1 + sovCGs_40Act(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *C_ActHeroSkinInfo) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GS_ActHeroSkinInfo_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ErrorCode))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	return n
}

func (m *ActMSummonData) Size() (n int) {
	var l int
	_ = l
	if m.NormalCnt != 0 {
		n += 1 + sovCGs_40Act(uint64(m.NormalCnt))
	}
	if m.MagicCnt != 0 {
		n += 1 + sovCGs_40Act(uint64(m.MagicCnt))
	}
	if m.DiamCnt != 0 {
		n += 1 + sovCGs_40Act(uint64(m.DiamCnt))
	}
	if m.LastTs != 0 {
		n += 1 + sovCGs_40Act(uint64(m.LastTs))
	}
	if len(m.ActGift) > 0 {
		for k, v := range m.ActGift {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCGs_40Act(uint64(k)) + 1 + sovCGs_40Act(uint64(v))
			n += mapEntrySize + 1 + sovCGs_40Act(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *C_ActMSummonInfo) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GS_ActMSummonInfo_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ErrorCode))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	return n
}

func (m *C_ActMSummonDraw) Size() (n int) {
	var l int
	_ = l
	if m.IsDiam {
		n += 2
	}
	if m.N != 0 {
		n += 1 + sovCGs_40Act(uint64(m.N))
	}
	return n
}

func (m *GS_ActMSummonDraw_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ErrorCode))
	}
	if m.MagicCnt != 0 {
		n += 1 + sovCGs_40Act(uint64(m.MagicCnt))
	}
	if m.LastTs != 0 {
		n += 1 + sovCGs_40Act(uint64(m.LastTs))
	}
	if m.DiamCnt != 0 {
		n += 1 + sovCGs_40Act(uint64(m.DiamCnt))
	}
	if m.NormalCnt != 0 {
		n += 1 + sovCGs_40Act(uint64(m.NormalCnt))
	}
	if m.Rewards != nil {
		l = m.Rewards.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	return n
}

func (m *ActMonopolyData) Size() (n int) {
	var l int
	_ = l
	if m.Seq != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Seq))
	}
	if m.Pos != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Pos))
	}
	if m.RepeatCnt != 0 {
		n += 1 + sovCGs_40Act(uint64(m.RepeatCnt))
	}
	if len(m.AdvPosInfo) > 0 {
		for k, v := range m.AdvPosInfo {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCGs_40Act(uint64(k)) + 1 + sovCGs_40Act(uint64(v))
			n += mapEntrySize + 1 + sovCGs_40Act(uint64(mapEntrySize))
		}
	}
	if len(m.TaskTaken) > 0 {
		l = 0
		for _, e := range m.TaskTaken {
			l += sovCGs_40Act(uint64(e))
		}
		n += 1 + sovCGs_40Act(uint64(l)) + l
	}
	if len(m.NormalBat) > 0 {
		for _, e := range m.NormalBat {
			l = e.Size()
			n += 1 + l + sovCGs_40Act(uint64(l))
		}
	}
	if len(m.Problems) > 0 {
		for _, e := range m.Problems {
			l = e.Size()
			n += 1 + l + sovCGs_40Act(uint64(l))
		}
	}
	if len(m.Shops) > 0 {
		for _, e := range m.Shops {
			l = e.Size()
			n += 1 + l + sovCGs_40Act(uint64(l))
		}
	}
	if len(m.HeroBat) > 0 {
		for _, e := range m.HeroBat {
			l = e.Size()
			n += 1 + l + sovCGs_40Act(uint64(l))
		}
	}
	if len(m.Attain) > 0 {
		for _, e := range m.Attain {
			l = e.Size()
			n += 1 + l + sovCGs_40Act(uint64(l))
		}
	}
	return n
}

func (m *ActMonolyShopItem) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Id))
	}
	if m.ExpireTs != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ExpireTs))
	}
	if m.DisCnt != 0 {
		n += 1 + sovCGs_40Act(uint64(m.DisCnt))
	}
	if len(m.AlreadyBuy) > 0 {
		l = 0
		for _, e := range m.AlreadyBuy {
			l += sovCGs_40Act(uint64(e))
		}
		n += 1 + sovCGs_40Act(uint64(l)) + l
	}
	return n
}

func (m *ActMonopolyAdvItem) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Id))
	}
	if m.ExpireTs != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ExpireTs))
	}
	return n
}

func (m *ActMonopolyBatItem) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Id))
	}
	if m.ExpireTs != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ExpireTs))
	}
	if m.HeroLv != 0 {
		n += 1 + sovCGs_40Act(uint64(m.HeroLv))
	}
	if m.MonsterLv != 0 {
		n += 1 + sovCGs_40Act(uint64(m.MonsterLv))
	}
	return n
}

func (m *GS_ActMonopolyObjValueChanged) Size() (n int) {
	var l int
	_ = l
	if m.OId != 0 {
		n += 1 + sovCGs_40Act(uint64(m.OId))
	}
	if m.Val != 0 {
		n += 9
	}
	return n
}

func (m *GS_ActMonoPolyNextLv) Size() (n int) {
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	return n
}

func (m *GS_ActMonopolyBoxReward) Size() (n int) {
	var l int
	_ = l
	if m.Rewards != nil {
		l = m.Rewards.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	return n
}

func (m *C_ActMonopolyInfo) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GS_ActMonoPolyInfo_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ErrorCode))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	return n
}

func (m *C_ActMonopolyNPos) Size() (n int) {
	var l int
	_ = l
	if m.Step != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Step))
	}
	return n
}

func (m *GS_ActMonopolyNPos_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ErrorCode))
	}
	if m.Step != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Step))
	}
	if len(m.NormalBat) > 0 {
		for _, e := range m.NormalBat {
			l = e.Size()
			n += 1 + l + sovCGs_40Act(uint64(l))
		}
	}
	if len(m.Problems) > 0 {
		for _, e := range m.Problems {
			l = e.Size()
			n += 1 + l + sovCGs_40Act(uint64(l))
		}
	}
	if len(m.Shops) > 0 {
		for _, e := range m.Shops {
			l = e.Size()
			n += 1 + l + sovCGs_40Act(uint64(l))
		}
	}
	if len(m.HeroBat) > 0 {
		for _, e := range m.HeroBat {
			l = e.Size()
			n += 1 + l + sovCGs_40Act(uint64(l))
		}
	}
	if m.Rewards != nil {
		l = m.Rewards.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	return n
}

func (m *C_ActMonopolyAnswer) Size() (n int) {
	var l int
	_ = l
	if m.Idx != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Idx))
	}
	if m.AnswerIdx != 0 {
		n += 1 + sovCGs_40Act(uint64(m.AnswerIdx))
	}
	return n
}

func (m *GS_ActMonopolyAnswer_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ErrorCode))
	}
	if m.Rewards != nil {
		l = m.Rewards.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	return n
}

func (m *C_ActMonopolyBuy) Size() (n int) {
	var l int
	_ = l
	if m.ShopIdx != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ShopIdx))
	}
	if m.ItemIdx != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ItemIdx))
	}
	return n
}

func (m *GS_ActMonopolyBuy_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ErrorCode))
	}
	if m.Rewards != nil {
		l = m.Rewards.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	return n
}

func (m *C_ActMonopolyBattle) Size() (n int) {
	var l int
	_ = l
	if m.Tp != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Tp))
	}
	if m.Idx != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Idx))
	}
	if m.T != nil {
		l = m.T.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	return n
}

func (m *GS_ActMonopolyBattle_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ErrorCode))
	}
	if m.Replay != nil {
		l = m.Replay.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	if m.Rewards != nil {
		l = m.Rewards.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	return n
}

func (m *C_ActMonopolyTaskTake) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Id))
	}
	return n
}

func (m *GS_ActMonopolyTaskTake_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ErrorCode))
	}
	if m.Rewards != nil {
		l = m.Rewards.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	return n
}

func (m *ActMazeData) Size() (n int) {
	var l int
	_ = l
	if m.Lv != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Lv))
	}
	if len(m.Clicked) > 0 {
		for k, v := range m.Clicked {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCGs_40Act(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovCGs_40Act(uint64(mapEntrySize))
		}
	}
	if len(m.Taken) > 0 {
		l = 0
		for _, e := range m.Taken {
			l += sovCGs_40Act(uint64(e))
		}
		n += 1 + sovCGs_40Act(uint64(l)) + l
	}
	if m.Score != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Score))
	}
	if len(m.Points) > 0 {
		for k, v := range m.Points {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCGs_40Act(uint64(k)) + 1 + sovCGs_40Act(uint64(v))
			n += mapEntrySize + 1 + sovCGs_40Act(uint64(mapEntrySize))
		}
	}
	if len(m.Box) > 0 {
		for k, v := range m.Box {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCGs_40Act(uint64(k)) + 1 + sovCGs_40Act(uint64(v))
			n += mapEntrySize + 1 + sovCGs_40Act(uint64(mapEntrySize))
		}
	}
	if len(m.Mine) > 0 {
		for k, v := range m.Mine {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCGs_40Act(uint64(k)) + 1 + sovCGs_40Act(uint64(v))
			n += mapEntrySize + 1 + sovCGs_40Act(uint64(mapEntrySize))
		}
	}
	if len(m.Item) > 0 {
		for k, v := range m.Item {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCGs_40Act(uint64(k)) + 1 + sovCGs_40Act(uint64(v))
			n += mapEntrySize + 1 + sovCGs_40Act(uint64(mapEntrySize))
		}
	}
	if len(m.Battle) > 0 {
		for k, v := range m.Battle {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCGs_40Act(uint64(l))
			}
			mapEntrySize := 1 + sovCGs_40Act(uint64(k)) + l
			n += mapEntrySize + 1 + sovCGs_40Act(uint64(mapEntrySize))
		}
	}
	if len(m.TradeLimit) > 0 {
		for k, v := range m.TradeLimit {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCGs_40Act(uint64(l))
			}
			mapEntrySize := 1 + sovCGs_40Act(uint64(k)) + l
			n += mapEntrySize + 1 + sovCGs_40Act(uint64(mapEntrySize))
		}
	}
	if len(m.Attain) > 0 {
		for _, e := range m.Attain {
			l = e.Size()
			n += 1 + l + sovCGs_40Act(uint64(l))
		}
	}
	return n
}

func (m *TradeData) Size() (n int) {
	var l int
	_ = l
	if len(m.Data) > 0 {
		for k, v := range m.Data {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCGs_40Act(uint64(k)) + 1 + sovCGs_40Act(uint64(v))
			n += mapEntrySize + 1 + sovCGs_40Act(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *BattleData) Size() (n int) {
	var l int
	_ = l
	if m.Lv != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Lv))
	}
	if m.Seq != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Seq))
	}
	if m.Tp != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Tp))
	}
	return n
}

func (m *GS_ActMazeObjValueChanged) Size() (n int) {
	var l int
	_ = l
	if m.OId != 0 {
		n += 1 + sovCGs_40Act(uint64(m.OId))
	}
	if m.Val != 0 {
		n += 9
	}
	return n
}

func (m *GS_ActMazeTaskTaken) Size() (n int) {
	var l int
	_ = l
	if len(m.Taken) > 0 {
		l = 0
		for _, e := range m.Taken {
			l += sovCGs_40Act(uint64(e))
		}
		n += 1 + sovCGs_40Act(uint64(l)) + l
	}
	return n
}

func (m *C_ActMazeInfo) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GS_ActMazeInfo_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ErrorCode))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	return n
}

func (m *C_ActMazeClick) Size() (n int) {
	var l int
	_ = l
	if m.Pos != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Pos))
	}
	return n
}

func (m *GS_ActMazeClick_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ErrorCode))
	}
	if m.Rewards != nil {
		l = m.Rewards.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	if m.Seq != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Seq))
	}
	if m.Battle != nil {
		l = m.Battle.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	if m.Score != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Score))
	}
	return n
}

func (m *C_ActMazeClickNext) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GS_ActMazeClickNext_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ErrorCode))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	return n
}

func (m *C_ActMazeClickTrade) Size() (n int) {
	var l int
	_ = l
	if m.Pos != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Pos))
	}
	if m.Seq != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Seq))
	}
	return n
}

func (m *GS_ActMazeClickTrade_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ErrorCode))
	}
	if m.Rewards != nil {
		l = m.Rewards.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	return n
}

func (m *C_ActMazeReset) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GS_ActMazeReset_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ErrorCode))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	return n
}

func (m *C_ActMazeClickThing) Size() (n int) {
	var l int
	_ = l
	if m.Pos != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Pos))
	}
	if m.ItemId != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ItemId))
	}
	return n
}

func (m *GS_ActMazeClickThing_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ErrorCode))
	}
	if m.Score != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Score))
	}
	if m.Rewards != nil {
		l = m.Rewards.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	return n
}

func (m *C_ActMazeClickBattle) Size() (n int) {
	var l int
	_ = l
	if m.Pos != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Pos))
	}
	if m.T != nil {
		l = m.T.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	if m.Seq != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Seq))
	}
	return n
}

func (m *GS_ActMazeClickBattle_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ErrorCode))
	}
	if m.Score != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Score))
	}
	if m.Replay != nil {
		l = m.Replay.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	if m.Rewards != nil {
		l = m.Rewards.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	return n
}

func (m *C_ActMazeTakeTask) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Id))
	}
	return n
}

func (m *GS_ActMazeTakeTask_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ErrorCode))
	}
	if m.Id != 0 {
		n += 1 + sovCGs_40Act(uint64(m.Id))
	}
	if m.Rewards != nil {
		l = m.Rewards.Size()
		n += 1 + l + sovCGs_40Act(uint64(l))
	}
	return n
}

func (m *C_ActMazeBuff) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GS_ActMazeBuff_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGs_40Act(uint64(m.ErrorCode))
	}
	if len(m.BuffIds) > 0 {
		for k, v := range m.BuffIds {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCGs_40Act(uint64(k)) + 1 + sovCGs_40Act(uint64(v))
			n += mapEntrySize + 1 + sovCGs_40Act(uint64(mapEntrySize))
		}
	}
	return n
}

func sovCGs_40Act(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCGs_40Act(x uint64) (n int) {
	return sovCGs_40Act(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ActAttainObj) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActAttainObj: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActAttainObj: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OId", wireType)
			}
			m.OId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Val = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActRushLocalRankData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActRushLocalRankData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActRushLocalRankData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankId", wireType)
			}
			m.RankId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Take", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Take = bool(v != 0)
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfScore", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.SelfScore = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachedScore", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CachedScore = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ActRushLocalGetInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ActRushLocalGetInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ActRushLocalGetInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankId", wireType)
			}
			m.RankId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActRushLocalGetInfo_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActRushLocalGetInfo_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActRushLocalGetInfo_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &ActRushLocalRankData{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ActRushLocalTake) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ActRushLocalTake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ActRushLocalTake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankId", wireType)
			}
			m.RankId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActRushLocalTake_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActRushLocalTake_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActRushLocalTake_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankId", wireType)
			}
			m.RankId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rewards == nil {
				m.Rewards = &Rewards{}
			}
			if err := m.Rewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActBillLtTotalData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActBillLtTotalData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActBillLtTotalData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Taken = append(m.Taken, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCGs_40Act
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Taken = append(m.Taken, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Taken", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActBillLtTotal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActBillLtTotal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActBillLtTotal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ActBillLtTotalInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ActBillLtTotalInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ActBillLtTotalInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActBillLtTotalInfo_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActBillLtTotalInfo_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActBillLtTotalInfo_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ActBillLtTotalData{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ActBillLtTotalTake) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ActBillLtTotalTake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ActBillLtTotalTake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActBillLtTotalTake_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActBillLtTotalTake_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActBillLtTotalTake_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rewards == nil {
				m.Rewards = &Rewards{}
			}
			if err := m.Rewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActBillLtDayData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActBillLtDayData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActBillLtDayData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Taken = append(m.Taken, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCGs_40Act
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Taken = append(m.Taken, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Taken", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BillDay", wireType)
			}
			m.BillDay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BillDay |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ActBillLtDayInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ActBillLtDayInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ActBillLtDayInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActBillLtDayInfo_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActBillLtDayInfo_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActBillLtDayInfo_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ActBillLtDayData{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ActBillLtDayTake) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ActBillLtDayTake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ActBillLtDayTake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActBillLtDayTake_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActBillLtDayTake_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActBillLtDayTake_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rewards == nil {
				m.Rewards = &Rewards{}
			}
			if err := m.Rewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActGiftNew) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActGiftNew: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActGiftNew: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rewards == nil {
				m.Rewards = &Rewards{}
			}
			if err := m.Rewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActSummonData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActSummonData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActSummonData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NormalCnt", wireType)
			}
			m.NormalCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NormalCnt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesireCnt", wireType)
			}
			m.DesireCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DesireCnt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiamCnt", wireType)
			}
			m.DiamCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiamCnt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpCnt", wireType)
			}
			m.UpCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpCnt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTs", wireType)
			}
			m.LastTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastTs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroPos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeroPos == nil {
				m.HeroPos = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCGs_40Act(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCGs_40Act
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.HeroPos[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActGift", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActGift == nil {
				m.ActGift = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCGs_40Act(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCGs_40Act
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ActGift[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ActSummonInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ActSummonInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ActSummonInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActSummonInfo_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActSummonInfo_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActSummonInfo_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ActSummonData{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ActSummonPick) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ActSummonPick: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ActSummonPick: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroPos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeroPos == nil {
				m.HeroPos = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCGs_40Act(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCGs_40Act
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.HeroPos[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActSummonPick_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActSummonPick_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActSummonPick_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ActSummonDraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ActSummonDraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ActSummonDraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDiam", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDiam = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			m.N = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.N |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActSummonDraw_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActSummonDraw_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActSummonDraw_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTs", wireType)
			}
			m.LastTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastTs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NormalCnt", wireType)
			}
			m.NormalCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NormalCnt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesireCnt", wireType)
			}
			m.DesireCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DesireCnt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpCnt", wireType)
			}
			m.UpCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpCnt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiamCnt", wireType)
			}
			m.DiamCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiamCnt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Item{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rewards == nil {
				m.Rewards = &Rewards{}
			}
			if err := m.Rewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActTargetTaskData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActTargetTaskData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActTargetTaskData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attain = append(m.Attain, &ActAttainObj{})
			if err := m.Attain[len(m.Attain)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Taken = append(m.Taken, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCGs_40Act
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Taken = append(m.Taken, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Taken", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActGift", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActGift == nil {
				m.ActGift = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCGs_40Act(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCGs_40Act
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ActGift[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActTargetTaskObjValueChanged) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActTargetTaskObjValueChanged: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActTargetTaskObjValueChanged: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OId", wireType)
			}
			m.OId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Val = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ActTargetTaskInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ActTargetTaskInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ActTargetTaskInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActTargetTaskInfo_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActTargetTaskInfo_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActTargetTaskInfo_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ActTargetTaskData{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ActTargetTaskTake) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ActTargetTaskTake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ActTargetTaskTake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActTargetTaskTake_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActTargetTaskTake_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActTargetTaskTake_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rewards == nil {
				m.Rewards = &Rewards{}
			}
			if err := m.Rewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActHeroSkinData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActHeroSkinData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActHeroSkinData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActGift", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActGift == nil {
				m.ActGift = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCGs_40Act(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCGs_40Act
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ActGift[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ActHeroSkinInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ActHeroSkinInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ActHeroSkinInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActHeroSkinInfo_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActHeroSkinInfo_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActHeroSkinInfo_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ActHeroSkinData{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActMSummonData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActMSummonData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActMSummonData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NormalCnt", wireType)
			}
			m.NormalCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NormalCnt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MagicCnt", wireType)
			}
			m.MagicCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MagicCnt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiamCnt", wireType)
			}
			m.DiamCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiamCnt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTs", wireType)
			}
			m.LastTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastTs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActGift", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActGift == nil {
				m.ActGift = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCGs_40Act(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCGs_40Act
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ActGift[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ActMSummonInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ActMSummonInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ActMSummonInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActMSummonInfo_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActMSummonInfo_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActMSummonInfo_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ActMSummonData{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ActMSummonDraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ActMSummonDraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ActMSummonDraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDiam", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDiam = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			m.N = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.N |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActMSummonDraw_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActMSummonDraw_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActMSummonDraw_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MagicCnt", wireType)
			}
			m.MagicCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MagicCnt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTs", wireType)
			}
			m.LastTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastTs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiamCnt", wireType)
			}
			m.DiamCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiamCnt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NormalCnt", wireType)
			}
			m.NormalCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NormalCnt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rewards == nil {
				m.Rewards = &Rewards{}
			}
			if err := m.Rewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActMonopolyData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActMonopolyData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActMonopolyData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatCnt", wireType)
			}
			m.RepeatCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RepeatCnt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvPosInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdvPosInfo == nil {
				m.AdvPosInfo = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCGs_40Act(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCGs_40Act
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AdvPosInfo[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TaskTaken = append(m.TaskTaken, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCGs_40Act
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TaskTaken = append(m.TaskTaken, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskTaken", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NormalBat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NormalBat = append(m.NormalBat, &ActMonopolyAdvItem{})
			if err := m.NormalBat[len(m.NormalBat)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Problems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Problems = append(m.Problems, &ActMonopolyAdvItem{})
			if err := m.Problems[len(m.Problems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shops", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shops = append(m.Shops, &ActMonolyShopItem{})
			if err := m.Shops[len(m.Shops)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroBat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeroBat = append(m.HeroBat, &ActMonopolyBatItem{})
			if err := m.HeroBat[len(m.HeroBat)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attain = append(m.Attain, &ActAttainObj{})
			if err := m.Attain[len(m.Attain)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActMonolyShopItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActMonolyShopItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActMonolyShopItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireTs", wireType)
			}
			m.ExpireTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireTs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisCnt", wireType)
			}
			m.DisCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DisCnt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AlreadyBuy = append(m.AlreadyBuy, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCGs_40Act
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AlreadyBuy = append(m.AlreadyBuy, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AlreadyBuy", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActMonopolyAdvItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActMonopolyAdvItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActMonopolyAdvItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireTs", wireType)
			}
			m.ExpireTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireTs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActMonopolyBatItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActMonopolyBatItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActMonopolyBatItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireTs", wireType)
			}
			m.ExpireTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireTs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroLv", wireType)
			}
			m.HeroLv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroLv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonsterLv", wireType)
			}
			m.MonsterLv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MonsterLv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActMonopolyObjValueChanged) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActMonopolyObjValueChanged: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActMonopolyObjValueChanged: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OId", wireType)
			}
			m.OId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Val = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActMonoPolyNextLv) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActMonoPolyNextLv: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActMonoPolyNextLv: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ActMonopolyData{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActMonopolyBoxReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActMonopolyBoxReward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActMonopolyBoxReward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rewards == nil {
				m.Rewards = &Rewards{}
			}
			if err := m.Rewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ActMonopolyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ActMonopolyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ActMonopolyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActMonoPolyInfo_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActMonoPolyInfo_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActMonoPolyInfo_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ActMonopolyData{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ActMonopolyNPos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ActMonopolyNPos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ActMonopolyNPos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			m.Step = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Step |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActMonopolyNPos_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActMonopolyNPos_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActMonopolyNPos_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			m.Step = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Step |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NormalBat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NormalBat = append(m.NormalBat, &ActMonopolyAdvItem{})
			if err := m.NormalBat[len(m.NormalBat)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Problems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Problems = append(m.Problems, &ActMonopolyAdvItem{})
			if err := m.Problems[len(m.Problems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shops", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shops = append(m.Shops, &ActMonolyShopItem{})
			if err := m.Shops[len(m.Shops)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroBat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeroBat = append(m.HeroBat, &ActMonopolyBatItem{})
			if err := m.HeroBat[len(m.HeroBat)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rewards == nil {
				m.Rewards = &Rewards{}
			}
			if err := m.Rewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ActMonopolyAnswer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ActMonopolyAnswer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ActMonopolyAnswer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnswerIdx", wireType)
			}
			m.AnswerIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnswerIdx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActMonopolyAnswer_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActMonopolyAnswer_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActMonopolyAnswer_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rewards == nil {
				m.Rewards = &Rewards{}
			}
			if err := m.Rewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ActMonopolyBuy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ActMonopolyBuy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ActMonopolyBuy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopIdx", wireType)
			}
			m.ShopIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopIdx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemIdx", wireType)
			}
			m.ItemIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemIdx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActMonopolyBuy_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActMonopolyBuy_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActMonopolyBuy_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rewards == nil {
				m.Rewards = &Rewards{}
			}
			if err := m.Rewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ActMonopolyBattle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ActMonopolyBattle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ActMonopolyBattle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tp", wireType)
			}
			m.Tp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field T", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.T == nil {
				m.T = &TeamFormation{}
			}
			if err := m.T.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActMonopolyBattle_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActMonopolyBattle_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActMonopolyBattle_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Replay == nil {
				m.Replay = &BattleReplay{}
			}
			if err := m.Replay.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rewards == nil {
				m.Rewards = &Rewards{}
			}
			if err := m.Rewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ActMonopolyTaskTake) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ActMonopolyTaskTake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ActMonopolyTaskTake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActMonopolyTaskTake_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActMonopolyTaskTake_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActMonopolyTaskTake_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rewards == nil {
				m.Rewards = &Rewards{}
			}
			if err := m.Rewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActMazeData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActMazeData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActMazeData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clicked", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Clicked == nil {
				m.Clicked = make(map[int32]bool)
			}
			var mapkey int32
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCGs_40Act(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCGs_40Act
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Clicked[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Taken = append(m.Taken, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCGs_40Act
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Taken = append(m.Taken, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Taken", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Points", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Points == nil {
				m.Points = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCGs_40Act(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCGs_40Act
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Points[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Box", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Box == nil {
				m.Box = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCGs_40Act(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCGs_40Act
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Box[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mine", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mine == nil {
				m.Mine = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCGs_40Act(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCGs_40Act
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Mine[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Item == nil {
				m.Item = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCGs_40Act(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCGs_40Act
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Item[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Battle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Battle == nil {
				m.Battle = make(map[int32]*BattleData)
			}
			var mapkey int32
			var mapvalue *BattleData
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCGs_40Act
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCGs_40Act
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &BattleData{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCGs_40Act(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCGs_40Act
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Battle[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeLimit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TradeLimit == nil {
				m.TradeLimit = make(map[int32]*TradeData)
			}
			var mapkey int32
			var mapvalue *TradeData
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCGs_40Act
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCGs_40Act
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TradeData{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCGs_40Act(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCGs_40Act
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TradeLimit[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attain = append(m.Attain, &ActAttainObj{})
			if err := m.Attain[len(m.Attain)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradeData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradeData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradeData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCGs_40Act(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCGs_40Act
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Data[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BattleData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BattleData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BattleData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tp", wireType)
			}
			m.Tp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActMazeObjValueChanged) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActMazeObjValueChanged: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActMazeObjValueChanged: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OId", wireType)
			}
			m.OId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Val = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActMazeTaskTaken) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActMazeTaskTaken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActMazeTaskTaken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Taken = append(m.Taken, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCGs_40Act
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Taken = append(m.Taken, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Taken", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ActMazeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ActMazeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ActMazeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActMazeInfo_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActMazeInfo_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActMazeInfo_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ActMazeData{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ActMazeClick) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ActMazeClick: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ActMazeClick: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActMazeClick_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActMazeClick_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActMazeClick_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rewards == nil {
				m.Rewards = &Rewards{}
			}
			if err := m.Rewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Battle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Battle == nil {
				m.Battle = &BattleData{}
			}
			if err := m.Battle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ActMazeClickNext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ActMazeClickNext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ActMazeClickNext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActMazeClickNext_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActMazeClickNext_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActMazeClickNext_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ActMazeData{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ActMazeClickTrade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ActMazeClickTrade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ActMazeClickTrade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActMazeClickTrade_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActMazeClickTrade_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActMazeClickTrade_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rewards == nil {
				m.Rewards = &Rewards{}
			}
			if err := m.Rewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ActMazeReset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ActMazeReset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ActMazeReset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActMazeReset_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActMazeReset_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActMazeReset_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ActMazeData{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ActMazeClickThing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ActMazeClickThing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ActMazeClickThing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActMazeClickThing_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActMazeClickThing_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActMazeClickThing_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rewards == nil {
				m.Rewards = &Rewards{}
			}
			if err := m.Rewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ActMazeClickBattle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ActMazeClickBattle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ActMazeClickBattle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field T", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.T == nil {
				m.T = &TeamFormation{}
			}
			if err := m.T.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActMazeClickBattle_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActMazeClickBattle_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActMazeClickBattle_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Replay == nil {
				m.Replay = &BattleReplay{}
			}
			if err := m.Replay.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rewards == nil {
				m.Rewards = &Rewards{}
			}
			if err := m.Rewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ActMazeTakeTask) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ActMazeTakeTask: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ActMazeTakeTask: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActMazeTakeTask_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActMazeTakeTask_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActMazeTakeTask_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rewards == nil {
				m.Rewards = &Rewards{}
			}
			if err := m.Rewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ActMazeBuff) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ActMazeBuff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ActMazeBuff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GS_ActMazeBuff_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GS_ActMazeBuff_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GS_ActMazeBuff_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BuffIds == nil {
				m.BuffIds = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGs_40Act
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCGs_40Act(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCGs_40Act
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BuffIds[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGs_40Act(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGs_40Act
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCGs_40Act(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCGs_40Act
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCGs_40Act
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCGs_40Act
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCGs_40Act
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCGs_40Act(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCGs_40Act = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCGs_40Act   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("c_gs.40.act.proto", fileDescriptorCGs_40Act) }

var fileDescriptorCGs_40Act = []byte{
	// 2212 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x5a, 0xcd, 0x77, 0x1b, 0x57,
	0x15, 0xef, 0x68, 0x24, 0xd9, 0xbe, 0x76, 0xfc, 0x31, 0xb1, 0x1d, 0xc5, 0x27, 0x75, 0xcc, 0x34,
	0x6d, 0x1c, 0x52, 0x74, 0x82, 0x1b, 0x48, 0x93, 0x52, 0x1a, 0x49, 0x76, 0x82, 0x38, 0x96, 0xe3,
	0x33, 0x12, 0xe1, 0x40, 0x4b, 0xd3, 0xb1, 0xf4, 0x2c, 0xab, 0x1a, 0x69, 0xd4, 0x99, 0x67, 0xd9,
	0xca, 0x8e, 0x25, 0x6c, 0xe0, 0x0f, 0x60, 0xc1, 0x82, 0x15, 0xff, 0x03, 0x6b, 0xba, 0x83, 0x3f,
	0x01, 0xc2, 0x9e, 0x15, 0x7b, 0x7a, 0xde, 0xe7, 0xbc, 0xf9, 0xb0, 0xa4, 0x71, 0xdd, 0x4d, 0x8e,
	0xdf, 0x7d, 0xf7, 0xdd, 0x7b, 0xdf, 0xef, 0x7e, 0xbe, 0x51, 0x60, 0xa5, 0xf9, 0xaa, 0xed, 0x17,
	0x1f, 0x3e, 0x28, 0xda, 0x4d, 0x5c, 0x1c, 0x78, 0x2e, 0x76, 0x0d, 0xbd, 0xe7, 0xb7, 0x37, 0xa0,
	0xed, 0xb6, 0x5d, 0x46, 0xd8, 0x58, 0xa3, 0x3c, 0x0f, 0x1e, 0x14, 0x7d, 0xec, 0x9d, 0x36, 0xb1,
	0xcf, 0xc8, 0xe6, 0x0e, 0x2c, 0x94, 0x9a, 0xb8, 0x84, 0xb1, 0xdd, 0xe9, 0xbf, 0x38, 0xfa, 0xd2,
	0x58, 0x06, 0xfd, 0x45, 0xb5, 0x55, 0xd0, 0xb6, 0xb4, 0xed, 0x9c, 0x45, 0xfe, 0x24, 0x94, 0x97,
	0xb6, 0x53, 0xc8, 0x6c, 0x69, 0xdb, 0x9a, 0x45, 0xfe, 0x34, 0xff, 0xa4, 0xc1, 0x6a, 0xa9, 0x89,
	0xad, 0x53, 0xff, 0x64, 0xdf, 0x6d, 0xda, 0x8e, 0x65, 0xf7, 0xbb, 0xbb, 0x36, 0xb6, 0x8d, 0x02,
	0xcc, 0x94, 0x9a, 0xf8, 0xc0, 0xee, 0x21, 0x2a, 0x60, 0xce, 0x12, 0x4b, 0x63, 0x1d, 0xf2, 0x84,
	0xab, 0xda, 0xa2, 0x72, 0x72, 0x16, 0x5f, 0x19, 0x06, 0x64, 0x1b, 0x76, 0x17, 0x15, 0xf4, 0x2d,
	0x6d, 0x7b, 0xd6, 0xa2, 0x7f, 0x1b, 0xb7, 0x60, 0xae, 0x8e, 0x9c, 0xe3, 0x7a, 0xd3, 0xf5, 0x50,
	0x21, 0x4b, 0xd5, 0x06, 0x04, 0x63, 0x0b, 0xe6, 0x2b, 0x76, 0xf3, 0x04, 0xb5, 0xd8, 0x7e, 0x8e,
	0xee, 0xab, 0x24, 0xb3, 0x0a, 0x6b, 0x95, 0x57, 0xaa, 0x7d, 0xcf, 0x11, 0xae, 0xf6, 0x8f, 0xdd,
	0xf4, 0xe6, 0x99, 0x6d, 0x28, 0x3c, 0xaf, 0x27, 0xc9, 0x7a, 0x65, 0x11, 0x33, 0xf7, 0x3c, 0xcf,
	0xf5, 0x2a, 0x6e, 0x0b, 0x71, 0xbc, 0x02, 0x82, 0xf1, 0x03, 0xc8, 0x12, 0x48, 0x0a, 0x99, 0x2d,
	0x7d, 0x7b, 0x7e, 0xe7, 0x66, 0xb1, 0xe7, 0xb7, 0x8b, 0x49, 0x98, 0x59, 0x94, 0xcd, 0x7c, 0x06,
	0x46, 0xd8, 0x66, 0x8a, 0x44, 0x7a, 0x83, 0xff, 0xa0, 0xc1, 0x5a, 0xc4, 0x62, 0x22, 0x69, 0xa2,
	0xb9, 0x8a, 0xa6, 0xcc, 0x45, 0x9a, 0xf4, 0x90, 0xe7, 0xde, 0x83, 0x19, 0x0b, 0x9d, 0xd9, 0x5e,
	0xcb, 0xa7, 0x3e, 0x9a, 0xdf, 0x59, 0xa0, 0x77, 0xe4, 0x34, 0x4b, 0x6c, 0x9a, 0x4f, 0xc1, 0x28,
	0x35, 0x71, 0xb9, 0xe3, 0x38, 0xfb, 0xb8, 0xe1, 0x62, 0xdb, 0xa1, 0x91, 0xb2, 0x0a, 0x39, 0xba,
	0xa0, 0x96, 0xe8, 0x16, 0x5b, 0x50, 0xaa, 0xdd, 0x45, 0x7d, 0x8a, 0x5a, 0xce, 0x62, 0x0b, 0xf3,
	0x1e, 0xac, 0xb0, 0x2b, 0x29, 0x42, 0x92, 0x05, 0x98, 0xeb, 0xb0, 0x5a, 0x89, 0x70, 0x12, 0x6f,
	0x99, 0x2d, 0xb8, 0x11, 0x13, 0x31, 0x95, 0x1b, 0xef, 0x4b, 0x37, 0x92, 0x2b, 0xde, 0x10, 0x6e,
	0x8c, 0x5c, 0x87, 0x3b, 0xf1, 0xbd, 0xb8, 0x76, 0xea, 0xc6, 0x45, 0xc8, 0xc8, 0x94, 0xca, 0x54,
	0x5b, 0xa6, 0x9b, 0x60, 0xcd, 0x54, 0x5e, 0x62, 0x82, 0x32, 0x42, 0x90, 0xea, 0x03, 0x7d, 0x9c,
	0x0f, 0xca, 0xb0, 0x2c, 0xb5, 0xed, 0xda, 0x23, 0xe9, 0x01, 0x8a, 0xb5, 0xa6, 0x60, 0x4d, 0xe2,
	0x80, 0xb0, 0xed, 0xda, 0x23, 0xae, 0x46, 0x2c, 0xcd, 0x55, 0x1e, 0xa1, 0x52, 0x0a, 0x05, 0xf6,
	0x0b, 0x11, 0x6e, 0x21, 0xf2, 0xc4, 0x8b, 0xdc, 0x0b, 0xc1, 0xba, 0x16, 0x86, 0x95, 0x5b, 0xc8,
	0x41, 0xbd, 0x13, 0xd5, 0x9b, 0x08, 0xe9, 0x6f, 0x62, 0x76, 0x4c, 0x05, 0xa8, 0x02, 0x60, 0x66,
	0x1c, 0x80, 0xcf, 0xe1, 0x1a, 0x13, 0xff, 0xbc, 0x73, 0x8c, 0x0f, 0xd0, 0x59, 0x54, 0xff, 0xd4,
	0x82, 0x7e, 0xab, 0xc3, 0xb5, 0x52, 0x13, 0xd7, 0x4f, 0x7b, 0x3d, 0xb7, 0x4f, 0xfd, 0x70, 0x0b,
	0xe6, 0x0e, 0x5c, 0xaf, 0x67, 0x3b, 0x95, 0x3e, 0x16, 0x06, 0x4a, 0x02, 0xd9, 0xdd, 0x45, 0x7e,
	0xc7, 0x43, 0x64, 0x97, 0x79, 0x24, 0x20, 0x10, 0x6f, 0xed, 0x76, 0xec, 0x1e, 0xd9, 0x63, 0xc9,
	0x29, 0x96, 0xc4, 0xbb, 0xbf, 0x18, 0x10, 0x7a, 0x96, 0xd2, 0xd9, 0x82, 0xe4, 0xf2, 0xbe, 0xed,
	0xe3, 0x86, 0x4f, 0xcb, 0xa6, 0x6e, 0xf1, 0x95, 0xf1, 0x18, 0x66, 0x7e, 0x86, 0x3c, 0xf7, 0xd0,
	0xf5, 0x0b, 0x79, 0x5a, 0xaf, 0x6e, 0x0b, 0x8f, 0x04, 0x86, 0x16, 0x39, 0xc7, 0x5e, 0x1f, 0x7b,
	0x23, 0x4b, 0xf0, 0x93, 0xa3, 0x1c, 0x96, 0xc2, 0xcc, 0x85, 0x47, 0x39, 0x07, 0x3f, 0xca, 0x57,
	0x1b, 0x4f, 0x60, 0x41, 0x95, 0x49, 0x1a, 0x4d, 0x17, 0x8d, 0x44, 0xeb, 0xe9, 0xa2, 0x11, 0xb9,
	0xc5, 0xd0, 0x76, 0x4e, 0x11, 0xbf, 0x39, 0x5b, 0x3c, 0xc9, 0x7c, 0xa8, 0x91, 0xb3, 0xaa, 0xd0,
	0x34, 0x67, 0xcd, 0x15, 0x58, 0xa2, 0x11, 0xc5, 0x0c, 0xa4, 0x61, 0xfc, 0x6b, 0x30, 0x98, 0x7f,
	0x03, 0xda, 0x14, 0xb1, 0xa3, 0xc6, 0xb0, 0x11, 0xbf, 0x36, 0x0f, 0xe0, 0xdf, 0x6b, 0x21, 0x7d,
	0x87, 0x9d, 0x66, 0xd7, 0xf8, 0x28, 0x00, 0x5c, 0xa3, 0xa8, 0x7d, 0x8f, 0x1e, 0x8f, 0xb0, 0x25,
	0x43, 0xfe, 0x6d, 0x70, 0x33, 0x77, 0xc2, 0x17, 0x25, 0x5a, 0x26, 0x5d, 0xd4, 0x7c, 0x14, 0xb2,
	0x7f, 0xd7, 0xb3, 0xcf, 0x48, 0x20, 0x55, 0x7d, 0x12, 0x6b, 0x94, 0x7b, 0xd6, 0xe2, 0x2b, 0x63,
	0x01, 0xb4, 0x03, 0xae, 0x54, 0x3b, 0x30, 0xff, 0xaf, 0x85, 0xb5, 0x91, 0xa3, 0x13, 0x61, 0x0d,
	0x62, 0x34, 0x13, 0x8a, 0xd1, 0x50, 0x9e, 0xe8, 0x63, 0xf3, 0x24, 0x1b, 0xcd, 0x13, 0x99, 0x0d,
	0x39, 0x35, 0x1b, 0x94, 0xec, 0xc9, 0x87, 0xb3, 0xe7, 0x36, 0xe4, 0xaa, 0x18, 0xf5, 0x7c, 0x1e,
	0xd2, 0x73, 0xd4, 0x39, 0x84, 0x62, 0x31, 0xba, 0x9a, 0xee, 0xb3, 0xe3, 0xd2, 0xfd, 0x1f, 0x1a,
	0xac, 0x94, 0x9a, 0xb8, 0x61, 0x7b, 0x6d, 0x84, 0x1b, 0xb6, 0xcf, 0xc6, 0xa4, 0x7b, 0x90, 0x67,
	0x03, 0x17, 0x77, 0xfe, 0x8a, 0x88, 0x1d, 0x39, 0x86, 0x59, 0x9c, 0x21, 0xb9, 0x23, 0x1a, 0x1f,
	0x07, 0x49, 0xa7, 0x53, 0x09, 0xef, 0x08, 0x09, 0x61, 0x4d, 0x17, 0x27, 0xde, 0xa5, 0x93, 0x67,
	0x0f, 0x6e, 0x33, 0x97, 0x06, 0x9a, 0x5e, 0x1c, 0x7d, 0xf9, 0x92, 0xec, 0x57, 0x4e, 0xec, 0x7e,
	0x1b, 0xb5, 0xa6, 0x1a, 0x21, 0xd7, 0xe0, 0x7a, 0x25, 0x2c, 0x85, 0xe6, 0xe1, 0x11, 0xac, 0x47,
	0xa5, 0x4f, 0x95, 0x8b, 0xdf, 0x0f, 0xe5, 0xe2, 0x7a, 0x32, 0x1a, 0x3c, 0x1f, 0xdf, 0x8d, 0xa9,
	0x4e, 0xec, 0x28, 0x9f, 0xc7, 0x4d, 0x49, 0xdb, 0x52, 0xc6, 0xf6, 0x64, 0x52, 0x16, 0x4a, 0x4d,
	0x4c, 0x32, 0xb9, 0xde, 0xed, 0xb0, 0x5e, 0xf0, 0x51, 0xe0, 0x57, 0xb5, 0x2c, 0x44, 0xd8, 0xbe,
	0x03, 0xaf, 0x5e, 0x87, 0x15, 0x8a, 0x89, 0x50, 0x43, 0x9d, 0xf1, 0x39, 0xac, 0x32, 0x04, 0x54,
	0xea, 0xc4, 0xfb, 0x6f, 0x87, 0x5c, 0xb1, 0x9a, 0x74, 0x01, 0xee, 0x88, 0xff, 0x69, 0xb0, 0x58,
	0x6a, 0xe2, 0xda, 0xd4, 0xcd, 0x70, 0x03, 0x66, 0x6b, 0x76, 0xbb, 0xd3, 0x0c, 0x7a, 0xa1, 0x5c,
	0x8f, 0x69, 0x85, 0x41, 0x41, 0xc9, 0x86, 0x0a, 0xca, 0x93, 0x00, 0xec, 0x1c, 0x05, 0x7b, 0x4b,
	0xd8, 0x5a, 0x9b, 0xa6, 0x75, 0x5d, 0x1a, 0x6b, 0x03, 0x96, 0x29, 0xd6, 0x35, 0xa5, 0xff, 0x7c,
	0x06, 0xd7, 0x19, 0xd4, 0xb5, 0x14, 0x0d, 0xe8, 0x6e, 0x08, 0xe9, 0xeb, 0x09, 0xd6, 0x73, 0xa0,
	0x3f, 0x0c, 0x6b, 0x4c, 0x51, 0xc1, 0xff, 0xae, 0x45, 0x0c, 0x9b, 0xaa, 0x84, 0x8f, 0xf3, 0x53,
	0xe0, 0x0d, 0x3d, 0xe4, 0x0d, 0xc5, 0x7f, 0xd9, 0xb0, 0xff, 0x42, 0x31, 0x91, 0x8b, 0xc6, 0x84,
	0x92, 0x6e, 0xf9, 0x71, 0xe9, 0xf6, 0x5f, 0x9d, 0xa6, 0x5b, 0xcd, 0xed, 0xbb, 0x03, 0xd7, 0x61,
	0x23, 0xf0, 0x32, 0xe8, 0x75, 0xf4, 0x95, 0xf0, 0x5a, 0x1d, 0x7d, 0x45, 0x28, 0xa4, 0x27, 0x33,
	0xa3, 0xc9, 0x9f, 0x44, 0xbb, 0x85, 0x06, 0xc8, 0xc6, 0x4a, 0xdb, 0x91, 0x04, 0x63, 0x17, 0xa0,
	0xd4, 0x1a, 0x1e, 0xba, 0x3e, 0x71, 0x58, 0x21, 0x4b, 0xc3, 0xe8, 0x8e, 0x74, 0x84, 0xa2, 0xab,
	0x18, 0xb0, 0xb1, 0x50, 0x52, 0xce, 0x11, 0x1d, 0xa2, 0xbc, 0xf4, 0x69, 0x2c, 0xe6, 0xac, 0x80,
	0x60, 0xfc, 0x48, 0xdc, 0xbf, 0x6c, 0x63, 0x3e, 0x9e, 0xdd, 0x88, 0xaa, 0x28, 0xb5, 0x86, 0xb4,
	0x3d, 0x05, 0x9c, 0xc6, 0x07, 0x30, 0x7b, 0xe8, 0xb9, 0x47, 0x4e, 0xd0, 0xc6, 0x2e, 0x3c, 0x25,
	0x19, 0x8d, 0xf7, 0x21, 0x57, 0x3f, 0x71, 0x07, 0xa4, 0xab, 0xe9, 0x6a, 0x21, 0x25, 0x27, 0x9c,
	0x11, 0xd9, 0x62, 0x5d, 0x90, 0x32, 0x19, 0x3f, 0x64, 0x53, 0x0c, 0xb1, 0x6b, 0x2e, 0x59, 0x43,
	0xd9, 0xc6, 0xf4, 0x80, 0xe0, 0x53, 0x5a, 0x1f, 0x4c, 0x68, 0x7d, 0x1b, 0x1f, 0xc3, 0x52, 0x04,
	0xb4, 0x54, 0x69, 0x76, 0x46, 0x3b, 0x6f, 0xd8, 0xf0, 0xd8, 0xd8, 0xbe, 0x01, 0xb3, 0x7b, 0xe7,
	0x83, 0x8e, 0x87, 0xe4, 0xb8, 0x21, 0xd7, 0x24, 0x52, 0x77, 0x3b, 0x7e, 0xe0, 0x76, 0xbe, 0x32,
	0x36, 0x01, 0x4a, 0x8e, 0x87, 0xec, 0xd6, 0xa8, 0x7c, 0x3a, 0xa2, 0x3e, 0xcf, 0x59, 0x0a, 0x85,
	0x3f, 0x78, 0x23, 0x18, 0xa7, 0xd1, 0x6c, 0x0e, 0x43, 0x12, 0x38, 0x86, 0x69, 0x6d, 0x27, 0x88,
	0xef, 0x0f, 0x85, 0xed, 0x6c, 0x45, 0x22, 0xad, 0xe6, 0xf6, 0x7d, 0x8c, 0xbc, 0xfd, 0xa1, 0x18,
	0x93, 0x24, 0xc1, 0xac, 0xc0, 0xdb, 0x3c, 0xd9, 0xb9, 0xea, 0xcb, 0x74, 0xf6, 0xa7, 0xa2, 0x6b,
	0x10, 0x21, 0x87, 0xae, 0x33, 0x3a, 0x40, 0xe7, 0x78, 0x7f, 0x78, 0x51, 0x5f, 0x50, 0x93, 0x84,
	0x97, 0xab, 0x92, 0x78, 0x1e, 0x4b, 0x04, 0xdc, 0x73, 0x96, 0xc6, 0x53, 0x3f, 0xb3, 0x44, 0x3f,
	0x13, 0x12, 0xc2, 0xfd, 0x4c, 0x58, 0xf6, 0x6d, 0xfa, 0x59, 0x82, 0xdd, 0x77, 0x23, 0x4a, 0x0f,
	0x48, 0xfd, 0x30, 0x20, 0x5b, 0xc7, 0x68, 0xc0, 0xe5, 0xd2, 0xbf, 0xcd, 0xbf, 0x65, 0x54, 0x4b,
	0x04, 0xeb, 0x44, 0x4b, 0x84, 0xa8, 0x4c, 0x20, 0x2a, 0x5c, 0x1c, 0xf4, 0x4b, 0x15, 0x87, 0x6c,
	0xea, 0xe2, 0x90, 0x4b, 0x59, 0x1c, 0xf2, 0x53, 0x16, 0x07, 0xc5, 0xbb, 0x33, 0xe3, 0xbc, 0xbb,
	0xc7, 0x27, 0x38, 0x69, 0x6a, 0xdf, 0x3f, 0x43, 0x1e, 0x89, 0xc5, 0x6a, 0xeb, 0x5c, 0x44, 0x67,
	0xb5, 0x75, 0x4e, 0xf0, 0x64, 0x7b, 0x84, 0xce, 0x5f, 0xcf, 0x92, 0x10, 0x4c, 0x78, 0x61, 0x39,
	0x57, 0xf6, 0xd1, 0xe0, 0x99, 0x68, 0xbb, 0xe2, 0xbe, 0xa7, 0x23, 0xd2, 0xe6, 0x28, 0x50, 0xd2,
	0x4e, 0xb1, 0x24, 0x3b, 0x04, 0x8d, 0xc0, 0x52, 0xb1, 0x34, 0x3f, 0x95, 0x3d, 0x38, 0x10, 0x74,
	0x65, 0x46, 0xfe, 0x2a, 0x82, 0x65, 0xd9, 0xc6, 0xd8, 0xa1, 0xd3, 0x70, 0x43, 0x04, 0x6d, 0xa6,
	0x31, 0x10, 0xd8, 0x66, 0x02, 0x6c, 0xb7, 0x40, 0x6b, 0xf0, 0x09, 0x97, 0xbd, 0x7d, 0x1b, 0xc8,
	0xee, 0x3d, 0x23, 0x11, 0x86, 0x3b, 0x6e, 0xdf, 0xd2, 0x1a, 0xe6, 0xef, 0xb4, 0x28, 0xc0, 0x4c,
	0xf8, 0x14, 0x5f, 0x87, 0xf2, 0x16, 0x1a, 0x38, 0xfc, 0x1b, 0x94, 0x68, 0x12, 0xec, 0x30, 0xdb,
	0xb0, 0x38, 0xc3, 0xd4, 0xd3, 0xf6, 0x5d, 0xfe, 0x4d, 0x58, 0x58, 0x72, 0xe1, 0xd8, 0xff, 0x85,
	0xf8, 0xe2, 0x1b, 0xe5, 0xbc, 0x32, 0xc4, 0xff, 0x32, 0x03, 0xf3, 0x44, 0xbe, 0xfd, 0x1a, 0xd1,
	0x29, 0x64, 0x11, 0x32, 0xfb, 0x43, 0x61, 0xc1, 0xfe, 0xd0, 0x78, 0x04, 0x33, 0x15, 0xa7, 0xd3,
	0xec, 0xa2, 0x16, 0xff, 0x78, 0xfc, 0xb6, 0x4c, 0x1c, 0x7e, 0xa4, 0xc8, 0xf7, 0xf9, 0x50, 0xca,
	0x57, 0xc1, 0x5b, 0x51, 0x57, 0xdf, 0x8a, 0xab, 0x90, 0x0b, 0xbe, 0xa4, 0xe7, 0x2c, 0xb6, 0x30,
	0x1e, 0x42, 0xfe, 0xd0, 0xed, 0xf4, 0xb1, 0x48, 0xe6, 0x5b, 0x31, 0x1d, 0x6c, 0x9b, 0xa9, 0xe0,
	0xbc, 0xc6, 0x7d, 0xd0, 0xcb, 0xee, 0x39, 0xcf, 0xe7, 0x9b, 0xb1, 0x23, 0x65, 0xf7, 0x9c, 0xf1,
	0x13, 0x2e, 0xa3, 0x08, 0xd9, 0x5a, 0xa7, 0x8f, 0xf8, 0xf0, 0xb1, 0x11, 0xe3, 0x26, 0x9b, 0x8c,
	0x9d, 0xf2, 0x11, 0x7e, 0x12, 0xf1, 0x7c, 0xf4, 0x88, 0xf3, 0x93, 0x4d, 0xce, 0x4f, 0xfb, 0xe1,
	0x43, 0xc8, 0xb3, 0x90, 0xe0, 0xc3, 0x47, 0xfc, 0x0a, 0x6c, 0x9b, 0x5f, 0x81, 0x07, 0xf6, 0x53,
	0x80, 0x86, 0x67, 0xb7, 0xd0, 0x7e, 0xa7, 0xd7, 0xc1, 0x7c, 0x08, 0xd9, 0x8a, 0x9d, 0x0c, 0x58,
	0xf8, 0xb4, 0x16, 0x10, 0x94, 0x11, 0x66, 0x7e, 0xd2, 0x08, 0xf3, 0x04, 0x16, 0x54, 0x57, 0x4d,
	0x9a, 0x5f, 0x66, 0xd5, 0x2f, 0x5c, 0x8f, 0x61, 0x5e, 0x71, 0x41, 0xaa, 0x8f, 0x63, 0x3f, 0x86,
	0x59, 0xe1, 0x8a, 0x54, 0xe7, 0x1e, 0xc1, 0x9c, 0x74, 0x4a, 0xda, 0x83, 0xd2, 0x3b, 0xa9, 0x0e,
	0xfe, 0x1c, 0xe6, 0x15, 0x27, 0x25, 0x1c, 0x7d, 0x57, 0x3d, 0x3a, 0xbf, 0xb3, 0xa4, 0x54, 0x02,
	0xda, 0x79, 0x15, 0x59, 0x35, 0x58, 0x8a, 0xb8, 0x2d, 0x41, 0xde, 0x9d, 0xb0, 0xbc, 0x45, 0x56,
	0xb9, 0xc8, 0xb1, 0x88, 0x38, 0xd3, 0x83, 0x39, 0x49, 0x37, 0xde, 0xe7, 0x43, 0x00, 0x7b, 0x95,
	0x17, 0xc2, 0xa7, 0x8a, 0xe4, 0x1f, 0x1e, 0x99, 0xe4, 0x4f, 0x02, 0x87, 0x24, 0xa5, 0x9a, 0x59,
	0x7f, 0x0a, 0x10, 0xdc, 0x2d, 0x56, 0x18, 0xf8, 0x73, 0x25, 0x13, 0x3c, 0x57, 0x58, 0x95, 0xd6,
	0x45, 0x95, 0x36, 0x3f, 0x81, 0x9b, 0xbc, 0x78, 0xd9, 0xaf, 0xd1, 0x65, 0x86, 0xb7, 0xfb, 0xb2,
	0xd5, 0xd8, 0xaf, 0x51, 0xf0, 0x04, 0x49, 0xfc, 0xad, 0xc0, 0x5c, 0x82, 0x6b, 0x15, 0xc1, 0x4b,
	0x07, 0xac, 0x97, 0xb0, 0x1c, 0x9c, 0x9e, 0x6a, 0xb8, 0xba, 0x13, 0x1a, 0xae, 0x96, 0xa3, 0x79,
	0xc8, 0x07, 0x2b, 0x13, 0x16, 0xa5, 0x22, 0x9a, 0x4f, 0xe2, 0x9d, 0xa6, 0xc9, 0x77, 0x9a, 0xf9,
	0x57, 0x4d, 0xfc, 0x4a, 0x24, 0xb9, 0xae, 0xaa, 0x62, 0x0b, 0xe0, 0xf5, 0x00, 0xf8, 0xbb, 0xb2,
	0xf6, 0x64, 0x93, 0xe3, 0x52, 0x94, 0x1b, 0x59, 0x7d, 0x73, 0x4a, 0xf5, 0x95, 0xbf, 0xa5, 0x48,
	0x53, 0xc9, 0x8c, 0x6c, 0x7e, 0x2a, 0x7e, 0xc3, 0x08, 0x91, 0xaf, 0x08, 0xc3, 0xc7, 0xa2, 0xcf,
	0x0b, 0xd9, 0x34, 0x7c, 0xe3, 0x40, 0xc6, 0xa3, 0x4c, 0x99, 0x93, 0x42, 0x67, 0xaf, 0xac, 0x21,
	0x2e, 0x2b, 0xee, 0xb5, 0x90, 0x8f, 0xb0, 0xf9, 0x4b, 0xd5, 0x97, 0x94, 0x74, 0x45, 0x28, 0x7c,
	0x12, 0x43, 0xe1, 0xa4, 0xd3, 0x6f, 0x27, 0xa0, 0xb0, 0x0e, 0x79, 0x36, 0x7e, 0x89, 0xdf, 0x57,
	0xd9, 0xca, 0xc4, 0x71, 0x2c, 0x88, 0x84, 0x89, 0xe6, 0xc9, 0x38, 0xc8, 0xa8, 0x5d, 0x78, 0xda,
	0xe9, 0xe5, 0x33, 0xfe, 0xc3, 0xa2, 0x54, 0xca, 0xa3, 0x2b, 0x6e, 0x37, 0x9d, 0xca, 0x32, 0x63,
	0xa6, 0xb2, 0x78, 0x30, 0x9b, 0x7f, 0xd6, 0xe4, 0x83, 0x2b, 0x2c, 0xff, 0x92, 0xb7, 0x0a, 0xc6,
	0x37, 0x3d, 0xc5, 0xf8, 0x36, 0xf6, 0x47, 0xe4, 0x77, 0xc4, 0xd3, 0x8a, 0x96, 0xa5, 0x2e, 0x2d,
	0x4d, 0xb1, 0xd1, 0xcd, 0x91, 0xaf, 0x2a, 0x85, 0xeb, 0x3b, 0xfb, 0x4d, 0x55, 0xad, 0x7e, 0xe5,
	0xd3, 0xe3, 0x63, 0x52, 0x81, 0x94, 0xf2, 0x47, 0x48, 0x13, 0x75, 0xff, 0x04, 0x66, 0x08, 0x5f,
	0x95, 0x66, 0x08, 0xe9, 0x2c, 0x26, 0xd5, 0x15, 0x95, 0x52, 0xe4, 0x4c, 0x7c, 0xde, 0xe3, 0x2b,
	0x32, 0x5d, 0xa8, 0x1b, 0x69, 0x3a, 0x4d, 0x79, 0xf5, 0xeb, 0x7f, 0x6f, 0xbe, 0xf5, 0xf5, 0x9b,
	0x4d, 0xed, 0x9f, 0x6f, 0x36, 0xb5, 0x7f, 0xbd, 0xd9, 0xd4, 0xfe, 0xf8, 0x9f, 0xcd, 0xb7, 0x8e,
	0xf2, 0xf4, 0xff, 0x84, 0x7c, 0xf0, 0x4d, 0x00, 0x00, 0x00, 0xff, 0xff, 0x23, 0x08, 0x67, 0xba,
	0x50, 0x22, 0x00, 0x00,
}
