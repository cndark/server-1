// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: c_gw.01.login.proto

/*
	Package msg is a generated protocol buffer package.

	It is generated from these files:
		c_gw.01.login.proto
		c_gs.00.structs.proto
		c_gs.01.aibot.proto
		c_gs.10.login.proto
		c_gs.11.plr.proto
		c_gs.12-1.bag.proto
		c_gs.12-2.item.proto
		c_gs.12-3.hero.proto
		c_gs.12-4.relic.proto
		c_gs.13.mail.proto
		c_gs.14.cloud.proto
		c_gs.15.tutorial.proto
		c_gs.16.act.proto
		c_gs.17.attaintab.proto
		c_gs.18.bill.proto
		c_gs.19.misc.proto
		c_gs.20.guild.proto
		c_gs.21.mopen.proto
		c_gs.23.counter.proto
		c_gs.24.rank.proto
		c_gs.26.taskdaily.proto
		c_gs.27.taskachv.proto
		c_gs.28.draw.proto
		c_gs.29.wlevel.proto
		c_gs.30.appoint.proto
		c_gs.31.tower.proto
		c_gs.32.teammgr.proto
		c_gs.33.arena.proto
		c_gs.34.shop.proto
		c_gs.35.marvelroll.proto
		c_gs.36.friend.proto
		c_gs.37.crusade.proto
		c_gs.38.vip.proto
		c_gs.40.act.proto
		c_gs.41.chat.proto
		c_gs.42.monthticket.proto
		c_gs.43.pushgift.proto
		c_gs.44.giftshop.proto
		c_gs.45.privcard.proto
		c_gs.46.signdaily.proto
		c_gs.47.taskmonth.proto
		c_gs.48.daysign.proto
		c_gs.49.targetdays.proto
		c_gs.50.taskgrow.proto
		c_gs.51.wlevelfund.proto
		c_gs.52.growfund.proto
		c_gs.53.billfirst.proto
		c_gs.54.lamp.proto
		c_gs.55.gwar.proto
		c_gs.56.rift.proto
		c_gs.57.ladder.proto
		c_gs.58.heroskin.proto
		c_gs.59.wleveldraw.proto
		c_gs.60.warcup.proto
		c_gs.61.wboss.proto
		c_gs.62.invite.proto

	It has these top-level messages:
		C_Auth
		GW_Auth_R
		C_Login
		GW_Login_R
		C_TokenGet
		GW_TokenGet_R
		C_TokenAuth
		GW_TokenAuth_R
		PlayerSimpleInfo
		Ccy
		Item
		Hero
		HeroDetail
		Trinket
		Armor
		Relic
		Rewards
		TeamFormation
		BattleFighter
		BattleTeam
		BattleInput
		BattleResult
		BattleReplay
		ForLoading
		GS_LoginError
		GS_UserInfo
		C_TimeSync
		GS_TimeSync_R
		GS_GameDataReloaded
		C_UserExtInfo
		GS_UserExtInfo_R
		HFrameStoreData
		HFrameStoreOne
		GS_PlayerUpdateLv
		GS_PlayerUpdateAtkPwr
		GS_PlayerUpdateHFrame
		C_PlayerChangeName
		GS_PlayerChangeName_R
		C_PlayerInfo
		GS_PlayerInfo_R
		C_PlayerHFrameAdd
		GS_PlayerHFrameAdd_R
		C_PlayerHFrameSet
		GS_PlayerHFrameSet_R
		C_PlayerHeadSet
		GS_PlayerHeadSet_R
		BagData
		GS_BagUpdate
		GS_ArmorUpdate_HeroSeq
		C_ItemExchange
		GS_ItemExchange_R
		C_ItemUse
		GS_ItemUse_R
		C_ArmorEquip
		GS_ArmorEquip_R
		C_ArmorUnequip
		GS_ArmorUnequip_R
		C_ArmorEquipOnekey
		GS_ArmorEquipOnekey_R
		C_ArmorUnequipOnekey
		GS_ArmorUnequipOnekey_R
		C_ArmorCompose
		GS_ArmorCompose_R
		C_ArmorComposeOnekey
		GS_ArmorComposeOnekey_R
		C_ItemChoose
		GS_ItemChoose_R
		HeroArray
		GS_HeroUpdate
		C_HeroLevelUp
		GS_HeroLevelUp_R
		C_HeroStarUp
		GS_HeroStarUp_R
		C_HeroLock
		GS_HeroLock_R
		C_HeroReset
		GS_HeroReset_R
		C_HeroDecompose
		GS_HeroDecompose_R
		C_HeroChange
		GS_HeroChange_R
		C_HeroChangeCancel
		GS_HeroChangeCancel_R
		C_HeroChangeApply
		GS_HeroChangeApply_R
		C_HeroTrinketUnlock
		GS_HeroTrinketUnlock_R
		C_HeroTrinketUp
		GS_HeroTrinketUp_R
		C_HeroTrinketTransformGen
		GS_HeroTrinketTransformGen_R
		C_HeroTrinketTransformCommit
		GS_HeroTrinketTransformCommit_R
		C_HeroBagBuy
		GS_HeroBagBuy_R
		C_HeroInherit
		GS_HeroInherit_R
		C_HeroSetSkin
		GS_HeroSetSkin_R
		GS_RelicUpdate_HeroSeq
		GS_RelicUpdate_Star
		C_RelicEquip
		GS_RelicEquip_R
		C_RelicUnequip
		GS_RelicUnequip_R
		C_RelicEat
		GS_RelicEat_R
		Mail
		MailRes
		MailExpire
		GS_MailNew
		GS_MailDel
		C_MailRead
		GS_MailRead_R
		C_MailDel
		GS_MailDel_R
		C_MailTakeAttachment
		GS_MailTakeAttachment_R
		C_MailTakeAttachmentAll
		GS_MailTakeAttachmentAll_R
		C_MailDelOnekey
		GS_MailDelOnekey_R
		C_CloudGet
		GS_CloudGet_R
		C_CloudSet
		GS_CloudSet_R
		TutorialData
		C_TutorialSet
		GS_TutorialSet_R
		ActState
		GS_ActStateChange
		C_ActStateGet
		GS_ActStateGet_R
		AttainTabData
		AttainObj
		GS_AttainTabObjValueChanged
		BillBuyCnt
		GS_BillDone
		GS_BillOrder
		C_BillInfo
		GS_BillInfo_R
		C_BillRefundCodeGet
		GS_BillRefundCodeGet_R
		C_BillRefundTake
		GS_BillRefundTake_R
		MiscData
		MiscGldActGiftOne
		GS_MiscGldActGift
		C_MiscBillLocal
		GS_MiscBillLocal_R
		C_GiftExchange
		GS_GiftExchange_R
		C_MiscSkipTutorial
		GS_MiscSkipTutorial_R
		C_MiscGoldenHand
		GS_MiscGoldenHand_R
		C_MiscOnlineBoxTake
		GS_MiscOnlineBoxTake_R
		C_MiscSharedGame
		GS_MiscSharedGame_R
		C_MiscGldActGiftTake
		GS_MiscGldActGiftTake_R
		GuildRow
		GuildInfo_Full
		GuildMemberInfo
		GuildApplyRow
		GuildLog
		GuildPlrData
		GS_GuildPlrLeaveTs
		GS_Guild_Join
		GS_Guild_Leave
		GS_Guild_MbRank
		GS_Guild_Lv
		GS_Guild_Notice
		GS_Guild_Icon
		GS_Guild_NewApply
		C_GuildCreate
		GS_GuildCreate_R
		C_GuildDestroy
		GS_GuildDestroy_R
		C_GuildChangeSetting
		GS_GuildChangeSetting_R
		C_GuildList
		GS_GuildList_R
		C_GuildPlrApplyList
		GS_GuildPlrApplyList_R
		C_GuildSearch
		GS_GuildSearch_R
		C_GuildApplyList
		GS_GuildApplyList_R
		C_GuildInfoFull
		GS_GuildInfoFull_R
		C_GuildApply
		GS_GuildApply_R
		C_GuildApplyCancel
		GS_GuildApplyCancel_R
		C_GuildApplyAccept
		GS_GuildApplyAccept_R
		C_GuildApplyDeny
		GS_GuildApplyDeny_R
		C_GuildLeave
		GS_GuildLeave_R
		C_GuildKick
		GS_GuildKick_R
		C_GuildSetRank
		GS_GuildSetRank_R
		C_GuildChangeName
		GS_GuildChangeName_R
		C_GuildApplyAcceptOneKey
		GS_GuildApplyAcceptOneKey_R
		C_GuildApplyDenyOneKey
		GS_GuildApplyDenyOneKey_R
		C_GuildKickOwner
		GS_GuildKickOwner_R
		C_GuildGetLog
		GS_GuildGetLog_R
		C_GuildSign
		GS_GuildSign_R
		C_GuildSetNotice
		GS_GuildSetNotice_R
		C_GuildSetIcon
		GS_GuildSetIcon_R
		C_GuildPublishZm
		GS_GuildPublishZm_R
		GuildWish
		GS_GuildWishNew
		GS_GuildWishFullHelp
		C_GuildWishItem
		GS_GuildWishItem_R
		C_GuildWishHelp
		GS_GuildWishHelp_R
		C_GuildWishClose
		GS_GuildWishClose_R
		C_GuildWishList
		GS_GuildWishList_R
		GuildHarborDonateRec
		GS_GuildHarborXpChange
		C_GuildHarborDonate
		GS_GuildHarborDonate_R
		C_GuildHarborDonateList
		GS_GuildHarborDonateList_R
		GuildOrderRec
		C_GuildOrderGet
		GS_GuildOrderGet_R
		C_GuildOrderStarup
		GS_GuildOrderStarup_R
		C_GuildOrderStart
		GS_GuildOrderStart_R
		C_GuildOrderClose
		GS_GuildOrderClose_R
		C_GuildOrderList
		GS_GuildOrderList_R
		C_GuildTechLevelup
		GS_GuildTechLevelup_R
		C_GuildTechReset
		GS_GuildTechReset_R
		C_GuildTechGetInfo
		GS_GuildTechGetInfo_R
		GuildBossHistory
		GuildBossDmg
		C_GuildBossFight
		GS_GuildBossFight_R
		C_GuildBossGetCurrent
		GS_GuildBossGetCurrent_R
		C_GuildBossGetHistory
		GS_GuildBossGetHistory_R
		MOpenData
		GS_MOpenModuleNew
		CounterData
		GS_CounterOpUpdate
		C_CounterRecover
		GS_CounterRecover_R
		C_CounterBuy
		GS_CounterBuy_R
		RankRow
		RankRowInfo
		RankPlayData
		C_RankGet
		GS_RankGet_R
		C_RankLike
		GS_RankLike_R
		TaskDailyData
		TaskDailyItem
		GS_TaskDailyValueChanged
		GS_TaskDailyItemCompleted
		C_TaskDailyInfo
		GS_TaskDailyInfo_R
		C_TaskDailyTakeBoxReward
		GS_TaskDailyTakeBoxReward_R
		TaskAchvData
		C_TaskAchvTake
		GS_TaskAchvTake_R
		DrawData
		DrawTpData
		C_DrawGetInfo
		GS_DrawGetInfo_R
		C_DrawTp
		GS_DrawTp_R
		C_DrawScoreBoxTake
		GS_DrawScoreBoxTake_R
		WLevelData
		C_WLevelFight
		GS_WLevelFight_R
		C_WLevelGJInfo
		GS_WLevelGJInfo_R
		C_WLevelGJTake
		GS_WLevelGJTake_R
		C_WLevelOneKeyGJTake
		GS_WLevelOneKeyGJTake_R
		C_WLevelFightOneKey
		GS_WLevelFightOneKey_R
		AppointData
		AppointTask
		GS_AppointAddTask
		C_AppointCheckAdd
		GS_AppointCheckAdd_R
		C_AppointRefresh
		GS_AppointRefresh_R
		C_AppointLock
		GS_AppointLock_R
		C_AppointSend
		GS_AppointSend_R
		C_AppointAcc
		GS_AppointAcc_R
		C_AppointTake
		GS_AppointTake_R
		C_AppointCancel
		GS_AppointCancel_R
		TowerData
		C_TowerFight
		GS_TowerFight_R
		C_TowerRaid
		GS_TowerRaid_R
		C_TowerRecord
		GS_TowerRecord_R
		TeamMgrData
		C_SetTeam
		GS_SetTeam_R
		ArenaData
		ArenaEnemy
		ArenaRecord
		GS_ArenaStageUpdate
		GS_ArenaFighted
		C_ArenaUpdateEnemy
		GS_ArenaUpdateEnemy_R
		C_ArenaFight
		GS_ArenaFight_R
		C_ArenaRecordInfo
		GS_ArenaRecordInfo_R
		C_ArenaRank
		GS_ArenaRank_R
		C_ArenaReplayGet
		GS_ArenaReplayGet_R
		ShopData
		Good
		C_ShopGetInfo
		GS_ShopGetInfo_R
		C_ShopBuy
		GS_ShopBuy_R
		C_ShopRefresh
		GS_ShopRefresh_R
		MarvelRollData
		MarvelRollGroup
		MarvelRollBlank
		C_MarvelRollInfo
		GS_MarvelRollInfo_R
		C_MarvelRollRefresh
		GS_MarvelRollRefresh_R
		C_MarvelRollTake
		GS_MarvelRollTake_R
		FriendData
		FriendInfo
		GS_FriendNewApplied
		GS_FriendNewFriend
		GS_FriendRemoveFriend
		GS_FriendRecv
		C_FriendGetFrds
		GS_FriendGetFrds_R
		C_FriendSearchFrds
		GS_FriendSearchFrds_R
		C_FriendRemoveFrds
		GS_FriendRemoveFrds_R
		C_FriendGetApplyList
		GS_FriendGetApplyList_R
		C_FriendApply
		GS_FriendApply_R
		C_FriendAccept
		GS_FriendAccept_R
		C_FriendGetBlackList
		GS_FriendGetBlackList_R
		C_FriendAddBlackList
		GS_FriendAddBlackList_R
		C_FriendGiveAndRecv
		GS_FriendGiveAndRecv_R
		CrusadeData
		CrusadeEnemy
		GS_CrusadeStageUpdate
		C_CrusadeGetInfo
		GS_CrusadeGetInfo_R
		C_CrusadeBoxTake
		GS_CrusadeBoxTake_R
		C_CrusadeFight
		GS_CrusadeFight_R
		VipData
		GS_VipUpdate
		ActAttainObj
		ActRushLocalRankData
		C_ActRushLocalGetInfo
		GS_ActRushLocalGetInfo_R
		C_ActRushLocalTake
		GS_ActRushLocalTake_R
		ActBillLtTotalData
		GS_ActBillLtTotal
		C_ActBillLtTotalInfo
		GS_ActBillLtTotalInfo_R
		C_ActBillLtTotalTake
		GS_ActBillLtTotalTake_R
		ActBillLtDayData
		C_ActBillLtDayInfo
		GS_ActBillLtDayInfo_R
		C_ActBillLtDayTake
		GS_ActBillLtDayTake_R
		GS_ActGiftNew
		ActSummonData
		C_ActSummonInfo
		GS_ActSummonInfo_R
		C_ActSummonPick
		GS_ActSummonPick_R
		C_ActSummonDraw
		GS_ActSummonDraw_R
		ActTargetTaskData
		GS_ActTargetTaskObjValueChanged
		C_ActTargetTaskInfo
		GS_ActTargetTaskInfo_R
		C_ActTargetTaskTake
		GS_ActTargetTaskTake_R
		ActHeroSkinData
		C_ActHeroSkinInfo
		GS_ActHeroSkinInfo_R
		ActMSummonData
		C_ActMSummonInfo
		GS_ActMSummonInfo_R
		C_ActMSummonDraw
		GS_ActMSummonDraw_R
		ActMonopolyData
		ActMonolyShopItem
		ActMonopolyAdvItem
		ActMonopolyBatItem
		GS_ActMonopolyObjValueChanged
		GS_ActMonoPolyNextLv
		GS_ActMonopolyBoxReward
		C_ActMonopolyInfo
		GS_ActMonoPolyInfo_R
		C_ActMonopolyNPos
		GS_ActMonopolyNPos_R
		C_ActMonopolyAnswer
		GS_ActMonopolyAnswer_R
		C_ActMonopolyBuy
		GS_ActMonopolyBuy_R
		C_ActMonopolyBattle
		GS_ActMonopolyBattle_R
		C_ActMonopolyTaskTake
		GS_ActMonopolyTaskTake_R
		ActMazeData
		TradeData
		BattleData
		GS_ActMazeObjValueChanged
		GS_ActMazeTaskTaken
		C_ActMazeInfo
		GS_ActMazeInfo_R
		C_ActMazeClick
		GS_ActMazeClick_R
		C_ActMazeClickNext
		GS_ActMazeClickNext_R
		C_ActMazeClickTrade
		GS_ActMazeClickTrade_R
		C_ActMazeReset
		GS_ActMazeReset_R
		C_ActMazeClickThing
		GS_ActMazeClickThing_R
		C_ActMazeClickBattle
		GS_ActMazeClickBattle_R
		C_ActMazeTakeTask
		GS_ActMazeTakeTask_R
		C_ActMazeBuff
		GS_ActMazeBuff_R
		ChatData
		ChatOne
		GS_ChatMsg
		C_ChatSend
		GS_ChatSend_R
		MonthTicketData
		MonthTicketItem
		GS_MonthTicketValueChanged
		GS_MonthTicketItemCompleted
		GS_MonthTicketIsBuy
		C_MonthTicketInfo
		GS_MonthTicketInfo_R
		C_MonthTicketTakeOneKey
		GS_MonthTicketTakeOneKey_R
		C_MonthTicketBuyUp
		GS_MonthTicketBuyUp_R
		C_MonthTicketTake
		GS_MonthTicketTake_R
		C_MonthTicketTaskTake
		GS_MonthTicketTaskTake_R
		PushGiftData
		PushGiftOne
		GS_PushGiftNew
		GS_PushGiftRewards
		C_PushGiftSetCreateTs
		GS_PushGiftSetCreateTs_R
		GiftShopData
		GS_GiftShopNew
		C_GiftShopTake
		GS_GiftShopTake_R
		PrivCardData
		PrivCard
		GS_PrivCardNew
		C_PrivCardTake
		GS_PrivCardTake_R
		SignDailyData
		C_SignDailySign
		GS_SignDailySign_R
		TaskMonthData
		TaskMonthItem
		GS_TaskMonthValueChanged
		GS_TaskMonthItemCompleted
		C_TaskMonthInfo
		GS_TaskMonthInfo_R
		C_TaskMonthTake
		GS_TaskMonthTask_R
		DaySignData
		C_DaySignTake
		GS_DaySignTake_R
		TargetDaysData
		C_TargetDaysTake
		GS_TargetDaysTake_R
		C_TargetDaysBuy
		GS_TargetDaysBuy_R
		TaskGrowData
		C_TaskGrowTake
		GS_TaskGrowTake_R
		WLevelFundData
		GS_WLevelFundNew
		C_WLevelFundTake
		GS_WLevelFundTake_R
		GrowFundData
		GS_GrowFundNew
		C_GrowFundInfo
		GS_GrowFundInfo_R
		C_GrowFundTakeLv
		GS_GrowFundTakeLv_R
		C_GrowFundTakeSvr
		GS_GrowFundTakeSvr_R
		BillFirstData
		BillFirstItem
		GS_BillFirstNew
		C_BillFirstTake
		GS_BillFirstTake_R
		LampData
		LampOne
		GS_LampMsg
		GWarData
		GWarGuildBase
		GWarGuildMember
		GWarGuildRankRow
		GWarPlrRankRow
		GS_GWarStageChange
		GS_GWarNewG2
		C_GWarGetSummary
		GS_GWarGetSummary_R
		C_GWarGetG2Members
		GS_GWarGetG2Members_R
		C_GWarGetGuildRank
		GS_GWarGetGuildRank_R
		C_GWarGetPlrRank
		GS_GWarGetPlrRank_R
		C_GWarFight
		GS_GWarFight_R
		RiftData
		RiftMonster
		RiftPlrMine
		RiftMine
		RiftBox
		GS_RiftMonsterNew
		GS_RiftMineNew
		GS_RiftMineOccupied
		GS_RiftBoxNew
		GS_RiftBoxRewards
		GS_RiftBoxOccupied
		C_RiftExplore
		GS_RiftExplore_R
		C_RiftMonsterFight
		GS_RiftMonsterFight_R
		C_RiftMineInfo
		GS_RiftMineInfo_R
		C_RiftMineOccupy
		GS_RiftMineOccupy_R
		C_RiftMineCancel
		GS_RiftMineCancel_R
		C_RiftMineTakeRewards
		GS_RiftMineTakeRewards_R
		C_RiftBoxOccupy
		GS_RiftBoxOccupy_R
		C_RiftBoxInfo
		GS_RiftBoxInfo_R
		LadderData
		LadderPlayerInfo
		LadderReplayRec
		GS_LadderStageChange
		C_LadderGetSummary
		GS_LadderGetSummary_R
		C_LadderMatch
		GS_LadderMatch_R
		C_LadderFight
		GS_LadderFight_R
		C_LadderGetRank
		GS_LadderGetRank_R
		C_LadderGetReplayList
		GS_LadderGetReplayList_R
		C_LadderGetReplay
		GS_LadderGetReplay_R
		HeroSkinData
		C_HeroSkinAdd
		GS_HeroSkinAdd_R
		C_HeroSkinLvUp
		GS_HeroSkinLvUp_R
		WLevelDrawData
		WLevelDrawItem
		C_WLevelDrawDraw
		GS_WLevelDrawDraw_R
		C_WLevelDrawTake
		GS_WLevelDrawTake_R
		WarCupData
		WarCupGuessData
		WarCupPlrGuessOne
		WarCupVsData
		WarCupAttainObj
		WarCupChatOne
		GS_WarCupStageUpdate
		GS_WarCupChat
		GS_WarCupGuessRatio
		GS_WarCupAttainObjValueChanged
		C_WarCupGuessInfo
		GS_WarCupGuessInfo_R
		C_WarCupSelfInfo
		GS_WarCupSelfInfo_R
		C_WarCupTop64Info
		GS_WarCupTop64Info_R
		C_WarCupTop8Info
		GS_WarCupTop8Info_R
		C_WarCupGuess
		GS_WarCupGuess_R
		C_WarCupAuditionRank
		GS_WarCupAuditionRank_R
		C_WarCupChatSend
		GS_WarCupChatSend_R
		C_WarCupGetReplay
		GS_WarCupGetReplay_R
		C_WarCupTop1Info
		GS_WarCupTop1Info_R
		C_WarCupTaskTake
		GS_WarCupTaskTake_R
		C_WarCupWatch
		C_WarCupGuessRecords
		GS_WarCupGuessRecords_R
		WBossData
		WBossMaxDmgInfo
		WBossRankRow
		GS_WBossStageChange
		C_WBossGetSummary
		GS_WBossGetSummary_R
		C_WBossFight
		GS_WBossFight_R
		C_WBossTakeMaxDmgRwd
		GS_WBossTakeMaxDmgRwd_R
		C_WBossGetRank
		GS_WBossGetRank_R
		C_WBossGetMaxDmgInfo
		GS_WBossGetMaxDmgInfo_R
		C_WBossGetSelfRank
		GS_WBossGetSelfRank_R
		InviteData
		C_InviteInfo
		GS_InviteInfo_R
		C_InviteTake
		GS_InviteTake_R
*/
package msg

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// 认证
type C_Auth struct {
	AuthId    string `protobuf:"bytes,1,opt,name=AuthId,proto3" json:"AuthId,omitempty"`
	AuthToken string `protobuf:"bytes,2,opt,name=AuthToken,proto3" json:"AuthToken,omitempty"`
	Sdk       string `protobuf:"bytes,3,opt,name=Sdk,proto3" json:"Sdk,omitempty"`
	Model     string `protobuf:"bytes,4,opt,name=Model,proto3" json:"Model,omitempty"`
	DevId     string `protobuf:"bytes,5,opt,name=DevId,proto3" json:"DevId,omitempty"`
	Os        string `protobuf:"bytes,6,opt,name=Os,proto3" json:"Os,omitempty"`
	OsVer     string `protobuf:"bytes,7,opt,name=OsVer,proto3" json:"OsVer,omitempty"`
	J         string `protobuf:"bytes,8,opt,name=J,proto3" json:"J,omitempty"`
	VerMajor  string `protobuf:"bytes,9,opt,name=VerMajor,proto3" json:"VerMajor,omitempty"`
	VerMinor  string `protobuf:"bytes,10,opt,name=VerMinor,proto3" json:"VerMinor,omitempty"`
	VerBuild  string `protobuf:"bytes,11,opt,name=VerBuild,proto3" json:"VerBuild,omitempty"`
}

func (m *C_Auth) Reset()                    { *m = C_Auth{} }
func (m *C_Auth) String() string            { return proto.CompactTextString(m) }
func (*C_Auth) ProtoMessage()               {}
func (*C_Auth) Descriptor() ([]byte, []int) { return fileDescriptorCGw_01Login, []int{0} }

type GW_Auth_R struct {
	ErrorCode int32             `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	AuthId    string            `protobuf:"bytes,2,opt,name=AuthId,proto3" json:"AuthId,omitempty"`
	C         map[string]string `protobuf:"bytes,3,rep,name=C" json:"C,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *GW_Auth_R) Reset()                    { *m = GW_Auth_R{} }
func (m *GW_Auth_R) String() string            { return proto.CompactTextString(m) }
func (*GW_Auth_R) ProtoMessage()               {}
func (*GW_Auth_R) Descriptor() ([]byte, []int) { return fileDescriptorCGw_01Login, []int{1} }

// 登录
type C_Login struct {
	Svr0     string `protobuf:"bytes,1,opt,name=Svr0,proto3" json:"Svr0,omitempty"`
	ChgSvr   bool   `protobuf:"varint,2,opt,name=ChgSvr,proto3" json:"ChgSvr,omitempty"`
	Language string `protobuf:"bytes,3,opt,name=Language,proto3" json:"Language,omitempty"`
}

func (m *C_Login) Reset()                    { *m = C_Login{} }
func (m *C_Login) String() string            { return proto.CompactTextString(m) }
func (*C_Login) ProtoMessage()               {}
func (*C_Login) Descriptor() ([]byte, []int) { return fileDescriptorCGw_01Login, []int{2} }

type GW_Login_R struct {
	ErrorCode int32 `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
}

func (m *GW_Login_R) Reset()                    { *m = GW_Login_R{} }
func (m *GW_Login_R) String() string            { return proto.CompactTextString(m) }
func (*GW_Login_R) ProtoMessage()               {}
func (*GW_Login_R) Descriptor() ([]byte, []int) { return fileDescriptorCGw_01Login, []int{3} }

// token 获取
type C_TokenGet struct {
}

func (m *C_TokenGet) Reset()                    { *m = C_TokenGet{} }
func (m *C_TokenGet) String() string            { return proto.CompactTextString(m) }
func (*C_TokenGet) ProtoMessage()               {}
func (*C_TokenGet) Descriptor() ([]byte, []int) { return fileDescriptorCGw_01Login, []int{4} }

type GW_TokenGet_R struct {
	ErrorCode int32  `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Token     string `protobuf:"bytes,2,opt,name=Token,proto3" json:"Token,omitempty"`
}

func (m *GW_TokenGet_R) Reset()                    { *m = GW_TokenGet_R{} }
func (m *GW_TokenGet_R) String() string            { return proto.CompactTextString(m) }
func (*GW_TokenGet_R) ProtoMessage()               {}
func (*GW_TokenGet_R) Descriptor() ([]byte, []int) { return fileDescriptorCGw_01Login, []int{5} }

// token 认证
type C_TokenAuth struct {
	Token  string `protobuf:"bytes,1,opt,name=Token,proto3" json:"Token,omitempty"`
	AuthId string `protobuf:"bytes,2,opt,name=AuthId,proto3" json:"AuthId,omitempty"`
	Sdk    string `protobuf:"bytes,3,opt,name=Sdk,proto3" json:"Sdk,omitempty"`
	DevId  string `protobuf:"bytes,4,opt,name=DevId,proto3" json:"DevId,omitempty"`
}

func (m *C_TokenAuth) Reset()                    { *m = C_TokenAuth{} }
func (m *C_TokenAuth) String() string            { return proto.CompactTextString(m) }
func (*C_TokenAuth) ProtoMessage()               {}
func (*C_TokenAuth) Descriptor() ([]byte, []int) { return fileDescriptorCGw_01Login, []int{6} }

type GW_TokenAuth_R struct {
	ErrorCode int32 `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
}

func (m *GW_TokenAuth_R) Reset()                    { *m = GW_TokenAuth_R{} }
func (m *GW_TokenAuth_R) String() string            { return proto.CompactTextString(m) }
func (*GW_TokenAuth_R) ProtoMessage()               {}
func (*GW_TokenAuth_R) Descriptor() ([]byte, []int) { return fileDescriptorCGw_01Login, []int{7} }

func init() {
	proto.RegisterType((*C_Auth)(nil), "msg.C_Auth")
	proto.RegisterType((*GW_Auth_R)(nil), "msg.GW_Auth_R")
	proto.RegisterType((*C_Login)(nil), "msg.C_Login")
	proto.RegisterType((*GW_Login_R)(nil), "msg.GW_Login_R")
	proto.RegisterType((*C_TokenGet)(nil), "msg.C_TokenGet")
	proto.RegisterType((*GW_TokenGet_R)(nil), "msg.GW_TokenGet_R")
	proto.RegisterType((*C_TokenAuth)(nil), "msg.C_TokenAuth")
	proto.RegisterType((*GW_TokenAuth_R)(nil), "msg.GW_TokenAuth_R")
}
func (m *C_Auth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_Auth) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AuthId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCGw_01Login(dAtA, i, uint64(len(m.AuthId)))
		i += copy(dAtA[i:], m.AuthId)
	}
	if len(m.AuthToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGw_01Login(dAtA, i, uint64(len(m.AuthToken)))
		i += copy(dAtA[i:], m.AuthToken)
	}
	if len(m.Sdk) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCGw_01Login(dAtA, i, uint64(len(m.Sdk)))
		i += copy(dAtA[i:], m.Sdk)
	}
	if len(m.Model) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCGw_01Login(dAtA, i, uint64(len(m.Model)))
		i += copy(dAtA[i:], m.Model)
	}
	if len(m.DevId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCGw_01Login(dAtA, i, uint64(len(m.DevId)))
		i += copy(dAtA[i:], m.DevId)
	}
	if len(m.Os) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCGw_01Login(dAtA, i, uint64(len(m.Os)))
		i += copy(dAtA[i:], m.Os)
	}
	if len(m.OsVer) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCGw_01Login(dAtA, i, uint64(len(m.OsVer)))
		i += copy(dAtA[i:], m.OsVer)
	}
	if len(m.J) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCGw_01Login(dAtA, i, uint64(len(m.J)))
		i += copy(dAtA[i:], m.J)
	}
	if len(m.VerMajor) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCGw_01Login(dAtA, i, uint64(len(m.VerMajor)))
		i += copy(dAtA[i:], m.VerMajor)
	}
	if len(m.VerMinor) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCGw_01Login(dAtA, i, uint64(len(m.VerMinor)))
		i += copy(dAtA[i:], m.VerMinor)
	}
	if len(m.VerBuild) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintCGw_01Login(dAtA, i, uint64(len(m.VerBuild)))
		i += copy(dAtA[i:], m.VerBuild)
	}
	return i, nil
}

func (m *GW_Auth_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GW_Auth_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGw_01Login(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.AuthId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGw_01Login(dAtA, i, uint64(len(m.AuthId)))
		i += copy(dAtA[i:], m.AuthId)
	}
	if len(m.C) > 0 {
		for k, _ := range m.C {
			dAtA[i] = 0x1a
			i++
			v := m.C[k]
			mapSize := 1 + len(k) + sovCGw_01Login(uint64(len(k))) + 1 + len(v) + sovCGw_01Login(uint64(len(v)))
			i = encodeVarintCGw_01Login(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCGw_01Login(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintCGw_01Login(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *C_Login) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_Login) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Svr0) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCGw_01Login(dAtA, i, uint64(len(m.Svr0)))
		i += copy(dAtA[i:], m.Svr0)
	}
	if m.ChgSvr {
		dAtA[i] = 0x10
		i++
		if m.ChgSvr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Language) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCGw_01Login(dAtA, i, uint64(len(m.Language)))
		i += copy(dAtA[i:], m.Language)
	}
	return i, nil
}

func (m *GW_Login_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GW_Login_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGw_01Login(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *C_TokenGet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_TokenGet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GW_TokenGet_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GW_TokenGet_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGw_01Login(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGw_01Login(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	return i, nil
}

func (m *C_TokenAuth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_TokenAuth) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCGw_01Login(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	if len(m.AuthId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCGw_01Login(dAtA, i, uint64(len(m.AuthId)))
		i += copy(dAtA[i:], m.AuthId)
	}
	if len(m.Sdk) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCGw_01Login(dAtA, i, uint64(len(m.Sdk)))
		i += copy(dAtA[i:], m.Sdk)
	}
	if len(m.DevId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCGw_01Login(dAtA, i, uint64(len(m.DevId)))
		i += copy(dAtA[i:], m.DevId)
	}
	return i, nil
}

func (m *GW_TokenAuth_R) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GW_TokenAuth_R) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCGw_01Login(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func encodeVarintCGw_01Login(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *C_Auth) Size() (n int) {
	var l int
	_ = l
	l = len(m.AuthId)
	if l > 0 {
		n += 1 + l + sovCGw_01Login(uint64(l))
	}
	l = len(m.AuthToken)
	if l > 0 {
		n += 1 + l + sovCGw_01Login(uint64(l))
	}
	l = len(m.Sdk)
	if l > 0 {
		n += 1 + l + sovCGw_01Login(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovCGw_01Login(uint64(l))
	}
	l = len(m.DevId)
	if l > 0 {
		n += 1 + l + sovCGw_01Login(uint64(l))
	}
	l = len(m.Os)
	if l > 0 {
		n += 1 + l + sovCGw_01Login(uint64(l))
	}
	l = len(m.OsVer)
	if l > 0 {
		n += 1 + l + sovCGw_01Login(uint64(l))
	}
	l = len(m.J)
	if l > 0 {
		n += 1 + l + sovCGw_01Login(uint64(l))
	}
	l = len(m.VerMajor)
	if l > 0 {
		n += 1 + l + sovCGw_01Login(uint64(l))
	}
	l = len(m.VerMinor)
	if l > 0 {
		n += 1 + l + sovCGw_01Login(uint64(l))
	}
	l = len(m.VerBuild)
	if l > 0 {
		n += 1 + l + sovCGw_01Login(uint64(l))
	}
	return n
}

func (m *GW_Auth_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGw_01Login(uint64(m.ErrorCode))
	}
	l = len(m.AuthId)
	if l > 0 {
		n += 1 + l + sovCGw_01Login(uint64(l))
	}
	if len(m.C) > 0 {
		for k, v := range m.C {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCGw_01Login(uint64(len(k))) + 1 + len(v) + sovCGw_01Login(uint64(len(v)))
			n += mapEntrySize + 1 + sovCGw_01Login(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *C_Login) Size() (n int) {
	var l int
	_ = l
	l = len(m.Svr0)
	if l > 0 {
		n += 1 + l + sovCGw_01Login(uint64(l))
	}
	if m.ChgSvr {
		n += 2
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovCGw_01Login(uint64(l))
	}
	return n
}

func (m *GW_Login_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGw_01Login(uint64(m.ErrorCode))
	}
	return n
}

func (m *C_TokenGet) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GW_TokenGet_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGw_01Login(uint64(m.ErrorCode))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovCGw_01Login(uint64(l))
	}
	return n
}

func (m *C_TokenAuth) Size() (n int) {
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovCGw_01Login(uint64(l))
	}
	l = len(m.AuthId)
	if l > 0 {
		n += 1 + l + sovCGw_01Login(uint64(l))
	}
	l = len(m.Sdk)
	if l > 0 {
		n += 1 + l + sovCGw_01Login(uint64(l))
	}
	l = len(m.DevId)
	if l > 0 {
		n += 1 + l + sovCGw_01Login(uint64(l))
	}
	return n
}

func (m *GW_TokenAuth_R) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCGw_01Login(uint64(m.ErrorCode))
	}
	return n
}

func sovCGw_01Login(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCGw_01Login(x uint64) (n int) {
	return sovCGw_01Login(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *C_Auth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGw_01Login
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_Auth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_Auth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGw_01Login
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGw_01Login
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGw_01Login
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGw_01Login
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sdk", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGw_01Login
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGw_01Login
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sdk = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGw_01Login
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGw_01Login
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGw_01Login
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGw_01Login
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DevId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Os", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGw_01Login
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGw_01Login
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Os = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsVer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGw_01Login
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGw_01Login
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OsVer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field J", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGw_01Login
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGw_01Login
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.J = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerMajor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGw_01Login
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGw_01Login
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerMajor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerMinor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGw_01Login
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGw_01Login
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerMinor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerBuild", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGw_01Login
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGw_01Login
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerBuild = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGw_01Login(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGw_01Login
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GW_Auth_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGw_01Login
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GW_Auth_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GW_Auth_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGw_01Login
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGw_01Login
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGw_01Login
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field C", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGw_01Login
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCGw_01Login
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.C == nil {
				m.C = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCGw_01Login
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGw_01Login
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCGw_01Login
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCGw_01Login
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCGw_01Login
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCGw_01Login(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCGw_01Login
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.C[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGw_01Login(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGw_01Login
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_Login) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGw_01Login
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_Login: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_Login: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svr0", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGw_01Login
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGw_01Login
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Svr0 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChgSvr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGw_01Login
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ChgSvr = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGw_01Login
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGw_01Login
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGw_01Login(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGw_01Login
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GW_Login_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGw_01Login
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GW_Login_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GW_Login_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGw_01Login
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGw_01Login(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGw_01Login
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_TokenGet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGw_01Login
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_TokenGet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_TokenGet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCGw_01Login(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGw_01Login
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GW_TokenGet_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGw_01Login
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GW_TokenGet_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GW_TokenGet_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGw_01Login
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGw_01Login
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGw_01Login
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGw_01Login(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGw_01Login
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_TokenAuth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGw_01Login
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_TokenAuth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_TokenAuth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGw_01Login
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGw_01Login
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGw_01Login
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGw_01Login
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sdk", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGw_01Login
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGw_01Login
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sdk = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGw_01Login
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCGw_01Login
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DevId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCGw_01Login(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGw_01Login
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GW_TokenAuth_R) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCGw_01Login
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GW_TokenAuth_R: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GW_TokenAuth_R: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCGw_01Login
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCGw_01Login(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCGw_01Login
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCGw_01Login(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCGw_01Login
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCGw_01Login
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCGw_01Login
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCGw_01Login
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCGw_01Login
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCGw_01Login(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCGw_01Login = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCGw_01Login   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("c_gw.01.login.proto", fileDescriptorCGw_01Login) }

var fileDescriptorCGw_01Login = []byte{
	// 450 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x93, 0xcf, 0x6e, 0xd3, 0x40,
	0x10, 0xc6, 0xbb, 0x76, 0xe2, 0x26, 0x93, 0x52, 0xa1, 0x25, 0xa0, 0x55, 0x84, 0xac, 0x6a, 0xb9,
	0x54, 0x1c, 0xac, 0xf2, 0xe7, 0x80, 0xb8, 0xd1, 0xa5, 0x8a, 0x5a, 0xb5, 0x8a, 0x70, 0x50, 0x73,
	0xb4, 0x42, 0xbd, 0xda, 0x86, 0xa4, 0x5e, 0xb4, 0x4e, 0x8c, 0x7a, 0xe7, 0x01, 0x78, 0x00, 0x1e,
	0xa8, 0x47, 0x1e, 0x01, 0xc2, 0x8b, 0xa0, 0x9d, 0xdd, 0x3a, 0x46, 0x02, 0x95, 0x53, 0xe6, 0xf7,
	0xcd, 0x78, 0xb4, 0xf3, 0xcd, 0x04, 0x1e, 0x5c, 0x64, 0xea, 0x73, 0x72, 0xf0, 0x2c, 0x59, 0x68,
	0x35, 0x2b, 0x92, 0x4f, 0x46, 0x2f, 0x35, 0x0d, 0xaf, 0x4a, 0x35, 0x00, 0xa5, 0x95, 0x76, 0x02,
	0xff, 0x12, 0x40, 0x24, 0xb2, 0x37, 0xab, 0xe5, 0x25, 0x7d, 0x04, 0x91, 0xfd, 0x3d, 0xce, 0x19,
	0xd9, 0x23, 0xfb, 0xdd, 0xd4, 0x13, 0x7d, 0x0c, 0x5d, 0x1b, 0xbd, 0xd7, 0x73, 0x59, 0xb0, 0x00,
	0x53, 0x1b, 0x81, 0xde, 0x87, 0x70, 0x9c, 0xcf, 0x59, 0x88, 0xba, 0x0d, 0x69, 0x1f, 0xda, 0x67,
	0x3a, 0x97, 0x0b, 0xd6, 0x42, 0xcd, 0x81, 0x55, 0xdf, 0xca, 0xea, 0x38, 0x67, 0x6d, 0xa7, 0x22,
	0xd0, 0x5d, 0x08, 0x46, 0x25, 0x8b, 0x50, 0x0a, 0x46, 0xa5, 0xad, 0x1a, 0x95, 0xe7, 0xd2, 0xb0,
	0x6d, 0x57, 0x85, 0x40, 0x77, 0x80, 0x9c, 0xb0, 0x0e, 0x2a, 0xe4, 0x84, 0x0e, 0xa0, 0x73, 0x2e,
	0xcd, 0xd9, 0xf4, 0xa3, 0x36, 0xac, 0x8b, 0x62, 0xcd, 0xb7, 0xb9, 0x59, 0xa1, 0x0d, 0x83, 0x4d,
	0xce, 0xb2, 0xcf, 0x1d, 0xae, 0x66, 0x8b, 0x9c, 0xf5, 0xea, 0x1c, 0x32, 0xff, 0x46, 0xa0, 0x3b,
	0x9c, 0xa0, 0x0f, 0x59, 0x6a, 0x27, 0x3e, 0x32, 0x46, 0x1b, 0xa1, 0x73, 0x89, 0x66, 0xb4, 0xd3,
	0x8d, 0xd0, 0xf0, 0x29, 0xf8, 0xc3, 0xa7, 0x27, 0x40, 0x04, 0x0b, 0xf7, 0xc2, 0xfd, 0xde, 0xf3,
	0x87, 0xc9, 0x55, 0xa9, 0x92, 0xba, 0x61, 0x22, 0x8e, 0x8a, 0xa5, 0xb9, 0x4e, 0x89, 0x18, 0xbc,
	0x84, 0xc8, 0x81, 0x35, 0x6e, 0x2e, 0xaf, 0xbd, 0xd7, 0x36, 0xb4, 0xc3, 0x57, 0xd3, 0xc5, 0x4a,
	0xfa, 0xbe, 0x0e, 0x5e, 0x07, 0xaf, 0x08, 0x7f, 0x07, 0xdb, 0x22, 0x3b, 0xb5, 0x7b, 0xa4, 0x14,
	0x5a, 0xe3, 0xca, 0x1c, 0xf8, 0xef, 0x30, 0xb6, 0x2f, 0x12, 0x97, 0x6a, 0x5c, 0x19, 0xfc, 0xb2,
	0x93, 0x7a, 0xb2, 0x13, 0x9f, 0x4e, 0x0b, 0xb5, 0x9a, 0x2a, 0xe9, 0x17, 0x54, 0x33, 0x7f, 0x0a,
	0x30, 0x9c, 0xb8, 0x9e, 0x77, 0x4d, 0xcc, 0x77, 0x00, 0x44, 0x86, 0xeb, 0x1e, 0xca, 0x25, 0x17,
	0x70, 0x6f, 0x38, 0xa9, 0xf1, 0x4e, 0xbb, 0xfa, 0xd0, 0x6e, 0x9e, 0x8e, 0x03, 0x7e, 0x01, 0x3d,
	0xdf, 0x12, 0x6f, 0xaf, 0x2e, 0x22, 0x8d, 0xa2, 0x7f, 0x3a, 0xfd, 0xd7, 0x9b, 0x73, 0xd7, 0xd5,
	0x6a, 0x5c, 0x17, 0x4f, 0x60, 0xf7, 0xf6, 0xa5, 0xff, 0xb3, 0xd9, 0xc3, 0xfe, 0xcd, 0xcf, 0x78,
	0xeb, 0x66, 0x1d, 0x93, 0xef, 0xeb, 0x98, 0xfc, 0x58, 0xc7, 0xe4, 0xeb, 0xaf, 0x78, 0xeb, 0x43,
	0x84, 0xff, 0x94, 0x17, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0x78, 0x6d, 0x7d, 0x03, 0x51, 0x03,
	0x00, 0x00,
}
